[{"categories":[""],"content":"Flutter是怎么操作Android键盘的？\n","description":"","tags":["Flutter","PlatformView"],"title":"Flutter中的键盘操作","uri":"/posts/flutter/flutter%E4%B8%AD%E7%9A%84%E9%94%AE%E7%9B%98%E6%93%8D%E4%BD%9C/"},{"categories":[""],"content":"  PlatformView如何使用？\n  Android原生组件是如何渲染到Flutter view中的？\n  s bgbhynygtygr56tgb nn ikt6yhb nb8';;lppp\n  ","description":"","tags":["Flutter","PlatformView"],"title":"PlatformView学习记录","uri":"/posts/flutter/platformview%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"近期运营反映了一个问题，\n","description":"","tags":["Google play","apk签名","线上问题"],"title":"记一次 Google play 的「Play App Signing」服务导致的线上问题。","uri":"/posts/%E5%BA%94%E7%94%A8%E4%B8%8A%E6%9E%B6/play-app-signing%E9%87%8D%E7%AD%BE%E5%90%8D%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"","description":"","tags":null,"title":"Title_of_the_post","uri":"/posts/title_of_the_post/"},{"categories":["管理"],"content":" 学习是被逼出来的。\n 吉刻联盟 CTO 王潇俊如是说。\n《从“996ICU”引发的技术团队建设问题》的学习笔记。\n 开放的心态来分析企业加班的原因和解决方法。\n 关于996ICU  没有996的公司存在吗？ 谁在鼓励996？ 谁在批判996？ 你对996是什么态度？ 给996定个性  996并不是坏事情，它确实是个福报 open心态   669！  996是什么    996是怎么产生的   996的原罪\n  马克思：《资本论》\n 劳动价值量是由劳动量来决定的\n  劳动量由劳动时间来决定？没有证明\n   脑力劳动的劳动价值度量问题\n 很难，暂时没有办法量化    程序员预估工作时间时，经常蜜汁自信\n 造成工作量和已定时间不符合\n   民族文化：“努力才有成功的机会”\n    该如何处理996的问题   通过技术来解决工作时间过长的问题\n  我们不排斥加班，但我们唾弃无意义加班\n  企业的生命周期\n  孕育期\n 技术创业 vs 技术入股 现在战略上的懒惰会造成以后战术上的加班    婴儿期\n 996有成就感 团队简单，彼此支撑 目标活下去 一流人才招一流人才，二流人才招三流人才    学步期 - 有一定成绩\n  质量问题严重\n  人员分工模糊\n  盲目的做减法\n 减法的精髓是做聚焦\n     青春期\n 冲突  新团队 VS 老团队 新制度 VS 老制度 新业务 VS 老业务 新架构 VS 老代码      盛年期\n  不平衡\n 忙得忙死，闲的闲死\n   四种员工\n  象龟\n 老员工，积极不激进\n   鲶鱼\n 新员工，积极又激进\n   蜗牛/小白兔\n 混日子，\n   蠢驴\n 态度不对还很激进\n    把员工像鲶鱼转换\n     稳定期\n 号召二次创业，意味着要加班 研发开销缩减    贵族期\n 虚  对表面形式的重视远远多过实际的价值 996变成了最好的表象 内部创新        总结  了解员工的期望，使工作富有成效，使其有成就感 利用智慧解决996 ","description":"","tags":["30天学习打卡"],"title":"996并不是坏事情，它确实是个福报","uri":"/posts/management/3%E6%9C%888%E6%97%A5/"},{"categories":["管理"],"content":" 做技术的要有一颗敬畏业务的心。\n 百度外卖技术总监 廖雪梅如是说。\n《强业务驱动的互联网+时代，技术管理的坑与路》的学习笔记。\n 接地气的经验分享，值得学习。\n 时代在变化   码农鄙视链\n 高并发、AI 底层服务 业务逻辑系统 内部管理系统   发展在逆袭，越来越多的人从纯技术跑去做业务了\n   两类典型产品形态  流量分发  人与信息的连接 产品：相对轻，比如百度搜索、地图、广告 技术：指标相对单一，精细化 技术建立壁垒，技术为王 管理：能者上，一切围绕技术   互联网+  技术对传统行业流程的改造 产品：闭环，重，比如百度外卖，新零售 技术：指标多，关注整体 业务驱动，效率优先    互联网+时代踩过的坑  需求理解难，PK更难  专业数据越来越多 想象不到的使用方案 强制业务要求 行业玩法   项目节奏，计划赶不上变化  行业新 需求琐碎 人少事多   越来越没成就感了？  没有技术挑战  后端：用户量小 前端：页面大同小异 测试：做不完的功能测试，自动化迟迟推不动   技术优化的效果还不如业务决策 花费时间学习业务，换个行业还有价值吗？    我的填坑之路   需求管理\n 大需求PK的曲折经历  没人力，投入产出比低 法宝：竟对对比？数据说话？ 实地看一看？   硬件设备适配  覆盖二八原则，覆盖主流设备 非主流用户？ 核心链路永远需要100%甚至200%   行业的敬畏心  不了解行业就无法平等对话 互联网+不是将互联网的套用到传统行业，二十在理解行业的基础之上再发回互联网的价值   烂尾项目  业务调整，试错 MVP（最小化可行产品） 行业先行摸索，产品化只是提高小绿的过程      项目管理\n 大量需求，缺少人员怎么办  对内  立体沟通机制 需求优先级机制 避免讲究，要做就做好   对外  规定发版周期 项目风险评估 个人战斗力提升     我的思考  资源永远是不够的 用心做好项目管理，激发个人潜能 团队的战斗力来自于一起奋战 横向团队的信任来自不断的沟通，更来自每次高质量的交付      人的破局  价值感从哪里来  技术的进步推动了互联网+的出现  基础应用：移动支付、定位、基础组件 原材料更丰富了   技术的挑战在于复合，更复杂的业务场景，更能彰显技术 技术提升效率  开发效率：前端组件库、打包工具等 技术解放生产力：异常业务自动上报   技术的价值更来自业务  真实看线下的实际应用 对一个行业的深入理解     如何快乐地做事  团队文化  强调问题解决而不是纯技术 主动、责任心   技术氛围建设  技术分享 不同阶段成长规划   团队氛围建设    变中之不变  项目质量和服务稳定性是技术团队的生命线  充分理解需求 责任心 对外服务业务 对内服务团队   内功：技术、管理 行业敬畏心 服务心态 ","description":"","tags":["30天学习打卡"],"title":"技术管理者的经验分享","uri":"/posts/management/3%E6%9C%887%E6%97%A5/"},{"categories":["创业"],"content":" 中国技术创新时代已经到来了。\n 远望资本创始合伙人、迅雷创始人 程浩如是说。\n《技术创新VS商业创新，中国下一个10年的创业机会》的学习笔记。\n 由于极客邦视频缺失，只有前8分钟，然后在MySlide找到了演讲PPT，通过看PPT学习了后续内容。\n 中国过去20年，为什么以模式创业为主？  流量红利 资本红利  为什么说中国技术创新时代已来？   流量红利消失，互联网进入下半场时代\n  互联网解决的核心问题，提高生产效率\n 提高生产效率就要需要技术创新\n   如何把握技术创新的机会？  创业的赛道要建立在大势和红利之上   互联网行业发展随时代变迁，顺之则昌\n   开放平台红利\n  BAT\n  小米\n  TMD\n 很多大企业都在构建开放平台来搭建自己的互联网生态圈，我们要善于利用这些平台\n   赛道选择不纠结技术主导   先选赛道 每条赛道都有自己的基因 赛道的基因要和CEO的基因吻合 不要有必须当老大的心态   To C的CEO是首席产品经理，To B的CEO是首席销售\n  要用户/客户导向，永远不要纯技术向\n  技术领先 ≠ 商业成功\n  技术创业要做“全栈”，不只做“技术提供商”\n   技术、产品、商业、数据 四者循环：\n技术创造产品，产品应用于商业，商业产生数据，数据是技术根基。\n “关键性应用” 技术创业要耐得住寂寞 ","description":"","tags":["30天学习打卡"],"title":"技术创新VS商业创新，中国下一个10年的创业机会","uri":"/posts/3%E6%9C%886%E6%97%A5/"},{"categories":["创业"],"content":" 事多的麻烦客户，才是最能帮助你打磨产品的客户。\n 经纬创投董事总经理 熊飞如是说。\n《技术方向创业的战略选择和执行经验》的学习笔记。\n 技术创业，要洞察技术发展趋势，相信纯粹的技术。\nInfra是Infrastructure的简称，中文译为基础设施。\n 近几年Infra创业新趋势  3-5亿估值规模的公司大量增加，比如TiDB、七牛、GrowingIO等 数家公司收入规模达到亿元量级，且保持告诉增长 创业机会极大增加  美国Infra公司创业持续繁荣 数家高收入公司已经出现 整体生态愈发繁荣，口碑效应显著    原因   人越来越贵，全国就业人员年平均工资上涨迅速\n  各行各业业务互联网化成为趋势\n 各行各业互联网化是非常实际的趋势\n   人情数据价值：尽可能收集数据，分析数据，使用数据\n 互联网产品收集数据成瘾\n   机会如何选择赛道   数据\n  分布式数据库\n  新型数据库\n lot、图数据库\n   在线数据分析\n    新技术架构变迁\n  容器（安全、超融合）\n  Lambda（Serveless）\n  软件定义网络\n  软件定义储存\n 云计算时代，有很多Infra相关的机会\n     机器学习应用\n  如何赢得资本青睐   先人一步\n 技术创业，没有1-2年，是磨不出好产品的\n当1%的人看出这个趋势时，就要有人奋不顾身的开始了，大家都看出趋势时，那就没机会了。\n先人一步，才能找到敢吃螃蟹的第一批客户，可以共同成长\n事多，麻烦的客户，是可以把你产品打磨成精品的磨刀石\n   在大市场中系统性解决问题\n  一流的相互信任和互补的团队\n  尽可能深入思考发展路径\n  TIPS   选择早期标杆客户\n 钱少事多的客户\n   抵制项目制诱惑\n 不要把产品做成外包\n   耐得住寂寞\n 成功不怕晚\n   Leverage 开源\n 开源是趋势\n开源是商业版的敲门砖\n   利用口碑效应\n 口口相传的渠道\n   从科技公司到商业科技公司\n ","description":"","tags":["30天学习打卡"],"title":"创业要耐得住寂寞","uri":"/posts/3%E6%9C%885%E6%97%A5/"},{"categories":["管理"],"content":" 英雄和普通人的区别就是，当大部分人感到恐惧的时候，英雄感到的是愤怒。\n 著名产品人 梁宁如是说。\n《做技术管理必须有这些产品思维》的学习笔记。\n 一个完整的产品，分为理性部分需求和非理性部分需求，做技术的人员，大部分只能看到理性需求，看不到非理性需求，所以技术管理要具备产品思维，需要理解非理性的需求，才能更好地促进产品的开发。\n 两组相对概念 理性和人性   合理的部分是理性\n 觉得很多事情应该这样，但是得到的结果却不是这样\n作为一个IT从业者，对理性非常崇尚和追求，对不合理的事情难以忍受\n   不合理的部分是人性\n  当有一定的压力时，人们才会按照理性做事，压力不够时，会按照自己的人性做事\n  10%生理体验，90%心理体验\n 理性的人认为，做好生理体验，就应该是做好了，从而忽略心理体验\n   满足   不满足\n   所有负面情绪的本质\n   被满足\n 所有正面情绪的本质\n   存在感   世界观 + 感受自己的存在\n 讲话是，看着别人的眼睛\n自卑是因为优越感缺失\n生存挑战优越，会有优越感\n好的产品，要让用户感觉到优越感\n   愤怒、恐惧   边界被侵犯\n 如果侵入者是一只猫，会愤怒\n如果侵入者是一只老虎，会恐惧\n愤怒还是恐惧的区别在于，你对对手的感知\n英雄人物和普通人的区别是什么：当大部分人感到恐惧的时候，英雄感到的是愤怒\n   提取真正的需求   状态和需求不同\n 饥饿的状态，并不能说明是个需求，因为所处场景不同\n   不满足的状态 + 处境 + 场景 = 痛点/痒点/爽点 需求切入点\n 饥饿 + 有额外的金钱 + 不需要节食 = 购买食物的需求\n   不满足状态：饥饿、孤独、。。。心理体验\n  心理的不满足是不会有尽头的\n  爽点：长期不满足的状态突然被满足了\n  To B\n 痛点 = 老板的恐惧\n只有让老板感觉到恐惧，才能促使老板强制推行一个产品\n   管理员视角和用户视角  天猫、淘宝、京东 - 管理员视角的弊端：没有明确需求的人，打开你的产品后，找不到一个可以点击的点 拼多多 - 用户视角：没有明确需求，但是打开你的产品后，会有好几个可以点的  人和人不同  我们要能够真正地完整地看到别人，与人产生连接 ","description":"","tags":["30天学习打卡"],"title":"好的产品，要让用户感觉到优越感","uri":"/posts/management/3%E6%9C%884%E6%97%A5/"},{"categories":["管理"],"content":" 用程序员思维，做大众化产品的市场营销。\n 馒头商学院创始人 王欣如是说。\n《技术管理者为什么一定要懂运营3.0》的学习笔记。\n 什么是运营3.0？\n服务商和用户之间的身份杂糅转换。\n内容比较少，提取出来的主要观点是：数据分析等技术能够促进运营的效率，所以，技术管理者要懂运营概念，从而更准确的使用技术来提高运营的效率。\n 程序员的三个转型  一直写代码 管理岗 横向发展  消费者行为发生了变化   信息获取的变化\n 媒介公信力下降 朋友推荐、口碑传播 影响力越来越大 新媒体提供了技术实现的可能性 信息传播速度暴增，影响范围空前扩大 对立思考能力在提高，消费行为更加离散 用户和厂商之间的距离扁平化 渠道如果没有附加值最终会消亡 Search和Share    人文在更新\n  媒介在延伸\n  APP、公众号、聚合网站\n 三个项目，最后只有公众号存活了下来\n     1.0 - 孤立的消费者\n  2.0 - 连接的消费者\n  3.0 - 社会化用户，大家互为厂商，互为用户\n  产品就是营销，用户就是渠道  技术人员和运营人员之间的区别会变得越来越模糊 这是理科生逆袭的一次重大机遇 技术影响营销成果  增长黑客  用程序员思维，做大众化产品的市场营销\n  如何获取用户 如何创造“啊哈”时刻 如何让用户再回来 如何让用户买单 如何让用户带来更多用户  如何实现  数据分析 原因假设 验证 大规模行动 ","description":"","tags":["30天学习打卡"],"title":"程序员思维在运营中的价值体现","uri":"/posts/management/3%E6%9C%883%E6%97%A5/"},{"categories":["管理"],"content":" 我们所有员工都有一个统一的Sense：“做全球最懂物流的技术团队”。\n 运满满CTO 王东如是说。\n《如何打造活力、持续创新的研发团队》的学习笔记。\n运满满  车货匹配 运满满和货车帮合并 估值60亿+  期待的技术团队   活力创新\n 碰撞产品迭代，讨论新技术，每个人都在贡献idea，尝试优化产品和系统\n   如何打造活力、持续创新的研发团队   业务支撑\n  重点业务0排期\n  项目节奏管理：早进入、并行、反向推动、Deadline、公告\n  项目机动组织\n  高T人员，快速支援缺人的业务\n  没有数据反馈，只知道做，成就感不足\n 了解用户，体验产品，关注线上数据，懂你的行业，思考业务的运营，心中有一张大图\n       技术驱动\n  架构升级\n 双样式APP、组件和服务分别维护    工程效率\n  动态化\n  配置化\n 把Native的东西，做成动态下发\nRN，H5\n   工具化\n  自动化\n 工单自动化，打包自动化      稳定性\n 通过系统来保证系统 测试体系/灰度体系 容灾/降级/回滚 监控告警，IM/邮件报警    用户体验\n  性能/交互\n 帧率、Crash、数据    可用性\n  新IO\n  语音，自然语言理解，人脸识别，\n 语音发货，风控，OBD盒子采集车辆数据，怎么开节油，车子性能\n     安全特性\n    运营效率\n 3000+运营\n   系统化\n  智能化\n 通过数据分析热点区域\n在某些地方用什么打法，更容易拉到新用户\n       文化塑造\n  工程师文化\n  担当\n 每个人都要Owner一个事情或系统\n责任感，负责\n   执行力、速度感\n 快速迭代，竞争格局此起彼伏，唯快不破\n   有挑战、做精彩\n OKR定挑战目标，做精彩的事情\n   大声说话、开放批示\n 乐于表达，吸收不同的声音\n会上充分讨论，会下坚决执行\n   文化如何落地\n  把遵从企业文化，变为认可企业文化\n  管理层共创\n 我们认同什么样的人？\n什么是好开发？\n什么是好测试？\n什么是好运维？\n什么是好领导？\n   落地员工\n  律人律己，管理者是关键\n 选拔标准\n群Rreview\n   树榜样，荣誉体系\n  员工OneOne，项目管理\n 鼓励则会生长\n   Hire，Fire\n 淘汰要坚决\n   首先保证Leader层面的味道\n        团队建设\n 面向未来挖掘人才    经验心得   打胜仗是最好的团建\n  小情大爱：提出长出能力的要求，保持小跑的节奏，小喘的状态\n  对得起好的人，跟不好的人说对不起\n 不认同我们的人，不要犹豫\n   影响而不是被影响，感染而不是被感染\n  简单不粗暴\n ","description":"","tags":["30天学习打卡"],"title":"对得起好的人，跟不好的人说对不起","uri":"/posts/management/3%E6%9C%882%E6%97%A5/"},{"categories":["管理"],"content":" 开口说，动手做，放手管。\n 科大讯飞研究主管 李鑫如是说。\n《工程师个人成长中的若干心理学问题》的学习笔记。\n心理学讲什么？   心理咨询\n 搞心理咨询的都是半路出家\n   脑科学\n 用高精尖技术，测量人体和外接的反映指标，来分析人类怎么思考，更偏向与理科\n   组织学\n 研究人与人之间是怎么协作的。\n   工程师成长的三个时期   职场新人 - 入门期\n 技术你不懂...\n我们领导说...\n   职场老人 - 平台期\n 这些东西都是我玩剩下的... 嗤之以鼻，高姿态\n画饼对我没有用... 对画饼有免疫力\n   带团队 - 展业期\n 我们部门... 本位姿态看问题\n你这也不会？... 心态：做了技术管理，是不是技术要丢掉？\n   心理学与成长状态的对应   从众心态\n 人在社会压力下会说出明显错误的答案！ 避免从众：离线收集意见，会上开始讨论\n   人云亦云\n 人会顺从地服从权利者行动，且很少人会意识到这点！ 避免服从：当被问到，这周我要做什么 时，反问，你觉得你自己应该做什么？\n   自我中心\n 人（特别是前运算阶段的儿童）具有自我中心主义 降低自我中心：儿童 - 互相玩对方的玩具；工程师 - 轮岗，熟悉别的部门都在干什么\n   舒适区\n   走出舒适区：引入新技术时，讲清楚和现有技能的关联，和工程师个人发展的关系，给予熟悉感。\n   全局意识\n 培训基层技术管理者，使其拥有全局经营思维；\n   损失厌恶\n 面对得到时，我们考虑盈利 面对损失时，我们考虑冒险 要让工程师们快速行动起来，与其画饼（承诺事后奖励），不如来点实惠（先给予后评价）。\n   判断错误\n 理性化 -\u003e 情绪化 资源有限 -\u003e 杀鸡用牛刀 贪得无厌 -\u003e 可满足即可\n   鼓励机制\n   你期望什么，你就会得到什么\n  软化冲突、淡化权威、强化边界 ","description":"","tags":["Android","30天学习打卡"],"title":"工程师的个人成长离不开心理学","uri":"/posts/3%E6%9C%881%E6%97%A5/"},{"categories":["管理"],"content":" 领导决定组织的成败。\n 网易前端开发专家 吴子房如是说。\n《打造通用型高效前端团队》的学习笔记。\n通用型高效前端团队   业务背景\n 网易严选，自主品牌，参与产品制造，担库存 技术平台：App、H5、小程序、PC    团队职责\n  4年+，20+人\n  技术平台/技术中台\n  DevOps平台\n 开发，打包，测试一体化方案\n     权限中心/流程平台\n  业务研发中通用的一些痛点\n 用户，用户组，权限管理等等\n     系统架构演进\n  BFF框架优化\n  Serverless实践\n 对前端非常实用\n   前端应用架构演进\n  组件库\n 基于统一设计规范的组件库，可实践\n   效率工具\n 基于远程办公条件下的效率工具\n   产品思维\n  人员不增的前提下，支撑产品数量成倍增长\n 我们可以吗？我们组能够hold住现有业务 * 2的任务量吗？\n         打造通用型高效前端团队   团队起步\n  打造核心能力，核心成员\n 5人，技术上的骨干力量\n12人，技术平台建设，全平台，快速开发框架\n18人，技术平台产品化，前后端全做，部分项目全栈开发\n20人+，接手更多业务组的团队，技术中台建设，实践Serverless\n   管理者\n 全局意识，洞察业务与技术的发展方向，规划团队的未来发展路线 研发链路优化，参与到研发上下游 掌握更全面的开发技能 培养产品思维能力 投入新技术研究/调研      架构调整\n 30%做基建 人员能力提升 团队获得更多资源    制度建设\n  项目制度\n 目标明确 选好项目人员 把控好项目进度    自定项目流程\n 评审 -\u003e 负责人 -\u003e 方案评审，授权 -\u003e 招募成员（开放） -\u003e 里程碑（合理的里程碑可以更好地控制项目进度） -\u003e 落地（实现项目价值）\n20+项目进行中\n   周会\n  信息同步，分享，培训\n  时间观念\n 时间观念非常重要，开会提前到的和到点后等别人叫的，差别真的很大很大。\n   提升团队凝聚力\n  主持人，分享者得到锻炼\n      人员培养 - 技术团队的核心就是人才\n  业务线之间人员流动\n 提升全局观，业务理解更全面、深入，有激情，更多话语权\n   业务组件库\n 跨业务线的组件库，依据设计规范\n   关注个人的核心诉求\n 了解团队中每个人的情况，喜好，能力\n   业务特点\n  一专多能的人才\n    管理者的思考   领导力\n  个人和团队的办事效力与领导力成正比\n  衡量标准：影响力\n   强制管理\n打成一片\n满足诉求\n辅导功课\n成为榜样\n   成就他人\n 领导精力有限，要给其他人机会，让其他人负责一些事情\n   建立信任\n 先做好建立信任，领导信任你，下属信任你。\n领导信任你，愿意分配事情给你做\n下属信任你，不会甩锅。\n   授权他人\n 不要天天追进度，只在里程碑评审时，关注项目进度。\n   提升自己\n 技术，视野，沟通\n   先“舍”后“得”\n 先成全别人，后成全自己\n   推荐书：\n《领导力21法则》\n","description":"","tags":["30天学习打卡"],"title":"团队领导的必修课","uri":"/posts/team_construction/2%E6%9C%8829%E6%97%A5/"},{"categories":["管理"],"content":" “不求有功，但求无过。”是陋习。\n 阿里巴巴高级技术专家 *孔凡勇（云狄）*如是说。\n《细说Tech Leader在开发团队的核心职责》的学习笔记。\n 分享者分别从技术和团队两个角度讲述了自己作为技术领导的总结和感悟，涉及面比较广；在当前疫情期间，我们可以找出具体可实施的点来实践。\n 技术   协作流程\n 项目启动 需求阶段 设计阶段 研发阶段 项目交付    开发规范 - java开发手册\n 降低故障率 提升协作效率 工匠精神 配置规范  统一代码formatter 统一git ignore   命名规范  lowerCameCase：方法名，参数名，成员变量，局部变量 UpperCameCase：类，接口包，常量命名 领域模型（DO/DTO/BO/VO） 其它   API规范  RPC REST API GateWay   异常处理规范  直接返回 抛出异常 重试处理 熔断处理 降级处理   分支开发规范  分支的定义 分支命名规范 checkout、merge request流程 提测流程 上线流程 hotfix流程   代码commit规范  Angular的提交规范 Type：feat/fix/docs/style/refactor/perf/test Commitizen / IDEA插件 生成cimmit log摘要   日志规范  日志框架 日志保存时间 日志级别-debug/info/warn/error 日志描述 - 上下文，traceId 日志信息安全 - 脱敏 禁用System.out/error   Mysql规范  建表规约  字段，索引，表命名规范   索引规约  普通索引，唯一索引，组合索引 索引区分度   SQL规约  外键与级联 count（列名）、count（1）、count（*）     统一工具与框架  常用工具封装（httpclient/orm/异常处理） 分布式基础组件（缓存，限流，分布式锁，幂等） 业务监控      流程规范\n  需求管理\n 需求类型  重要程度 紧急程度   需求优先级    架构评审\n 架构设计目标 架构设计原则 架构评审要素  目标  功能需求 非功能需求   原则  合适原则 简单原则 演化原则  需求演化 技术架构演化          代码评审\n 开发规约插件扫描 Sonar扫描    发布计划评审\n 发布时，要统筹好所有依赖资料\n     技术规划\n  短期规划\n 巡检，周报   像航空飞机一样，定期巡检所有依赖的组件\n   长期规划\n 架构演进规划，根据技术需求，优化项目架构\n     管理   团队建设与管理\n  集权式管理\n 事必躬亲，事无巨细都要参与\n   放权式管理\n 对所有业务和人员都很熟悉后，开始放权式管理\n思路转变，口令转变，授权不授责\n激励，指导，赋予，淘汰\n     团队文化\n  坦诚，公开，透明\n 自我暴露，才能更快的融合到团队\n   平等相处，消除等级感\n 不要让大家对你言听计从，各自发挥自己的特点，要各自有独立的思考能力。\n   敢于担当\n 不求有功，但求无过。 不可取\n明确各个人的职责范围\n   成就他人，乐于分享\n 每周一次分享会，大家会乐于研究新技术\n   沟通与辅导\n  一对一沟通\n 相对私密的环境，聊一些不同角度的各种问题，让大家去思考，定期举行沟通，慢慢的就会发现很多各自的需要优化的点。 1-2个月沟通一次。\n     招聘\n 价值观，味道 技术     ","description":"","tags":["30天学习打卡"],"title":"怎样做好 Tech Leader","uri":"/posts/team_construction/2%E6%9C%8828%E6%97%A5/"},{"categories":["管理"],"content":" 我为我们团队的高效而感到自豪。\n 触宝研发总监 孟雷如是说。\n《如何通过结对编程进行高质量的软件开发》的学习笔记。\n 了解结对编程的概念，是否符合我们的团队，具体改如何实施。\n 软件研发模式的演化  瀑布模型 快速原型模型 螺旋模型 敏捷开发 ？？？  开发和测试的困境  困难  在敏捷的短周期里面实现的其实是瀑布模式 在强调交付速度的过程中，开发飞擦画那个容易急功近利，为完成手头的工作而在架构方面做很多的妥协和折中，从而为日后的维护升级买下很多隐患。 水平参差不齐，很多地方写的很山寨，后面很多问题都是给前面的疏忽买单，产品一直处于不定加不定的状态 有质量的code review没空做 代码量大了，没空仔细review 研发过程当中的团队分工角色较多，因此从上游到下游的过程中，会有很多沟通方面的损耗，团队管理消耗更多。   正确的方法  从源头提高代码质量 注重代码的框架和设计，杜绝补丁加补丁 建立标准化的设计模型和代码风格 培养功能 + 测试 + 监控   关于结对编程  两人共用一台电脑 一起设计，写代码，测试 没有专门的测试环节，完成即上线    结对编程与传统软件开发流程的主要区别  利于只是的传递 避免没有明确文档的潜规则的坑 强迫接触不熟悉的领域，有利于培养全栈 代码风格，设计思想，强一致，不存在项目移交的风险 没有单点瓶颈，不怕人员流失  结对编程最佳实施方法  两个人必须使用同一台电脑，不能两台点啊弄，坐在一起 不准带手机，写程序的人有义务监督观察者使其注意力集中 每半天或者一天轮换一次（驾驶员、领航员） 固定时间，中间休息 搭档定期更换，但必须有梯度 必须开发测试都做  使用场景，成功案例  周日程  周一 发布上一个正式版本 周二 开发测试 周三 开发测试 周四 代码冻结，公测 周五 观察，新需求   天日程  10:00 - 10:30 站会讨论 10:30 - 12:00 结对编程 1:30 - 3:00 结对编程 3:30 - 6:00 结对编程   必须遇到的问题  执行力！执行力！执行力！ 组员：想做自己的事情，我是不是在浪费时间？ Leader的顾虑：影响项目进度 两人会有性格等各方面的问题，会有争议，争吵；Leader介入参与讨论 没有测试不放心   必然要抓住的重点  确保团队成员对于业务目标以及研发流程的理解和认同 帮助团队成员摆脱固有的研发角色的分工 重点关注架构设计，模块重用 增强开发人员的自我测试意识   必须付出的代价  组员：很少有私人控件 leader：需要尽可能的带大家做靠谱的事   适用场景  偏极客分为的公司或团队 公司规模较小，但业务形态相对来说比较稳定 业务需求较多，迭代较快 有一定逻辑复杂性，需要较好的基础架构的项目 人员流动较大，缺乏系统化文档   相关数据  线上Crash率下降 完成任务数 / 人 先降后升   关于测试  美欧专门的功能测试不代表没有测试 跟单纯的功能测试说再见！ 以自动化持续继承测试作为研发的基础 注重多平台，性能测试，压力测试，耗电量测试等高级测试，以及测试工具和框架的研发 注重线上实时监控，研发，测试，监控一体化   ","description":"","tags":["30天学习打卡"],"title":"提高开发效率的秘密武器：结对编程","uri":"/posts/2%E6%9C%8827%E6%97%A5/"},{"categories":["Flutter"],"content":" 在未来Fuchsia会成为一个非常重要的操作系统。\n 重德智能工程师 许中兴如是说。\n《世界需要新的操作系统-Fuchsia设计解读》的学习笔记。\n 了解Fuchsia操作系统的基本情况、设计原理和优点，了解市场上各个操作系统的境况。\n Fuchsia的基本情况  全新的操作系统 Google开发 微内核，基于能力的访问控制，Vulkan图形接口，3D桌面渲染Scenic，Flutter应用开发框架，目前支持的编程语言：C/C++，Go，Rust，Dart 2016年，Google放出所有代码，但是没有正式宣布项目目标，一个IRC频道交流 支持的架构X86-64和ARM 64，支持的设备从IoT到服务器  Google为什么要从头设计权限的操作系统  737问题：当系统总体设计出现问题的时候，用再多的技巧去弥补，也只会造成最终的灾难  现代通用、开放OS需要面对的方面  上游硬件厂商 下游应用开发者 设备友商 用户 黑客  Fuchsia解决现代OS痛点  原生进程沙箱，解决应用安全和分发问题  Linux：Namespace，Control group，Unionfs =\u003e Docker   稳定的驱动接口，硬件厂商可独立维护硬件驱动 系统模块化，分层，设备厂商可以灵活定制专有系统 基于Vulkan和物理渲染的纯3D UI，全局光照 Flutter应用开发框架  Fuchsia重新思考四个Unix的基础抽象机制  全局文件系统  Unix，存在一个全局的跟文件系统  他是每个进程共享的基础资源 文件系统涵盖了非文件资源：/proc, /sys, ...   Fuchsia里，没有全局根文件系统  文件和文件系统成为一个局部概念，从而在进程内核数据结构里没有file 用Namespace来定义一个进程能够访问的资源，每个name对应一个资源进程channel的handle     用户  Unix中，User本来是用作不同的用户登录，共享服务器的机制  User是真正的用户 后来主要用作权限控制，弱化的沙箱机制   Fuchsia中，在底层（Zircon，Garnet）没有用户的概念  用namespace来控制进程能够访问的资源 Capability-based access control 从而在进程里没有uid     进程的创建  Unix中，新的进程由老的进程fork而来  新的进程继承父进程的全部资源 偷懒的设计 Andrew Baumann, a fork() in the road, ACM Hot Topics in OS, May 2019   Fuchsia中，新进程需要从头开始创建  创建process，Thread 父进程建立初始的namespace到资源channel handle的映射 调用process_start显式的告诉内核新的进程可以跑了 在Fuchsia内核的process数据结构中，没有file和uid     系统调用  Unix中，通过中断调用内核服务：int 0x80，syscall,sysenter 系统调用的方式是确定的，直接的  内核接口不能变 可以被任意注入的代码调用   Zircon里系统调用通过vDSO进行，意图是防止用户代码直接通过固定的中断代码调用system call，达到内核详细接口的隔离，保持C层面的接口稳定：名字 + 参数。而不是内核入口汇编指令层面的稳定  注入的代码无法直接调用vDSO里的接口，虽然加载地址固定，但是计算出入口地址很难，如果不是不可能的话 内核会验证调用指定的地址，而vDSO的加载地址是固定的，并且在编译的时候会验证有限的入口符号，这些符号在编译时位移生成，防止用户进程绕过vDSO 这里主要的目地是隔离system call的调用方式，不是绝对已以上的不可注入调用      仿佛是专门针对漏洞利用作出的设计  典型的漏洞利用步骤  通过系统调用fork()/exec()直接创建反向shell 继承uid获得泛在授权 访问全局文件系统   在Fuchsia里，以上机制都不存在  没有固定的系统调用入口 船舰进程时显式建立root namespace 没有user，从而没有ambient authority (DAC/MAC) Capability-based access control 能访问的资源是父进程赋予的namespace，看不到初始namespace之外的任何资源    Kernel的本质是什么？  不是  管理硬件 执行特权指令 引导启动过程 处理中断   作者的理解：地址空间切换  不同进程唯一共享内存地址空间的场合 切换地址空间是进入内核的标志 不同的进程通过共享内核地址空间来交换信息 切换地址空间是切换进程的关键步骤   Zircon主要内核态共跟你个  虚拟内存和物理内存管理 进程和线程管理 进程间通信   以内存为中心的设计  VMO代表一个内存对象，懒分配 VMO通过向channel发送handle在进程之间传递，进程拿到VOM handle，把VMP重新映射到自己的地址空间里 Unix是以文件为中心的设计   Channel  是进程间通信的唯一机制 一个channel有两个handle，h1，h2，从一头写入ixaoxi，从另一头读出消息 进程进程，有一些初始channel handle 要与一个服务建立通信，h1自己拿着，h2发送给响应的服务做监听 channel_write() 必须是一个系统调用   系统调用vDSO 微内核  性能问题  上下文切换 线程切换      Fuchsia在各个平台上的可能的优势  服务器平台，原生进程沙箱机制将带来新的安全特性和容器机制 桌面平台，无缝兼容Android 移动平台，系统的模块化方便第三方设备厂商的全面定制  Fuchsia分层  四层，后两层可以替换掉，不影响兼容性  用户体验层 应用层 内核层 系统服务层    Fuchsia 目前的运行环境  在Qemu中可以直接运行  Booloader加载到0x40080000 内核加载到0x40090000 Ramdisk加载到0x48000000 0x40000000 - 0x40080000之间是FDT flattened device tree    系统软件研发能力的获得  系统软件与应用软件不同  大量缄默知识 工具链：gcc，Id，as，clang，ELF 微处理器 周边设备UEFI，ACPI，APIC，PCIE，USB，STATA，AHCI，GPU... 知识存在与代码中，硬件标准文档内容太多 产品级的设计非常困难    总结  Fuchsia重新思考了操作系统设计的各个方面，是一次男的的从头开始的机会 在未来Fuchsia会成为一个非常重要的操作系统 世界需要新的操作系统  每一个大型软件系统都值得尊重 Windows老迈龙钟，历史负担太重，微软自己的创新Midori胎死腹中，因为无法承受在新的框架中重新实现一遍Windows的全部功能，只能在原地进行重构 Linux里大部分开发人员只关心服务器的世界，就像一个专注与在加班下面锅炉房里干活的锅炉工 MacOS，iOS封闭在苹果的硬件生态里 Android微了弥补Linux的缺点打上了一个厚厚的中间层，不断在做着妥协 GNU Hurd作为GNU项目“最后的组件”一直未能产品化，原因是“微内核消息传递机制debug态困难”？ Unix的后继者 Plan 9 与2002年发布了最后一个版本，他的余热随着作者融入了Go   ","description":"","tags":["30天学习打卡"],"title":"Fuchsia - 来自 Google 的全新开源操作系统","uri":"/posts/2%E6%9C%8826%E6%97%A5/"},{"categories":["Web"],"content":" 在生态链上，完成自己的角色。\n 上海木鸡网络科技有限公司联合创始人 杨轶如是说。\n《移动Web上玩转原生游戏》的学习笔记。\n 了解当前移动端Web游戏开发的历程、技术瓶颈和作者产品的功能。\n 当今移动端浏览器为游戏开发准备了啥  HTML5，CSS3，JS，WelGL Web API：Web Audio API, XHR/Fetch, WebSocket, WebRTC, Web Workder, Touch/Accelerometer 存储，IndexedDB PWA，Service Worker JS引擎：V8，SquirrelFish Extrem，JaegerMonkey  Web上游戏开发之现状  纯Web游戏引擎  COCOS 2DX，Egret，LayaBox，Construct 2，three.js   原生游戏引擎Web版  Unity，移动端游戏王者，50%占有率，可用资源多 Unreal，大，占有率不高 Emscripten   Web游戏渠道平台  小游戏框架，国内环境 标准HTML5，WebView渠道，海外渠道    移动Web上能玩原生游戏吗  移动Web环境，Unity  WASM模块：函数多，加载慢，编译慢，内存占用高 Web天生不支持阻塞调用，加载大资源是问题 使用MultiThreading，BSD Socket的游戏   WEB-IR，Unity引擎游戏通过WEB-IR处理，达到可以在移动Web环境可以运行，轻游戏2.0时代  代码动态Profiling，Code Size减直1/3，加载启动提速2X 编译器支持的阻塞机制，虚拟上下文切换，支持资源渐进式加载，支持TCP/UDP select/poll 虚拟协程来模拟多线程   软件栈  OS Layer WebView Client, Browser Client Game Engine Core / WebAPI 和设备打交道，平台SDK Game Logic Native Part / Game Logic Web Part 游戏逻辑   内存使用是Web游戏的第一阻碍  案例分析  贪吃蛇游戏  代码动态Profilling，Code Size缩小到1/3，编译加载时间缩短 支持阻塞调用，资源文件可以同步读取，仅需要8M内存来做Cache，按需下载的数据很小，加载耗时明显见效 对原始WASM代码进行重编译，插入控制指令，并奇怪Patch Unity的IL2CPP库以支持虚拟的多线程调用和UDP连接，解决了原生游戏所依赖的网络连接问题   MMO 3D游戏  3D游戏，需要更大的计算量和更多的资源，同事也真实了Unity 3D游戏的表现力 由于原生游戏依赖了很多第三方库，UNity WebGL版执行代码有超过60K个函数 Demo版的资源有300M，意味着完整游戏会在GB级别，占用内存也就在GB级，在手机浏览器环境是完全不可界首的 MMO游戏，要用到BSD Socket和MUlti-Threading，不做调整的Unity WebGL版依旧无法运行 通过我们处理，有效函数控制在20K个，为了满足iOS对编译WASM的限制采取了WASM和JS混搭的Hybrid模式，同事配以IndexedDB来满足资源持续储存并作为Cache加速再次加载的速度   3D 动作游戏  中量级，3D单击游戏，内容丰富，移植速度快   解密类游戏  适合Web化，操作要求不高   实践中的关键  WASM程序所要编译的函数 游戏首帧启动时间 游戏运行时内存占用    WEB-IR，这种方案所要解决的关键问题  WEB-IR解决问题的关键-重构Unity WebGL  动态Profilling 资源渐进加载  大块文件切割成若干个Chunks Chunks预加载 Chunks多种方式存储 解析出来的资源数据会被保存到内存Cache中提高访问速度 Chunk渐进加载以阻塞I/O为前提 云端跟踪前端资源的加载情况，为后面的加载做准备 渐进加载无需开发者修改代码   阻塞I/O  阻塞IO是保存文章的调用栈，以做恢复使用   虚拟线程  协程方式代替线程      WEB-IR工具链  WEB-IR以一种中间语言的代码格式支持整个技术框架，工具链所BUild产出的任何代码都是基于WEB-IR中间语言之上 WEB-IR中间语言是和WebAssembly在相同级别的低级语言，基于的是CFG而不是AST WEB-IR中间语言以纯文本的形式保存，方便修改调试 WEB-IR中间语言可以通过源代码（C/C++）和WebAssembly 二进制码生成  我们的感悟  用好前人的肩膀，尽量不要重复造轮子，在生态链上，完成自己的角色 拓展思维，尝试做一些不一样的事情 很少有火箭科技，更没有黑魔法，在实践中不断地改良 时刻不要忘记真实环境的适配能力 ","description":"","tags":["30天学习打卡"],"title":"在浏览器上打王者荣耀？","uri":"/posts/2%E6%9C%8825%E6%97%A5/"},{"categories":["AR"],"content":" AR是一个瓶子，这个瓶子可以装天下。\n 沪江网架构师 李超如是说。\n《AR在直播系统中的应用》的学习笔记。\n 了解VR/AR/MR的概念和特点，了解当前AR技术的发展阶段。\n VR/AR/MR介绍  VR：虚拟现实，可以完全沉浸到该环境中 AR：增强现实，将虚拟世界与现实世界结合到一起，并能进行互动 MR：混合现实技术，虚拟环境中引入真实场景  AR技术与现状  2017年6月5日，苹果发布ARKit Tango，Google眼镜 AR应用场景  游戏 电商 教育 直播    AR核心概念  特征点：计算机视觉中的一种关键技术，通常用在人脸识别中。  特种点是指图像灰度值发生剧烈变化的点或者在图像边缘上曲率较大的点。像边缘特征点，角点等都是常见的特征点。   运动追踪：ARKit使用视觉惯性测距技术获取手机的姿态  通过采集对的图像序列进行计算机视觉分析，找出其特征点在连续的图像帧之间的位置变化，再通过设备的运动传感器，最终得到设备的位置和方向。   场景理解：平面检测，识别地面，桌子等平面。  识别的方法，区域中Y值为0的区域   光线评估：估算当前环境的光线强度，使虚拟物更真实。  ARKit运行机制  ARKit三个核心类  ARCamera：不停的获取手机拍到的图像 ARSession：三大概念处理 ARSCNView：展示   ARKit虚拟物品  SCNScene：画布 SCNNode：虚拟物品 SCNMaterial：纹理，材质   ARKit运行机制  ARConfiguration ARFrame：AR帧 ARAnchor：锚点，控制虚拟物品的位置    ARKit Demo任意门  Demo演示  ARCore运行机制  ARCore核心Session类  运动跟踪、场景理解、光照评估   ARCore运行机制  Session OpenGL ES GLSurfaceView   View组件  Surface、SurfaceTexture、SurfaceView、GLSurfaceView、TextureView等组件   OpenGL ES  矩阵变化 什么是EGL OpenGL ES API：控制GPU    ARCore与ARKit区别  核心算法相同 ARKit API相对完整，ARCore只关注核心算法 ARKit可以商用，ARCore只能在有限的机型上测试。  AR在直播系统中的应用  视频通话与AR  音视频通话的基本原理：采集，编码，传输，解码，渲染。AR在视频通话中的实现与本地的AR应用有着本质的区别。 难点：  AR与非AR客户端如何交互，ARKit和ARCore如何互通？ AR端无法直接从ARCamera获取视频 帧率过高导致传书码流过大   设置参数及启动Session 获得锚点及设置虚拟物品   展望  裸3D离我们还很遥远，但通过手机我们可以实现部分黑科技，可以将AR认为是一个瓶子，这个瓶子可以装天下 目前AR才刚刚起步，未来可期   ","description":"","tags":["30天学习打卡"],"title":"AR发展，未来可期","uri":"/posts/2%E6%9C%8824%E6%97%A5/"},{"categories":["深度学习"],"content":" 不确定性是对人的最大挑战和锻炼。\n 阿里巴巴高级无线技术专家 *吕承飞（吕行）*如是说。\n《淘宝端智能探索和实践》的学习笔记。\n 由于个人对深度学习了解有限，只记录了一些比较书面的内容，作为个人拓宽视野的资料。\n 端智能背景介绍   端智能应用示例\n 人脸贴纸 人脸交互动作 图像物体识别 试装    端上AI优势，不做模型训练\n 实时性 个性化 数据隐私 离线服务    应用场景\n AI手机  AI摄影、AI图片编辑 AI提升性能   App  OCR 短视频/直播、特效 安全风控 互动活动 试装 个性化推荐      业界趋势\n  AI芯片\n 麒麟970 A11 骁龙845    AI框架\n FB Caffe2 Google TF-Lite 苹果CoreML Android NNAPI 腾讯NCNN 百度MDL/Anakin 小米MACE 华为HiAI   端智能已成为趋势，各大公司积极布局AI芯片和AI框架；\n端智能已在手机和App中发回巨大价值，未来可期；\n手机摄像，短视频特效，端计算，IOT智能硬件是终点应用方向。\n     系统模块   面临的问题\n 适合移动端的算法模型 如何解决模型文件过大问题 如何解决端侧模型推理问题，需要一个深度推理框架 如何解决深度模型部署更新问题 如何解决部署后的模型安全问题 如何解决端上计算力有限情况下的性能问题    端智能工作流程\n 模型训练 模型压缩 模型发布 推理预测    模型压缩平台\n  基础方案\n  支持TF/TF-Lite量化模型/直接量化工具\n  门槛低，对算法透明\n  压缩率低，精度有一定下降\n    高级方案\n 低精度计算（8bits/3bits）/剪枝/稀疏 压缩率搞，基本无精度损失 对算法不透明，修改框架，重新训练      模型管理下发度量平台\n  模型管理\n 模型转换 模型列表 模型详情 模型发布cdn    发布管理\n 版本管理 版本详情 发布  单机 灰度 AB 回滚 发布      数据管理\n 发布度量  成功率 异常   模型度量  推理耗时 内存消耗 成功率 使用统计      端侧的推理框架\n  核心指标\n 通用性，跨系统 轻量性 高性能 安全性 易用性    挑战\n 设备资源局限性 性能挑战 模型文件 适配挑战    方案选择\n  开源方案\n TF-Lite   不同模型格式\n模型转换困难\n支持PO和Layer不同\n  Caffe2   性能优化不够充分\n功能支持不充分（OP有限）\n   系统方案\n Android-NN API   Android 8.1\n  iOS CoreML   iOS 11\n   自研方案 AliNN\n 统计部署 异构设备优化 模型安全      ALiNN完整体系\n 模型转换工具 模型编译器    ALiNN性能优化思路\n 转换工具 模型优化 内存优化 计算加速 NCHW内存布局问题 ALiNN NCoHWCi(4)内存布局        如何在业务场景应用端智能\n 业务触发 理解端智能    个人感想  移动互联网下半场出路？  效率  大规模团队协同开发方案 自动化UI还原 代码腐化问题   体验   突破自己  脱离舒适区   怎么过去  因为相信，所以看见，关键怎么过去   不确定性  不确定性是对人的最大挑战和锻炼   ","description":"","tags":["30天学习打卡"],"title":"端智能是什么？","uri":"/posts/2%E6%9C%8823%E6%97%A5/"},{"categories":["平台研发"],"content":" 重复造轮子是不好，但是适合自己的轮子才是最好的。\n 携程开发总监 刘李丰如是说。\n《携程无线技术平台化研发实践》的学习笔记。\n持续交付平台 - MCD  MCD之前  专人打包 最多2-3个包 per day 开发测试流程完成通过人工协调 发版时迟迟不能定版 最和新问题：没有版本信息，包名相同，自动化测试不清楚验证包信息   MCD 1.0  解放生产力，随时打包 自动化流程，打包流程由环境演变成pipeline CI/CD  定时打包 代码扫描 自动化验证包 - 白屏检测     持续继承 + 冒烟测试  代码扫描 infer \u0026 sonar 冒烟测试  多机型兼容测试 页面内容长度 + 图像比对     超级App改造  同一个代码库 基于源码打包，编译错误阻塞打包 打包时间仍然过长，8分钟   超级App改造 - MCD 2.0  重新定义MCD  集成 测试 发布 运营   基于Bundle打包  引入Bundle发布状态（L，RC）   进一步优化流程  从项目创建覆盖到定版   急速出包  2-3分钟     发布升级  发布对象  hotfix Bundle Hybrid/RN   升级之路  存储云化 灰度发布  白名单/百分比   差分  全量 文本 二进制 动态差分   实时查看  基于设备ID查看 整体趋势     配置中心  移动端配置中心化  支持平台，版本，渠道下发 支持分流，AB App启动全量拉取     崩溃收集  Bugly很专业，无法定制 基于代码打标签，MCD无缝对接 实时报警 多维度搜索 各种样式Dashboard   App Size管理  基于业务线模块进行统计  和历史版本比较 各自比较   刨除法计算   MCD Arch  Not Just Jenkins  MQ 解决 Jenkins Cluster   支撑数量  打包：10000+ 每年 发布：10000+ 每年        性能监控平台 - APM  APM背景  缺乏质量大盘 缺乏精细化运营数据 缺乏多维度查看数据 Hive拉取数据过漫   APM质量大盘  网络性能 网络成功率 崩溃率 启动时间 定位成功率   APM多维度分析  热门地区 运营商 网络   APM服务大盘  成功率 耗时 请求大小 报文大小 Error code占比   APM报警  设定阈值 与上周数据比较 有问题数据进行冒烟   精细化运营 - Server IP下发  背景  运营商 网络质量存在差异   方案  海外：国家 国内：城市   目标  下发高质量的IP列表   测试结果  成功率1个点提升     踩过的坑  噪音数据过滤 数据处理性能，延迟监控  埋点监控   数据处理的准确性  Hive数据比对   数据Trade off  无线请求可以花粉为App版本、平台、网络类型、国家、城市等 维度降低     设计细节  Metric 100+ 日处理数据量 100亿+ 写入数据量 100GB+ 处理流程：  app采集数据 -\u003e Storm数据清洗聚合 -\u003e DownSample数据归集 -\u003e ES数据存储 -\u003e Dashboard数据展示     Down sample设计  多级聚合 错误监听 状态监听    日志排障平台 - MTS  MTS背景 全链路打通  Native App TCP服务调用 Hybrid/H5 调用 Base Page请求 图片请求 用户轨迹流，崩溃路径 用户服务访问流程，各自的报文    无线技术平台 - MTP   无线平台建设背景\n 缺乏Meta信息维护 重复造轮子，质量不高 研发效率不高，App代码导出拷贝 缺乏通用解决方案    移动技术产品\n Platform Communication Framework Business    通用技术方案\n MTP 注册应用，组件，开发控制台 MCD 集成，测试，发布 APM 运营，监控 MTS 排障    MTP控制台\n  平台治理\n  开放\n 注册服务，注册回调    排障\n 查询数据及调用链    熔断\n 服务请求过载    报告\n 查看调用      未来方向  打造无线中台 大数据赋能 ","description":"","tags":["持续交付平台","30天学习打卡"],"title":"无线持续交付平台助力移动端开发","uri":"/posts/2%E6%9C%8822%E6%97%A5/"},{"categories":["平台研发"],"content":" 即使后台数据服务挂了，C端还是能拿到数据的。\n 美团点评高级架构师 蒋国宝 如是说。\n《打造稳定、灵活、高效的运营配置平台》的学习笔记。\n 为每一个应用场景开发一个页面，效率是非常差的，设计一套可灵活组合的动态化运营后台，才能更好地满足多变的业务需求。\n 运营平台是什么？   打断是扼杀搞效率工作的一大原因\n 让产品自己发布    高效\n 难点：多样展示、跨团队 方案  模块化拆分，达到可配置 不同模块进行组合，称为商户样式  商户样式什么决定？  版本 商户类型 城市       模块化配置运营  可复用的模块列表（模块池） 运营通过后台可以配置模块组合      灵活\n 为每一个应用场景开发一个页面？  缺点：需求易变，开发效率低，维护成本高   构建多个维度下的动态运营界面  优点：界面动态声场，无需开发，界面灵活可定制   方案：Json存储页面配置    稳定\n  配置内置到app内部一套，保证没有拉取到最新配置\n  配置完成流程\n 审核 + 测试预览 = 上线的可靠性    数据域划分 \u0026 审核上线\n  测试设备注册，保证上线前预览效果\n  第一个版本\n C端 -\u003e 业务接入层 -\u003e 配置后台数据服务 -\u003e Redis缓存/数据库    演进1\n C端 -\u003e 业务接入层 -\u003e 配置后台数据服务/本地缓存 -\u003e Redis缓存/数据库 优点：解决Redis抖动造成的问题 缺点：单击内存大小限制，中心化带来堵塞问题    演进2\n C端 -\u003e 业务接入层/数据缓存SDK，做部分数据缓存 -\u003e 配置后台数据服务 -\u003e -\u003e Redis缓存/数据库 优点：各业务缓存各自的数据，去中心化 缺点：数据一致性如何保证？数据时效性如何实现？SDK本地缓存如何监控？    演进3\n 将SDK植入C端，正在开发     ","description":"","tags":["运营配置平台","30天学习打卡"],"title":"越复杂的需求，就要做越简单的设计","uri":"/posts/2%E6%9C%8821%E6%97%A5/"},{"categories":["Android"],"content":" 我们确实找不到一套方案来解决所有问题，所以我们都做了。\n 美团点评资深技术专家 方锦涛 如是说。\n《美团客户端动态化实践》的学习笔记。\n 除了一些重交互的效率工具，其它的都是JS的天下。\n 关于美团业务  200+个品类 美团客户端平台  众口难调  业务发展阶段不一样 团队技术栈不一样 历史包袱不一样      移动端开发的痛点  Native  多端开发 升级慢   H5  功能弱 体验差   Native优化  提高迭代效率  开发效率 更新效率     H5优化  功能问题 体验问题   已知方案  百度 轻应用，小程序，DynamicLoadAPK，ReactNative，HtmlNative 阿里巴巴 支付宝小程序，Weex，Atlas，Tangram 腾讯 微信小程序，VasSonic，ReactNative Google Android Instant App，Progressive Web App，Flutter Facebook ReactNative 携程 DynamicAPK，Ctrip ReactNative（CRN） 滴滴 VirtualAPK，DynamicCocoa 其它 快应用   动态化技术方案总结  布局动态化 虚拟运行环境 业务插件化 Web容器增强    美团动态化方案的选择  特点  迁移效率 开发效率 更新效率 稳定性 流畅度   Web容器增强  流畅度太差   业务插件化  开发效率稍差   布局动态化  方案简单，稳定，用在了美团首页   虚拟运行环境  迁移效率低 开发效率高 美团“发现”Tab 使用的ReactNative   美团客户端动态化的痛点  动态化诉求不一致  业务发展阶段不同 团队技术栈不同 历史包袱不同   确定 多套解决方案  布局动态化  MTFlexbox 美团首页、搜索结果页、外卖首页、美食首页等   业务插件化  美团插件化框架 Hydra 搜索业务，火车票、机票、周边游、到餐旗舰店、金融闪付等   虚拟运行环境  MRN 收藏业务、内容业务、火车票部分页面、外卖退款页等   Web容器增强  TitansX 各种运营活动页面        移动端动态化未来之路   PC年代\n CS - 纯客户端开发  生产力工具，重交互效率   PS - 网页  功能专一      移动年代 类似PC\n 编辑工具，效率工具  还是Native的天下   交易工具  BS方向，小程序，快应用，PWA，RN   资讯工具  小程序、PWA   通讯工具  业务插件化     ","description":"","tags":["Android","30天学习打卡"],"title":"没有办法一劳永逸，所以我们面面俱到","uri":"/posts/2%E6%9C%8820%E6%97%A5/"},{"categories":["Android"],"content":" AAB的开发套件太爽了，不想就这样暴殄天物。\n 爱奇艺资深工程师 陈家威 如是说。\n《基于Android App Bundle动态化方案探索》的学习笔记。\n 爱奇艺的Qigsaw方案脱胎于AAB，紧跟Google的脚步又适应国内环境，高大上又接地气。\n Google减少APK体积的发展历程  以前的发布过程，周期长，占用更多空间  包含所有so库 包含所有资源   包体积和安装成功率呈反比 Multiple APK  Google Play支持 通过不同配置，下发不同apk 通过Gradle 的split配置打包  像素配置 架构配置   推广使用并不好   Android App Bundle  apk转换为 aab 上传aab到Google Play Google Play将aab拆分成多个apk  Base APK Configuration APK 下载是根据配置下载：Base APK + Configuration APK + xxhdpi APK + arm64 APK Dynamic Feature 根据设备配置继续拆分      国内插件化发展回顾及原理分析   国内插件化\n AndroidDynamicLoad DynamicLoadAPK Neptune OpenAtlas DroidPlugin    原理\n BaseDexClassLoader加载class Resources AssetManager BaseDexLassLoader加载lib中的so AndroidManifest记录四大组件    单类加载器\n Element 对应 DexFile，加载Dex NativeLibraryElement 对应 File 记录so目录    多类加载器\n 替换系统ClassLoader 每个插件，独立的ClassLoader加载    资源加载\n 资源文件ID PP（系统应用还是第三方 7F）TT（资源类型）EEEE（顺序） AAPT|AAPT2生成资源ID 调用AssetManager#addAssetPath(String) 加载Asset资源  系统资源 PP01 PP02 PP03 App资源 PP7F 插件 PP7E   资源隔离 资源分区    启动未在宿主AndroidManifest文件注册的Activity\n 插状预埋方式  startActivity后，execStartActivity时替换Class信息，newActivity时还原Class信息      Android App Bundle原理介绍  Split APK  Android 5.0提供 减少包体积 签名相同 同一个应用 如何安装？  adb 安装：adb install-multiple [base-apk,split1-apk] PackageInstaller安装  在运行期间，安装Split APKs 安装后，宿主应用进程会被杀死   系统应用可以静默安装Split APKs   如何加载的 - LoadedAPK 用于保存当前已加载APK的本地状态  mClassLoader  创建PathClassLoader ：createOrUpdateClassLoaderLocked(List addedPaths) 增加Split APks路径   mResources  getSplitRources   mApplication   AAB如何加载插件  Play Core Library，Google Play支持 SplitCompat 为了可以及时插件生效，与国内插件化很类似   国内无法使用Google Play    Qigsaw简介及原理分析   利用AAB开发套件，爱奇艺自研的动态组件化方案\n  设计原因\n 开发者希望插件和基线能在同一工程写作开发  体验好 共同学习   Android P对私有API访问限制 利用AAB强大的开发套件 便于国际化    开发初体验\n 全新的打包插件 dynamic-feature 插件和Base 可以同一开发调试 部分插件可以和主apk打包在一起，部分插件apk上传到cdn    核心优势\n “山寨”Play Core Library公开接口实现，开发者阅读官方文档即可开发 Hook，少量私有API访问（Grey list） 利用AAB开发工具 支持Android4.0及以上 任何进程均可加载插件 国际化和AAB无缝切换    对比其它插件化框架\n 接入方便 无需关心插件上传，分发    插件安装加载过程\n 与AAB过程类似    如何工作的\n  单类加载器\n  资源加载使用Qigsaw独有方式，插件提供代码插入\n1 2 3 4  public Resources getResources(){ SplitInstallHelper.loadResources(this,super.getResources()); return super.getResources(); }       扩展功能\n 多进程支持  解决“那个进程发起插件请求，插件就加载到哪个进程里”问题  捕获ClassNotFoundException异常然后在game进程中加载已安装单未加载的插件   Hook PathClassLoader   支持插件的Application，在插件启动时创建Application实例，并调用生命周期方法 支持插件的Provider  进程启动时移除插件Provider 插件启动时再进行Provider安装   与Tinker融合  通过Tinker Patch下发插件更新  assets文件中的文件记录版本号     在爱奇艺的应用场景  爱奇艺小游戏和小程序框架，是通过Qigsaw加载的 19年初上线，经受数亿用户考研 崩溃率接近于0%   开源计划  已开源 地址：https://github.com/iqiyi/Qigsaw     ","description":"","tags":["Android","30天学习打卡"],"title":"基于AAB的插件化方案：Qigsaw","uri":"/posts/2%E6%9C%8819%E6%97%A5/"},{"categories":["Web"],"content":" 快应用最大的特点就是秒开妙用，用完即走。\n 小米快应用前端负责人 董永清 如是说。\n《快应用开发与实现指南》的学习笔记。\n ​\t作为原生APP开发者，对H5开发并不是很了解，尤其是涉及到架构方面，学习快应用相关知识，主要是了解现在手机应用开发的趋势，各种技术的实现原理和特点。\n​\t快应用在实现方案上，对标微信小程序，体验上应该也比较类似，只是提供原生支持的从微信应用换到了手机厂商的内置支持。\n 背景介绍   什么是快应用，视频介绍\n 秒开 用完即走 3月20日，小米及其它9家厂商宣布快应用诞生，统一了标准 多家手机厂商内置到room中    多场景应用\n -1屏、浏览器入口、全局搜索入口、应用商店入口等    技术如何做到\n  移动网页 - 无需安装，升级容易；性能差，功能确实\n  原生应用 - 性能好，功能完整 ；需要下载安装，版本问题\n  快应用 - 秒开，容易管理，性能好，功能完整\n  开发体验：接入成本大？\n  和H5开发体验类似\n  静态页面\n 标签 样式 脚本    调整样式\n flex css属性子集 多种选择器    系统能力\n import引入系统能力，import prompt from '@system.prompt' 调用方法 prpmpt.showToast() 其它功能     我理解的系统能力，就是系统内置一套快应用专用的web框架，和微信的小程序的方案完全相同。\n  响应事件  模块定义 ViewModel 数据模型 public，protected，private 组件事件 click，appear，focus   声明周期  页面创建 页面可见性 页面销毁 按键响应 - 实体按键，虚拟按键          开发体验  组件化  自定义组件  引入组件 使用组件     原生组件  List，list-item，tabs等   动画 调试开发  devtools  Elements 查看dom结构 Style 修改节点样式 Source 调试js代码 Console 输出日志，数据结构     总结  前端概念 + MVVM + 组件化    架构概述   编译时\n ux页面：html + style + script js页面：json+js 页面UI：DOM树    运行时\n rpk压缩文件    流程\n UX =\u003e 编译时 =\u003e JS页面 =\u003e 运行时 =\u003e 页面UI 多页面 =\u003e 编译时 =\u003e rpk压缩文件 =\u003e 运行时 =\u003e 应用    编译时工具\n hap-toolkit工具  脚手架 编译器 调试器/服务器      运行时\n js引擎 渲染引擎    JS层架构\n 架构输出  MVVM 组件化 数据驱动 Diff实现   应用管理  页面 生命周期 DOM模型 样式计算   基础能力  组件 系统能力 第三方服务 回调机制      DOM模型\n  样式计算引擎\n 编译样式 元素更新 合并计算 优化  选择器规则分类 缓存元素子节点匹配规则 懒合并计算      页面渲染\n 创建页面 -\u003e 建立DOM模型 -\u003e 节点转换、布局 -\u003e Android OS层   ","description":"","tags":["快应用","30天学习打卡"],"title":"秒开秒用，用完即走","uri":"/posts/2%E6%9C%8818%E6%97%A5/"},{"categories":["Android"],"content":" 紧密的Follow官方，平滑过度才是插件化最稳妥的道路。\n 京东商城资深 Android 系统架构师 张志强 如是说。\n《当插件化遇上Android P》的学习笔记。\n Android P禁止调用非SDK接口，对插件化技术有很大的挑战，但更禁止了不良开发者利用非SDK接口做对用户不利的行为，总体来说，利大于弊，支持官方。\n Android P 禁令  禁止应用程序调用非SDK接口  浅灰名单 深灰名单 黑名单    Android AppBundles  Legacy APK - 所有资源一个包 Dynamic Delivery - 动态下发  将APK拆分成多个，动态下发用户需要的 AAB的整体流程  上传Base apk 和AAB到Google Play 用户下啊在Base apk，根据需求下载AAB资源   限制  必须通过Google Play发布 最低版本支持Android 5.0 不是很成熟，单纯的减少了包的体积，无法通过动态下发修复bug或者增加新功能   成本 AS 3.2 集成Play Core Library 加入SplitCompat库以支持6.0以下的手机Dynamic feature apk 所有模块必须位于同一个工程 如果之前的Library想改造成Dynamic Feature Module必须手动改造    Android插件化路在何方  用到了哪些黑科技  Hook app中关键技术点，达到动态劫持页面请求 动态加载插件中的Class，大量使用反射  单ClassLoader 多ClassLoader   动态加载插件中的资源  反射调用AssetsManager中的addAssetPath()方法      ###京东架构升级和重构\n  为什么需要插件化\n 65536 模块解偶 多团队并行开发 加快编译速度 动态部署，修复bug和发布新功能    我们的需求\n 去除黑科技 平稳过度 边界隔离 并行开发 独立调试 快速编译 动态部署    路在何方\n  Follow官方\n  组件化\n  大前端技术\n RN 快应用 Weex    步骤\n 增加组件化功能    组件化 + 插件化 AAB、前端技术 持续改进和优化    重构\n 去除插件化黑科技 平稳过度 JdLib去中心化 插件组件随时互转    京东架构升级\n Aura插件化架构升级 -\u003e Aura Plus  插件和组件灵活互转 无缝调用 优势互补 去中心化 平台支撑   重构后架构图  一切皆组件      解密关键技术点  高内聚低耦合  以Project和Module为边界进行组件间隔离  一主工程多字工程开发模型  多个仓库：一主多子 Library无需转换到Application 一切皆组件 小团队独立开发     使用暴露API的方法达到组件间灵活通讯和调用的目地  组件编译产物  Api.jar Full.aar     处理组件的依赖关系  组件无依赖传递，边界隔离   武林秘籍  通过Gradle插件实现方便的依赖引用 预防资源id冲突：resourcePrefix 统一管理第三方库：ThirdBundle 统一管理公共资源：BaseResBundle     ","description":"","tags":["Android","30天学习打卡"],"title":"Android插件化路在何方","uri":"/posts/2%E6%9C%8817%E6%97%A5/"},{"categories":null,"content":" 多重回调的回调地狱，就像是龟派气功。\n 饿了么资深Android工程师 张涛 如是说。\n《领略Kotlin协程的力量》的学习笔记。\n Kotlin的协程功能确实非常强大，类似Flutter的async/await使用。\n 什么是协程   进程 - 进程间切换要保存状态数据\n 单CPU 时间分片 多CPU 并行执行    线程 - 多线程切换，寄存器保存状态\n 线程阻塞    协程概念：通过提升CPU利用率，减少线程切换，进而提升CPU运行效率\n  协程的特点\n 可控制 - 协程能做到可被控制的发起子任务 轻量级 - 协程非常小，占用资源比线程还少 语法糖 - 使多任务或多线程切换不再使用回调方法    如何使用Kotlin协程   例子：第三方登录，多个顺序接口请求\n  不用协程：需要多重回调，陷入了回调地狱\n  使用协程： runBlocking - T 用于执行协程任务，通常用于启动最外层协程\n  launch：Job 协程内启动协程\n1 2 3  fun setText(name: String) = launch(UI){ textView.text = name }     async/await：Defered 成对出现，用于执行协程并获取返回值\n1 2 3  suspend fun requestToken() = async(CommonPool){ return@async \"curl http://www.example.com\" }.await()     suspend关键字\n  suspend修饰的函数（或lambda），只能被suspend修饰的函数（或lambda）调用\n1 2 3 4 5 6 7 8 9 10 11  // 编译前 suspend fun requestToken():String {...} // 编译后 Object requestToken(Continuation\u003cString\u003e c) {...} // Continuation接口 interface Continuation\u003cin T\u003e { val context: CoroutineContext fun resume(value: T) // 成功回调  fun resumeWithException(e: Throwable) // 失败回调 }       如何在现有的项目中引入协程  使用扩展方法，扩展已有方法  1 2 3 4 5 6  interface Service { fun requestToken(): Call\u003cToken\u003e } suspend fun requestToken(): String = serverInterface.requestToken().await()    改进I/O操作  1 2 3 4 5 6 7 8  fun save(textView: TextView, file: File) = runBlocking { val text = textView.text.toString() val deferred = async(CommonPool) { file.appendText(text) file.readText() } deferred.await() }    引入协程时充分利用协程的特性 不要滥用协程 ","description":"","tags":["Kotlin","30天学习打卡"],"title":"回调地狱就像龟派气功","uri":"/posts/kotlin/2%E6%9C%8815%E6%97%A5/"},{"categories":null,"content":" 偷懒是一种美德\n 阿里巴巴技术专家 陈新新 如是说。\n《基于FLutter \u0026 Dart的全栈开发》的学习笔记。\n 了解到了闲鱼是如何将Flutter \u0026 Dart应用到前后端一体化开发的，没想到FLutter结合Dart Server能够实现这么令人惊艳的开发模式！\n 闲鱼移动端框架演进  原生 + H5 + WEEX 原生 + Flutter  原生性能 - 渲染引擎、AOT、无锁GC 快速开发 - 亚秒级、有状态的热重载 统一的应用开发体验 - 两端一致的开发方式，Material和Cupertino    ###Flutter快速开发\n Hot Reload  Flutter在闲鱼应用过程  2个人3个月，做出闲鱼国际版本 接近Native的效果 关键问题解决  混合开发：工程管理和混合栈管理  Flutter产物引入原生项目   外接纹理播放视频 图片缓存优化 无反射JSON序列化 私有PUB库、阿里生态适配   Flutter两端统一开发，提高效率  协议定义 接口实现 一个人开发三端  不一样的开发和思维方式 部署运维让客户端开发人员觉得很复杂 增加很多工作量   胶水层 - Dart实现  胶水层多变，领域层少改 详情页所有流量由Dart Server服务 运行时长 - 长时间运行稳定 RT 单机QPS   让Flutter同学快速上手服务端  All in IDE - 制作了很多IDE插件  新建服务 快速部署 本地执行 隔离调试 日志回传 错误定位   服务集合  领域服务 代码转换 - java转Dart工具 服务索引 - 文档索引   简化运维  监控 告警 开关 降级 限流     秒级部署 - Dart Isolate  无需代码提交 运行时隔离 远程热部署   本地测试  本地调用远程服务 - http 单次请求所有日志回传 - Dart Zone   无冲突调试 - Isolate隔离  Isolate 加载每个人的代码 只调试指定Isolate      三端一体化新开发模式  数据模型 - 前后端一致 业务逻辑 - 分拆实现 视图 - 统计两端UI 协议 - 前后端协议用工具生成一套 全链路日志 一体化开发的好处  开发灵活，扩展性好，降低沟通成本 协议三端一致，提高性能和效率 一体化开发，全链路日志和调试 服务端更专注领域服务的通用性和性能    未来和研发自动化的结合  研发自动化  UI2Code - UI生成代码 Fluttter代码生成 Data Bind - 生成协议   即将开源  Dart Server Framework Dart Server IDE Plugins   ","description":"","tags":["Flutter","30天学习打卡"],"title":"偷懒是一种美德","uri":"/posts/2%E6%9C%8814%E6%97%A5/"},{"categories":null,"content":" Flutter要运行在所有能显示的设备上。\n 密歇根大学人机交互博士、Google Flutter团队高级研究员 董韬 如是说。\n《Flutter：最新进展和未来展望》的学习笔记。\n 今天的学习内容，并不高深，都是一些基础知识，但是学到了几个非常实用的语法，也促使我要好的看一下Dart的各个版本更新内容文档了！\n Flutter基本介绍和在中国的发展状况  什么是Flutter  18年 Flutter Live 发布1.0版本   特点  美观、快速、高效、开放 非常受开发者欢迎   在中国的发展  闲鱼的一位开发者提交的PR数量超过了Google专职Flutter开发的工程师的个人提交数量 （震惊） Flutter多平台：Mobile、Web、Desktop、Enbedded    多平台远景：Flutter for Web  代码库已合并到Flutter主SDK中 SDK  和移动端最大条件的复用 Flutter framework in Dart（widgets, gestures, etc） Flutter Web engine 类似原生的 C++ Flutter engine   Flutter Web engine  HTML + CSS 来绘制图形  利用浏览器自身的性能优化 不担心尺寸兼容   Canvas 2D 备用绘图选项  性能和缩放问题   未来计划 CSS Paint API 代替 Canvas以提高性能，不过浏览器支持不太好 依赖Flutter框架 Dart2js compiler  在Google应用广泛 ：Google广告业务体系等 高效、成熟     应用场景  作为移动应用的配套程序 先体验后下载 覆盖更多用户 使用桌面端的输入输出需求 高度交互元素复用   性能  桌面浏览器 60FPS以上 移动浏览器  一般手机 60FPS 差手机 达不到60FPS     开发体验  Widget API 和移动端一致   局限和后续研发  合并到Flutter SDK 保证所有widgets正确渲染 性能优化 完善对浏览器无障碍功能的支持 添加插件系统来使用现有的JS库 加强开发调试工具的可用性    生态建设：与社区共建的状态管理解决方案  社区开发者设计的状态管理解决方案 地址 官方推荐 provider  ChangeNotifier ChangeNotifierProvider Consumer    开发体验：“UI as Code” - 编程语言和IDE的改进   Dart代码编写Flutter UI的优点和改进空间\n  声明式UI\n  改进空间\n 复杂UI逻辑会使用命令式语法，打破代码结构和UI视觉结构的一致性 死亡嵌套！      新语法\n  Controll Flow Elements in Collections\n 在集合中使用if 和for来操作UI\n   Spread Operator‘...’ - 展开操作符\n 构建集合时，可以更方便的将小集合动态组合起来，非常实用\n     IDE优化\n UI Guides child 和children的缩写优化探索    以往的改进\n new关键字非必须 UI as Code UI Guides    Flutter/Dart近期展望  改进Flutter和原生混编的机制和开发体验（add-to-app） Dart语言演进 non-nullable, extension methods, Dart runtime增加FFI(C/C++ interop) 更容易理解的报错信息 Flutter Web性能优化，Flutter Desktop功能完善，FLutter路线图 ","description":"","tags":["Flutter","30天学习打卡"],"title":"Flutter要运行在所有能显示的设备上","uri":"/posts/2%E6%9C%8813%E6%97%A5/"},{"categories":null,"content":" 很后悔从后端转到移动端，这个大坑。\n 头发日渐稀疏的贝壳找房移动端资深工程师 张华峰 如是说。\n《Flutter在贝壳的接入实践》的学习笔记。\nFlutter贝壳接入案例  Android工程师，在不熟悉的情况下，Flutter比原生花费1.1 -1.2倍的时间，iOS端同步运行 “海神”监控Exception率，原生是万分之0.7，Flutter低于万分之0.7  Flutter工程基础   SDK\n pub_cache bin packages    工程类型\n Flutter Application - Flutter标准应用程序  DartLib Android子工程 iOS子工程   Flutter Plugin - 封装Native工程的基础拓展 Flutter Package - 纯Dart库 Flutter Module - FLutter作为子Module    原生工程接入Flutter\n  官方方案 - Flutter Module引入原生项目\n 耦合度高 - 所有的Flutter代码都在同一个Module里 编译成本比较高 - 原生编译 + Flutter Module编译      闲鱼接入方案\n Flutter产物放入远端，当作Lib引入到原生    贝壳接入方案\n 原生解偶 - 对原生影响最小 屏蔽平台 - 工程师会Dart和Flutter UI即可 业务分离 - 同基础，分散业务 保证开发效率 方便继承 - 减少人工干预，少量维护     开发时，是Flutter Application，各个业务以package存在，运行在原生的壳工程中，速度相对较快。 通过Target文件和透传原生的Flavor实现不同资源/渠道的打包。\n Flutter接入方案介绍与理论基础   Flutter编译模式   Flutter构建流程Debug模式   Flutter构建流程Release模式   Flutter构建工具链   Flutter构建工具   Flutter gradle脚本修改   Flutter构建工具flutter_tools修改   Flutter日常开发构建流程（Android）   Flutter持续继承构建流程（Android）   Flutter热更新探索  动态产物下载  只支持Android 实现简单   DSL - 动态语言映射FLutter UI  实现复杂 在Flutter生态中比较危险 双端都适用   贝壳的热更新方案  Android - 使用原生的插件化框架将Flutter业务做成单独插件 iOS - 避免审核异常，暂不实现热更新 Flutter for Web - 和app UI几乎完全一致，通过开关控制Flutter和Flutter web的切换     干货很多，值得认真学习。\n","description":"","tags":["Flutter","30天学习打卡"],"title":"移动端是个大坑-Flutter在贝壳的接入实践学习笔记","uri":"/posts/2%E6%9C%8812%E6%97%A5/"},{"categories":null,"content":" 好奇心 + 懒惰 是 工程师 最大的美德。\n 在福厂修福报修了7年的福娃 于佳（宗心） 如是说。\n《闲鱼基于Flutter技术的架构演进与创新》的学习笔记。\n演讲PPT下载，InfoQ登录可下载。\nFlutter在闲鱼的优势与挑战   Flutter吸引作者的几点\n Flutter的Skia底层跨端渲染保证了效率和各平台的一致性； Dbug链路、Hot Reolad等功能在客户端开发商非常先进； 开箱即用的Widget，加快开发速度。    什么样的团队适合使用Flutter\n 开发人力资源匮乏的团队； 双端用户不均，不想维护1:1的开发人员； 大公司的APP工厂，业务打法。    如今闲鱼主业务已使用大量Flutter来实现\n  闲鱼的架构演进与创新  如何将Flutter融入到现有原生APP中 - Flutter Boost  Navigator管理 Native生命周期感知   Flutter页面嵌入原生控件  拍摄视频/图片到显示的链路过长，通过传递TextureId实现更短链路，更少的CPU和更少的内存   如何让整个团队快速上手Flutter  Fish-Redux 解决Big cell问题，使用Adapter完成多List的合并     关于闲鱼在Flutter上的的视频/图片优化，有在其它文章中看到过\n 研发智能化在闲鱼的应用  高速公路上换轮胎是很危险的  数据驱动 - 数据化每个过程 bug数量、运行时间、开发时间、数据报表、commit绑定任务id等 自动化 - 持续继承 2-1-7 原则 Exception率 - error收集  ErrorWidget Exception handler isolate Exception   WidgetsFlutterBinding 统计FPS/加载时长 PerformanceFlutterBindingObserver - dispatchEvent    总结与展望  好奇心 + 懒惰 是 工程师 最大的美德 ","description":"","tags":["Flutter","30天学习打卡"],"title":"好奇心 + 懒惰是「工程师」最大的美德","uri":"/posts/2%E6%9C%8811%E6%97%A5/"},{"categories":null,"content":" 我们的宗旨是，做最好的移动软件开发方案。\n 小学没毕业就出国了的 Google Flutter 团队高级工程师 于潇 如是说。\n学习《使用Flutter快速构建集美观与高性能于一体的移动应用》笔记。\n学习地址：https://time.geekbang.org/dailylesson/detail/100016434\n当前移动软件开发中的阻碍  开发太贵 开发太慢 高质量太难 工程资源太难共享  Flutter的研发设计路线  跨平台 高开发效率 简单的表达出UI设计师期望的效果 不牺牲原生的运行速度  Flutter的性能与特点  Hot Reload（热重载）   作为一名Android开发人员，非常能体会到，等待代码编译的过程是多么的让人无奈... 想象一下，现在是晚上九点钟，今晚必须上线，测试小伙伴坐在你旁边，等待着你修复最后一个Bug，你的Wife还在不停的Call你回家恰饭，你飞速的浏览代码定位问题思考正确逻辑飞速敲击键盘完成修改点击Run一气呵成，接下来就是长达8分钟的等待... 编译完成后，测试小伙伴飞速复测，发现还是有问题，继续修改... 这一来一回，十多分钟过去了，修改bug的时间成本太高了！\n保守估计，用上热重载功能的话，能够提高原生客户端开发效率10%以上。\n  声明式+响应式开发模式   具体场景：原生开发中，很多运行时异常不做特殊处理的话，会直接Crash掉，我们需要分析Crash log，修改代码，再重新编译运行来测试；而有了这个功能之后，异常只影响错误的部分，修改掉错误代码后，通过Hot Reolad功能，快速应用到已运行的程序中，既不会Crash，又不需要重新编译运行，这是APP开发前所未有的体验！\n  组合性API   “万物皆Widget”，提供了一套强大的可特制设计的UI系统\n内置Material和Cupertino风格设计组建\n直接GPU渲染\n 系统架构 其它全平台方案架构性能链路 原生平台的性能是很快的，但是跨平台代码和原生交互时，链路很长，性能很差。\nFlutter架构性能链路 Flutter的代码执行链路非常简单，执行效率高。\n性能优化 - 布局 由于Flutter的单个Element是比较简单的，可以从上到下，单次布局，加快运行速度。\nFlutter的使用体验 闲鱼移动团队分享Flutter的使用体验，实现了Flutter和原生APP的混合开发。\n社区支持   Github：https://github.com/flutter/flutter\n  Flutter官网： https://flutter.dev\n  Flutter国内社区： https://flutter.cn\n  版本计划   Flutter : Release 1.12\n  Flutter Web : Beta阶段\n  Flutter Desktop : Dev阶段\n   由于本视频是2018年GMTC的，时间比较久了，直到现在（2020年2月10日），Flutter又有了长足的发展，项目应用也越来越成熟，希望感兴趣的同学多多关注。\n 2018年GMTC视频PPT下载：https://con.infoq.cn/archives/?conf=gmtc\n","description":"","tags":["Flutter","30天学习打卡"],"title":"最好的移动软件开发方案","uri":"/posts/2%E6%9C%8810%E6%97%A5/"},{"categories":null,"content":"基于V1签名方式生成渠道包方法汇总。\n关于Android渠道包生成，以前写过一些小工具，集成了三种渠道包生成方案：反编译方案、美团渠道包生成方案、豌豆荚渠道包生成方案，还有一种比较有效率的打包方案是修改zip文件。\n反编译方案 方案简述： 通过apktool等工具反编译base.apk，修改Manifest.xml中的meta-data值，重打包，签名。\n特点： 过程繁琐，效率低下，无需侵入Android代码。\n美团渠道包生成方案 方案简述： 在APK中的签名文件夹META-INF中，放入空文件，名字为渠道信息，APK运行过程中读取APK源文件中的渠道信息。\n特点 速度快，过程简单，侵入Android代码(重)。\n豌豆荚渠道包生成方案 方案简述： 通过Android SDK提供的AAPT命令，向apk的assert文件夹中加入有内容的渠道文件，重签名，APK运行过程中读取assert目录下的渠道文件。\n特点： 速度一般，过程简单，侵入Android代码(低)。\n修改zip文件方案 方案简述： APK是zip压缩包，末尾是zip压缩包的注释，向其中添加渠道信息，APK运行过程中读取APK源文件中的注释信息，提取出渠道信息。\n特点： 速度快，过程简单，侵入Android代码(重)。\n以上是对四种渠道包生成方案的简介，最近发现360加固保的多渠道包生成是修改Manifest.xml中的内容，生成速度速度炒鸡快，但是生成后需要重签名。\n新发现 最近在使用360渠道包生成工具，生成渠道包速度非常快，而且是直接修改了Manifest.xml中的渠道号，根据这一思路我开始查APK中Manifest.xml文件导出，二进制解码，xml解析修改，Manifest.xml重编码等相关资料，后来发现，其它过程都没问题，只有Manifest.xml重编码没有相关资料，又查了几天，发现自己进入了一个误区，为什么要把Manifest.xml二进制解码再编码？，直接修改二进制文件不就好了，然后查到了这个项目：（apkeditor）AndroidManifest.xml二进制编辑和签名工具，学习了Manifest.xml二进制文件的参数替换和修改等技巧。\n这种Manifest.xml二进制数据替换方案，从打包效率上说比不上美团方案和ZIP注释方案，但是贵在直接修改Manifest.xml中meta-data的数据，不侵入Android代码，最大化兼容了第三方平台渠道号的读取（极光推送只支持从Manifest中读取渠道，不支持动态设置）。\n","description":"","tags":["Android"],"title":"Android多渠道包生成方案学习记录(V1签名)","uri":"/posts/android%E5%A4%9A%E6%B8%A0%E9%81%93%E5%8C%85%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95v1%E7%AD%BE%E5%90%8D/"},{"categories":null,"content":"背景 近日在做网页模拟才做的业务，最初想到的方案是按键精灵，无奈这玩意对网页端的操作支持不太好，所以想到用Web端的自动化测试框架Selenium来实现需求。\nSelenium驱动Chrome浏览器需要官网下载的驱动，但是程序异常退出后，驱动进程依然存在，所以在程序下一次启动的时候，检测驱动进程是否存在，如果存在，全都kill掉，再进行正常的业务流程。\n根据进程名字查询PID tasklist /nh /FI \"IMAGENAME eq \u003ctaskName\u003e\" 关闭进程 // 根据名字关闭进程 taskkill /F /IM \u003ctaskName\u003e // 根据PID关闭进程 taskkill /F /PID \u003ctaskPid\u003e ","description":"","tags":["Windows"],"title":"Windows查询进程PID，关闭进程","uri":"/posts/windows%E6%9F%A5%E8%AF%A2%E8%BF%9B%E7%A8%8Bpid%E5%85%B3%E9%97%AD%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"作为Android开发者，大家都知道，在Android开发中， Service是非常常用的四大组件之一，大部分后台操作的工作都要在Service中执行，Service连接网络发送数据是很普遍的业务，但是Service在手机cpu休眠之后还会继续执行吗？连接网络发送数据正常吗？\n挖个坑，后续填。\n date: 2017-01-31 趁着过年瘫在家，来填坑啦~~~~ 想要分析这个问题是因为工作过程中遇到过心跳数据发送不及时的现象，测试过程中是没有遇到过的，所以怀疑是系统休眠造成的影响，下面就分析一下这种异常的原因。\n测试1，服务是否会异常： 后台服务定时写入日志，每隔1s写入一个Timestamp，手机静止10min查看日志文件；\nst=\u003estart: 创建一个Service logout=\u003eoperation: 每隔1s写入一个Timestamp到日志文件 delay=\u003eoperation: 锁屏静置手机10分钟 showlog=\u003econdition: 检查日志是否正常 ServiceisRight=\u003eend: 服务运行正常 ServiceisWrong=\u003eend: 服务运行异常 st-\u003elogout-\u003edelay-\u003eshowlog showlog(yes)-\u003eServiceisRight showlog(no)-\u003eServiceisWrong 测试2，网络是否会异常： 如果测试1结果为服务运行正常，则执行测试2：\nst=\u003estart: 创建一个Service logout=\u003eoperation: 每隔1s发送一个网络请求 fiddler=\u003eoperation: fiddler抓包检测网络请求 delay=\u003eoperation: 锁屏静置手机10分钟 showlog=\u003econdition: Fiddler抓包是否正常 ServiceisRight=\u003eend: 服务和网络正常 ServiceisWrong=\u003eend: 服务和网络异常 st-\u003elogout-\u003efiddler-\u003edelay-\u003eshowlog showlog(yes)-\u003eServiceisRight showlog(no)-\u003eServiceisWrong 测试结果 测试1结果：服务运行正常； 测试2结果：网络运行异常，每1s发送一次的网络请求，在手机休眠后，变成了每5s左右发送一次。\n结果分析 手机休眠后，后台服务仍然在运行，但是网络CPU进入休眠状态，应用无法访问网络，网络CPU每隔一段时间被Baseband Processor（BP）唤醒一次，应用可以访问网络，然后继续进入休眠状态，依次循环。\n注意 手机插着数据线调试的时候，是不会进入休眠状态的。\n更多资料 android设备休眠 PowerManager\n","description":"","tags":["Android","service"],"title":"Android Service在手机cpu休眠之后还会运行吗？","uri":"/posts/android-service%E5%9C%A8%E6%89%8B%E6%9C%BAcpu%E4%BC%91%E7%9C%A0%E4%B9%8B%E5%90%8E%E8%BF%98%E4%BC%9A%E8%BF%90%E8%A1%8C%E5%90%97/"},{"categories":null,"content":"Activity启动模式 四种：standard singleTop singleTask singleInstance\nstandard，标准模式  标准的启动模式，每次StartActivity() 都会创建实例。 注意： 需要Activity对象的context，如果是Application的context，需要加一个flag，FLAG_ACTIVITY_NEW_TASK。\n singleTop,栈顶复用模式  有实例在栈顶的时候才复用。\n singleTask,栈内复用模式  只要栈中有实例，就会复用。 自带clearTop属性 ABCD-\u003eD调用singleTask属性的B-\u003eAB\n singleInstance,栈外复用模式（单实例模式）  会新启动一个栈，创建实例。\n 注意 复用：调用的onNewIntent()方法。\n问题 singleInstance的Activity调用startActivity创建的standard属性的Activity，这个新的实例在那个栈里呢？\n标记位 总结：Activity的标记位功能不确定，需要自己去测试，并且文档里的描述也是不准确的。\n","description":"","tags":["Android","Android高手进阶视频","笔记"],"title":"Activity的启动模式和标志位","uri":"/posts/activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E6%A0%87%E5%BF%97%E4%BD%8D/"},{"categories":null,"content":"原文链接： https://developer.android.com/preview/api-overview.html\nAndroid N for Developers Android N 仍处于活动的开发状态，但现在您可以将其作为 N Developer Preview 的一部分进行试用。以下部分重点介绍面向开发者的部分新功能。\n请务必查阅行为变更以了解平台变更可能影响您的应用的领域，看看开发者指南，了解有关关键功能的更多信息，并下载 API 参考以获取新 API 的详细信息。\n多窗口支持 在 Android N 中，我们为该平台引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。\n现在，用户可以一次在屏幕上打开两个应用。\n在运行 Android N 的手机和平板电脑上，用户可以并排运行两个应用，或者处于分屏模式时一个应用位于另一个应用之上。用户可以通过拖动两个应用之间的分隔线来调整应用。 在 Android TV 设备上，应用可以将自身置于画中画模式，从而让它们可以在用户浏览或与其他应用交互时继续显示内容。如需了解详细信息，请参阅下文。\n多窗口支持为您提供新的吸引用户方式，特别是在平板电脑和其他更大屏幕的设备上。您甚至可以在您的应用中启用拖放，从而使用户可以方便地将内容拖放到您的应用或从其中拖出内容—这是一个非常好的增强用户体验的方式。\n向您的应用添加多窗口支持并配置多窗口显示的处理方式非常简单。例如，您可以指定您的 Activity 允许的最小尺寸，从而防止用户将 Activity 调整到该尺寸以下。您还可以为应用禁用多窗口显示，这可确保系统将仅以全屏模式显示应用。\n如需了解详细信息，请参阅多窗口支持开发者文档。\n通知增强功能 在 Android N 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括：\n模板更新：我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。 绑定的通知：系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行 Dismiss 或 Archive 等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模型。 直接回复：对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。 自定义视图：两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。\n如需了解如何实现新功能的信息，请参阅通知指南。\n配置文件指导的 JIT/AOT 编译 在 Android N 中，我们添加了 Just in Time (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。\n配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用的热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。\n除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。\nAndroid 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。\n快速的应用安装路径 Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤。\n外出瞌睡模式... Android 6.0 推出了瞌睡模式，即设备处于空闲状态时，通过推迟应用的 CPU 和网络活动以实现省电目的的系统模式，例如，设备放在桌上或抽屉里时。\n现在，在 Android N 中，瞌睡模式又前进了一步，在外出时也可以省电。只要屏幕关闭了一段时间，且设备未插入电源，瞌睡模式就会对应用使用熟悉的 CPU 和网络限制。这意味着用户即使将设备放入口袋里也可以省电。\n屏幕关闭片刻后，设备在使用电池时，瞌睡模式将限制网络访问，同时延迟作业和同步。在短暂的维护时间范围后，其允许应用访问网络，并执行延迟的作业/同步。打开屏幕或将设备插入电源会使设备退出瞌睡模式。\n当设备再次处于静止状态时，屏幕关闭且使用电池一段时间，瞌睡模式针对 PowerManager.WakeLock, AlarmManager 警报和 GPS/Wi-Fi 扫描应用完整 CPU 和网络限制。\n无论设备是否处于运动状态，将应用调整到瞌睡模式的最佳做法均相同，因此，如果您已更新应用以妥善处理瞌睡模式，则一切就绪。如果不是，请立即开始将应用调整到瞌睡模式。\nProject Svelte：后台优化 Project Svelte 在持续改善，以最大程度减少生态系统中一系列 Android 设备中系统和应用使用的 RAM。在 Android N 中，Project Svelte 注重优化在后台中运行应用的方式。\n后台处理是大多数应用的一个重要部分。处理得当，可让您实现非常棒的用户体验 — 即时、快速和情境感知。如果处理不得当，后台处理会毫无必要地消耗 RAM（和电池），同时影响其他应用的系统性能。\n自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。JobScheduler 可实现控制和简洁性，我们想要所有应用都使用它。\n另一个非常好的选择是 GCMNetworkManager（Google Play 服务的一部分），其在旧版 Android 中提供类似的作业安排和兼容性。\n我们在继续扩展 JobScheduler 和 GCMNetworkManager，以符合多个用例 — 例如，在 Android N 中，现在，您可以基于内容提供程序中的更改安排后台工作。同时，我们开始弃用一些较旧的模式，这些模式会降低系统性能，特别是低内存设备的系统性能。\n在 Android N 中，我们删除了三个常用隐式广播 — CONNECTIVITY_ACTION、ACTION_NEW_PICTURE 和 ACTION_NEW_VIDEO — 因为这些广播可能会一次唤醒多个应用的后台进程，同时会耗尽内存和电池。如果您的应用收到这些广播，请充分利用 N Developer Preview 以迁移到 JobScheduler 和相关的 API。\n如需了解详情，请查看后台优化文档。\nData Saver 在移动设备的整个生命周期，蜂窝数据计划的成本通常会超出设备本身的成本。对于许多用户而言，蜂窝数据是他们想要节省的昂贵资源。\nAndroid N 推出了 Data Saver 模式，这是一项新的系统服务，有助于减少应用使用的蜂窝数据，无论是在漫游，账单周期即将结束，还是使用少量的预付费数据包。Data Saver 让用户可以控制应用使用蜂窝数据的方式，同时让开发者打开 Data Saver 时可以提供更多有效的服务。\n用户在 Settings 中启用 Data Saver 且设备位于按流量计费的网络上时，系统屏蔽后台数据使用，同时指示应用在前台尽可能使用较少的数据 — 例如，通过限制用于流媒体服务的比特率、降低图片质量、延迟最佳的预缓冲等方法来实现。用户可以将特定应用加入白名单以允许后台按流量的数据使用，即使在打开 Data Saver 时也是如此。\nAndroid N 扩展了 ConnectivityManager，以便为应用检索用户的 Data Saver 首选项并监控首选项变更提供一种方式。所有应用均应检查用户是否已启用 Data Saver 并努力限制前台和后台数据的使用。\n快速设置图块 API “快速设置”通常用于直接从通知栏显示关键设置和操作，非常简单。在 Android N 中，我们已扩展“快速设置”的范围，使其更加有用更方便。\n我们为额外的“快速设置”图块添加了更多空间，用户可以通过向左或向右滑动跨分页的显示区域访问它们。我们还让用户可以控制显示哪些“快速设置”图块以及显示的位置 — 用户可以通过拖放图块来添加或移动图块。\n对于开发者，Android N 还添加了一个新的 API，从而让您可以定义自己的“快速设置”图块，使用户可以轻松访问您应用中的关键控件和操作。\n对于急需或频繁使用的控件和操作，保留“快速设置”图块，且不应将其用作启动应用的快捷方式。\n定义图块后，您可以将它们显示给用户，用户可通过拖放将图块添加到“快速设置”。\n如需创建应用图块的更多信息，请参阅可下载的 API 参考中的 android.service.quicksettings.Tile。\n号码屏蔽 Android N 现在支持在平台中进行号码屏蔽，提供框架 API，让服务提供商可以维护屏蔽的号码列表。默认短信应用、默认手机应用和提供商应用可以对屏蔽的号码列表进行读取和写入操作。其他应用则无法访问此列表。\n通过使号码屏蔽成为平台的标准功能，Android 为应用提供一致的方式来支持广泛的设备上的号码屏蔽。应用可以利用的其他优势包括：\n还会屏蔽已屏蔽的来电号码发出的短信 通过 Backup \u0026 Restore（备份和还原）功能可以跨重置和设备保留屏蔽的号码 多个应用可以使用相同的屏蔽号码列表 此外，通过 Android 的运营商应用集成表示运营商可以读取设备上屏蔽的号码列表，并为用户执行服务端屏蔽，以阻止不需要的来电和短信通过任何介质（如 VOIP 端点或转接电话）到达用户。\n如需了解详细信息，请参阅可下载的 API 参考中的 android.provider.BlockedNumberContract。\n来电过滤 Android N 允许默认的手机应用过滤来电。手机应用执行此操作的方式是实现新的 CallScreeningService，该方法允许手机应用基于来电的 Call.Details 执行大量操作，例如：\n拒绝来电 不允许来电到达呼叫日志 不向用户显示来电通知 如需了解详细信息，请参阅可下载的 API 参考中的 android.telecom.CallScreeningService。\n多区域设置支持、多语言 Android N 现在允许用户在设置中选择多个区域设置，以更好地支持双语用例。应用可以使用新的 API 获取用户选择的区域设置，然后为多区域设置用户提供更成熟的用户体验 — 如以多个语言显示搜索结果，并且不会以用户了解的语言翻译网页。\n除多区域设置支持外，Android N 还扩展了用户可用的语言范围。它针对常用语言提供超过 25 种的变体，如英语、西班牙语、法语和阿拉伯语。它还针对 100 多种新语言添加了部分支持。\n应用可以通过调用 LocaleList.GetDefault() 获取用户设置的区域设置列表。为支持扩展的区域设置数量，Android N 正在改变其解析资源的方式。请务必使用新的资源解析逻辑测试和验证您的应用是否能如期运行。\n如需有关新资源解析行为和应遵循的最佳做法的更多信息，请参阅多语言支持。\nAndroid 中的 ICU4J API Android N 目前在 Android 框架（位于 android.icu 软件包下）中提供 ICU4J API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。\n如果要了解有关 Android ICU4J API 的更多信息，请参阅 ICU4J 支持。\nOpenGL™ ES 3.2 API Android N 添加了框架接口和对 OpenGL ES 3.2 的平台支持，包括：\n来自 Android 扩展包 (AEP) 的所有扩展（EXT_texture_sRGB_decode 除外）。 针对 HDR 的浮点帧缓冲和延迟着色。 BaseVertex 绘图调用可实现更好的批处理和流媒体服务。 强大的缓冲区访问控制可减少 WebGL 开销。 Android N 上适用于 OpenGL ES 3.2 的框架 API 与 GLES32 类一起提供。使用 OpenGL ES 3.2 时，请务必通过  标记和 android:glEsVersion 属性在您的清单文件中声明要求。\n如需了解有关使用 OpenGL ES 的信息，包括如何在运行时检查设备支持的 OpenGL ES 版本，请参阅 OpenGL ES API 指南。\nAndroid TV 录制 Android N 通过新的录制 API 添加了从 Android TV 输入服务录制和播放内容的功能。构建在现有时移 API 之上，TV 输入服务可以控制能够录制的渠道数据、保存录制的会话的方式，同时可通过录制的内容管理用户交互。\n如需了解详细信息，请参阅 Android TV 录制 API。\nAndroid for Work Android for Work 针对运行 Android N 的设备添加了许多新功能和 API。部分重要内容如下— 有关与 Android N 相关的 Android for Work 更新的完整列表，请参阅 Android for Work 变更。\n托管配置文件安全性挑战 配置文件所有者可以指定为托管配置文件中运行的应用指定单独的安全性挑战。当用户尝试打开任何工作应用时将显示工作挑战。成功完成安全性挑战可解锁托管配置文件并将其解密（如果需要）。对于配置文件所有者，ACTION_SET_NEW_PASSWORD 提示用户设置工作挑战，ACTION_SET_NEW_PARENT_PROFILE_PASSWORD 提示用户设置设备锁。\n配置文件所有者可以使用 setPasswordQuality()、setPasswordMinimumLength() 和相关方法针对工作挑战设置不同的密码策略（例如，PIN 必须多长，或是否可以使用指纹解锁配置文件）。配置文件所有者还可以使用新的 getParentProfileInstance() 方法返回的 DevicePolicyManager 实例设置设备锁定。此外，配置文件所有者可以使用新的 setOrganizationColor() 和 setOrganizationName() 方法针对工作挑战自定义凭据屏幕。\n关闭工作 在具有托管配置文件的设备上，用户可以切换工作模式。工作模式关闭时，管理的用户临时关闭，其禁用托管配置文件应用、后台同步和通知。这包括配置文件所有者应用。关闭工作模式时，系统显示永久状态图标，以提醒用户他们无法启动工作应用。启动器指示该工作应用和小组件无法访问。\nAlways on VPN 设备所有者和配置文件所有者可以确保工作应用始终通过指定的 VPN 连接。系统在设备启动后自动启动该 VPN。\n新的 DevicePolicyManager 方法为 setAlwaysOnVpnPackage() 和 getAlwaysOnVpnPackage()。\n由于 VPN 服务无需应用交互即可由系统直接绑定，因此，VPN 客户端必须针对 Always on VPN 处理新的入口点。和以前一样，由与操作匹配的 Intent 过滤器将服务指示给系统。android.net.VpnService。\n用户还可以使用 Settings\u003eMore\u003eVpn 在主要用户中手动设置实现 VPNService 方法的 Always on VPN 客户端。\n辅助工具增强功能 Android N 现在针对新的设备设置直接在欢迎屏幕上提供“Vision Settings”。这使用户可以更容易发现和配置他们设备上的辅助工具功能，包括放大手势、字体大小、显示屏尺寸和 TalkBack。\n随着这些辅助工具功能更为突出，在启用这些功能后，您的用户更可能试用您的应用。请务必提前启用这些设置测试您的应用。您可以通过 Settings \u003e Accessibility 启用它们。\n还是在 Android N 中，辅助工具服务现在可以帮助具有动作障碍的用户触摸屏幕。全新的 API 允许使用人脸追踪、眼球追踪、点扫描等功能构建服务，以满足这些用户的需求。\n如需了解详细信息，请参阅可下载的 API 参考 中的 android.accessibilityservice.GestureDescription 。\n直接启动 直接启动可以缩短设备启动时间，让注册的应用具有有限的功能，即使在意外重启后。例如，如果当用户睡觉时加密的设备重启，那么注册的警报、消息和来电现在可以和往常一样继续通知用户。这也意味着重启后辅助工具服务会立即可用。\n在 Android N 中，直接启动充分利用基于文件的加密，以针对系统和应用数据启用细化的加密策略。为系统和应用数据。系统针对选定的系统数据和显式注册的应用数据使用设备加密的存储。默认情况下，凭据加密的存储可用于所有其他系统数据、用户数据、应用及应用数据。\n启动时，系统在受限的模式中启动，仅访问设备加密的数据，不会对应用或数据进行常规访问。如果您有想要在此模式下运行的组件，您可以通过在清单文件中设置标记注册它们。重启后，系统通过广播 LOCKED_BOOT_COMPLETED Intent 激活注册的组件。系统确保注册的设备加密的应用数据在解锁前可用。所有其他数据在用户确认锁定屏幕凭据进行解密前均不可用。\n如需了解详细信息，请参阅直接启动。\n密钥认证 使用硬件支持的密钥库，可更安全地在 Android 设备上创建、存储和使用加密密钥。它们可保护密钥免受 Linux 内核、潜在的 Android 漏洞的攻击，也可防止从已取得 root 权限的设备提取密钥。\n为了让硬件支持的密钥库使用起来更简单和更安全，Android N 引入了密钥认证。应用和关闭的设备可使用密钥认证以坚决地确定 RSA 或 EC 密钥对是否受硬件支持、密钥对的属性如何，以及其使用和有效性有何限制。\n应用和关闭的设备服务可以通过 X.509 认证证书（必须由有效的认证密钥签署）请求有关密钥对的信息。认证密钥是一个 ECDSA 签署密钥，其在出厂时被注入设备的硬件支持的密钥库。因此，有效的认证密钥签署的认证证书可确认硬件支持的密钥库是否存在，以及该密钥库中密钥对的详细信息。\n为确保设备使用安全的官方 Android 出厂映像，密钥认证要求设备 bootloader 向可信执行环境 (TEE) 提供以下信息：\n设备上安装的操作系统版本和补丁级别 验证的启动公钥和锁定状态。 如需了解有关硬件支持的密钥库功能的详细信息，请参阅硬件支持的密钥库指南。\n除密钥认证外，Android N 还推出了指纹绑定密钥，在指纹注册时不会撤销。\n网络安全性配置 在 Android N 中，通过使用说明性网络安全性配置（而不是使用传统的易出错的编程 API（例如，X509TrustManager）），应用可以安全地自定义其安全（HTTPS、TLS）连接的行为，无需任何代码修改。\n支持的功能：\n自定义信任锚。让应用可以针对其安全连接自定义哪些证书颁发机构 (CA) 受信任。例如，信任特定的自签署证书或受限的公共 CA 集。 仅调试重写。让应用开发者可以安全调试其应用的安全连接，而不会增加安装基础的风险。 明文流量退出。让应用可以防止自身意外使用明文流量。 固定证书。这是一项高级功能，让应用可以针对安全连接限制哪些服务器密钥受信任。 如需了解详细信息，请参阅网络安全性配置。\n默认受信任的证书颁发机构 默认情况下，针对 Android N 的应用仅信任系统提供的证书，且不再信任用户添加的证书颁发机构 (CA)。如果针对 Android N 的应用希望信任用户添加的 CA，则应使用网络安全性配置以指定信任用户 CA 的方式。\nAPK signature scheme v2 PackageManager 类现在支持使用 APK signature scheme v2 验证应用。APK signature scheme v2 是一个整个文件签名架构，通过检测对 APK 文件进行的任何未经授权更改，可大幅提高验证速度，同时也可加强完整性保证。\n为保持向后兼容，在使用 v2 签名架构签署之前，APK 必须先使用 v1 签名架构（JAR 签名架构）签署。对于 v2 签名架构，如果在使用 v2 架构签署后使用额外的证书签署 APK，验证将失败。\nAPK signature scheme v2 支持稍后将在 N Developer Preview中推出。\n作用域目录访问 在 Android N 中，应用可以使用新的 API 请求访问特定的外部存储目录，包括可移动媒体上的目录，如 SD 卡。新 API 大大简化了应用访问标准外部存储目录的方式，如 Pictures 目录。应用（如照片应用）可以使用这些 API（而不是使用 READ_EXTERNAL_STORAGE），其授予所有存储目录的访问权限或存储访问框架，从而让用户可以导航到目录。\n此外，新的 API 简化了用户向应用授予外部存储访问权限的步骤。当您使用新的 API 时，系统使用一个简单的权限 UI，其清楚地详细介绍应用正在请求访问的目录。\n如需了解详细信息，请参阅作用域目录访问开发者文档。\n","description":"","tags":["Android","翻译"],"title":"Android N for Developers","uri":"/posts/android-n-for-developers/"},{"categories":null,"content":"Android Studio修改包需要两步（资源文件访问路径一并修改）：\n第一步： 右击要修改的包名，Refactor\u003eRename，点击 点击Rename package： 然后修改，点击Refactor，然后等： ﻿第二步： 手动修改Manifest里面的package。\n","description":"","tags":["Android"],"title":"Android Studio修改包名","uri":"/posts/android-studio%E4%BF%AE%E6%94%B9%E5%8C%85%E5%90%8D/"},{"categories":null,"content":"挖坑。\n","description":"","tags":null,"title":"Android资源文件混淆思路解析","uri":"/posts/android%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E6%B7%B7%E6%B7%86%E6%80%9D%E8%B7%AF%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  /* * 启动一个app * QQ的包名：\"com.tencent.mobileqq\" * 支付宝包名： */ public static boolean openAppWithPackageName(Activity activity,String appPackageName){ try{ Intent intent = activity.getPackageManager().getLaunchIntentForPackage(appPackageName); activity.startActivity(intent); return true; }catch(Exception e){ return false; } }   ","description":"","tags":null,"title":"Android通过包名启动任意APP","uri":"/posts/android%E9%80%9A%E8%BF%87%E5%8C%85%E5%90%8D%E5%90%AF%E5%8A%A8%E4%BB%BB%E6%84%8Fapp/"},{"categories":null,"content":"近日需求，要根据渠道修改应用的名称，涉及到了在Manifest中的label属性了，特此记录。\nlabel属性在两个地方都有，Application、Activity，Activity的优先级高于Application，也就是说两者都设置这个标签的话，Activity的值覆盖Application。\n对于app名字，优先级最高的是主Activity的label，其次是Application的label。","description":"","tags":["Android","Application","Activity","label"],"title":"Application的label和Activity的label","uri":"/posts/application%E7%9A%84label%E5%92%8Cactivity%E7%9A%84label/"},{"categories":null,"content":"在项目的开发中，一般都是要封装一个BaseActivity来做一些常用的动作的，下面就是我在项目中用到的一些简单封装。\n1，统计 在BaseActivity的生命周期中调用统计部分的代码，这样可以省去在不同的界面重复编写统计代码的工作。\n1 2 3 4 5 6 7 8 9 10 11  @Override public void onResume() { super.onResume(); AnalyticsHelper.getInstance().onResume(this); } @Override protected void onPause() { super.onPause(); AnalyticsHelper.getInstance().onPause(this); }   2，ProgressDialog 配置一个通用的ProgressDialog是非常有用的，这样在接口请求的时候，直接调用显示，数据返回后调用消失，超级爽！！！\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  //显示ProgressDialog  public ProgressDialog progressDialog; public void showProgressDialog() { if (progressDialog == null) { progressDialog = new ProgressDialog(this); progressDialog.show(); } else { if (!progressDialog.isShowing()) { progressDialog.show(); } } } //隐藏ProgressDialog  public void cancelProgressDialog() { if (progressDialog != null \u0026\u0026 progressDialog.isShowing()) { progressDialog.dismiss(); } }    注意： 要在OnDestory()中调用cancelProgressDialog()一下，防止Activity has leaked window错误。\n 4，全局handler 如果习惯用Thread+Handler来异步操作数据并刷新界面的话，每个界面都定义一遍Handler对象是非常烦人的，所以可以在BaseActivity中定义一个Handler对象，快捷又方便。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { HandleMessage(msg); } }; /** * 复写来处理mHandler发来的消息 * @param msg */ public void HandleMessage(Message msg){}; @Override protected void onDestroy() { mHandler.removeCallbacksAndMessages(null); super.onDestroy(); }    注意： 要在OnDestory()中调用mHandler.removeCallbacksAndMessages()方法，否则会出现handler内存泄露问题。\n 5，全局的观察者模式 未完待续\n","description":"","tags":["Android"],"title":"BaseActivity封装技巧","uri":"/posts/baseactivity%E5%B0%81%E8%A3%85%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"Unsupported Modules Detected:Compilation is not supported for following modules:app. Unfortunately you can't have non-Gradle Java modules and Android-Gradle modules in one project. 如果出现上面的提示，并且as代码检测通不过，但是编译可以通过，一般是由于as升级造成的，升级后打开旧的项目就会出现这样的问题，解决方法是： File -\u003e Invalidate Caches / Restart -\u003e Invalidate Caches \u0026 Restart.\n通过上面的方法as代码检测确实通过了，编译也没问题，但是还是有如题的提示，但是正常使用没问题了，问题保留。\n资料\n","description":"","tags":["Android","bug","gradle"],"title":"Compilation is not supported for following modules:app","uri":"/posts/unsupported-modules-detected/"},{"categories":null,"content":"为了方便，在bash增加了一个路径，放自己写的一些shell脚本。\n但是terminal执行的时候，后面总是有.sh后缀名，感觉怪怪的，现在学习c语言，发现编译后的可执行文件没有后缀名，可以直接执行，所以把shell脚本换成了c语言写的可执行程序，具体替换示例如下：\nactivity.sh 1 2  cd /Users/lipeng/hexo hexo g -d   activity.c 1 2 3 4 5 6  #include \u003cstdlib.h\u003e int main() { system(\"cd /Users/lipeng/hexo \u0026\u0026 hexo g -d\"); }   ","description":"","tags":["c语言"],"title":"c语言学习笔记之执行shell命令","uri":"/posts/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%89%A7%E8%A1%8Cshell%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"This document explains how to use the Data Binding Library to write declarative layouts and minimize the glue code necessary to bind your application logic and layouts.\nThe Data Binding Library offers both flexibility and broad compatibility — it's a support library, so you can use it with all Android platform versions back to Android 2.1 (API level 7+).\nTo use data binding, Android Plugin for Gradle 1.5.0-alpha1 or higher is required.\nBuild Environment To get started with Data Binding, download the library from the Support repository in the Android SDK manager.\nTo configure your app to use data binding, add the dataBinding element to your build.gradle file in the app module.\nUse the following code snippet to configure data binding:\n1 2 3 4 5 6  android { .... dataBinding { enabled = true } }   If you have an app module that depends on a library which uses data binding, your app module must configure data binding in its build.gradle file as well.\nAlso, make sure you are using a compatible version of Android Studio. Android Studio 1.3 and later provides support for data binding as described in Android Studio Support for Data Binding.\nData Binding Layout Files Writing your first data binding expressions Data-binding layout files are slightly different and start with a root tag of layout followed by a data element and a view root element. This view element is what your root would be in a non-binding layout file. A sample file looks like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003cdata\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e \u003cLinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\"/\u003e \u003c/LinearLayout\u003e \u003c/layout\u003e   The user variable within data describes a property that may be used within this layout.\n1  \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e   Expressions within the layout are written in the attribute properties using the “@{}” syntax. Here, the TextView’s text is set to the firstName property of user:\n1 2 3  \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/\u003e   Data Object Let’s assume for now that you have a plain-old Java object (POJO) for User:\n1 2 3 4 5 6 7 8  public class User { public final String firstName; public final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } }   This type of object has data that never changes. It is common in applications to have data that is read once and never changes thereafter. It is also possible to use a JavaBeans objects:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  public class User { private final String firstName; private final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; } }   From the perspective of data binding, these two classes are equivalent. The expression @{user.firstName} used for the TextView’s android:text attribute will access the firstName field in the former class and the getFirstName() method in the latter class. Alternatively, it will also be resolved to firstName() if that method exists.\nBinding Data By default, a Binding class will be generated based on the name of the layout file, converting it to Pascal case and suffixing “Binding” to it. The above layout file was main_activity.xml so the generate class was MainActivityBinding. This class holds all the bindings from the layout properties (e.g. the user variable) to the layout’s Views and knows how to assign values for the binding expressions.The easiest means for creating the bindings is to do it while inflating:\n1 2 3 4 5 6 7  @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User(\"Test\", \"User\"); binding.setUser(user); }   You’re done! Run the application and you’ll see Test User in the UI. Alternatively, you can get the view via:\n1  MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater());   If you are using data binding items inside a ListView or RecyclerView adapter, you may prefer to use:\n1 2 3  ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false); //or ListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false);   Binding Events Events may be bound to handler methods directly, similar to the way android:onClick can be assigned to a method in the Activity. Event attribute names are governed by the name of the listener method with a few exceptions. For example, View.OnLongClickListener has a method onLongClick(), so the attribute for this event is android:onLongClick.\nTo assign an event to its handler, use a normal binding expression, with the value being the method name to call. For example, if your data object has two methods:\n1 2 3 4  public class MyHandlers { public void onClickFriend(View view) { ... } public void onClickEnemy(View view) { ... } }   The binding expression can assign the click listener for a View:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003cdata\u003e \u003cvariable name=\"handlers\" type=\"com.example.Handlers\"/\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e \u003cLinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\" android:onClick=\"@{user.isFriend ? handlers.onClickFriend : handlers.onClickEnemy}\"/\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\" android:onClick=\"@{user.isFriend ? handlers.onClickFriend : handlers.onClickEnemy}\"/\u003e \u003c/LinearLayout\u003e \u003c/layout\u003e   Some specialized click event handlers exist and they need an attribute other than android:onClick to avoid a conflict. The following attributes have been created to avoid such conflicts:\n   Class Listener Setter Attribute     SearchView setOnSearchClickListener(View.OnClickListener) android:onSearchClick   ZoomControls setOnZoomInClickListener(View.OnClickListener) android:onZoomIn   ZoomControls setOnZoomOutClickListener(View.OnClickListener) android:onZoomOut    Layout Details Imports Zero or more import elements may be used inside the data element. These allow easy reference to classes inside your layout file, just like in Java.\n1 2 3  \u003cdata\u003e \u003cimport type=\"android.view.View\"/\u003e \u003c/data\u003e   Now, View may be used within your binding expression:\n1 2 3 4 5  \u003cTextView android:text=\"@{user.lastName}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"@{user.isAdult ? View.VISIBLE : View.GONE}\"/\u003e   When there are class name conflicts, one of the classes may be renamed to an “alias:”\n1 2 3  \u003cimport type=\"android.view.View\"/\u003e \u003cimport type=\"com.example.real.estate.View\" alias=\"Vista\"/\u003e   Now, Vista may be used to reference the com.example.real.estate.View and View may be used to reference android.view.View within the layout file. Imported types may be used as type references in variables and expressions:\n1 2 3 4 5 6  \u003cdata\u003e \u003cimport type=\"com.example.User\"/\u003e \u003cimport type=\"java.util.List\"/\u003e \u003cvariable name=\"user\" type=\"User\"/\u003e \u003cvariable name=\"userList\" type=\"List\u0026lt;User\u003e\"/\u003e \u003c/data\u003e    Note: Android Studio does not yet handle imports so the autocomplete for imported variables may not work in your IDE. Your application will still compile fine and you can work around the IDE issue by using fully qualified names in your variable definitions.\n 1 2 3 4  \u003cTextView android:text=\"@{((User)(user.connection)).lastName}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   Imported types may also be used when referencing static fields and methods in expressions:\n1 2 3 4 5 6 7 8 9  \u003cdata\u003e \u003cimport type=\"com.example.MyStringUtils\"/\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e … \u003cTextView android:text=\"@{MyStringUtils.capitalize(user.lastName)}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   Just as in Java, java.lang.* is imported automatically.\nVariables Any number of variable elements may be used inside the data element. Each variable element describes a property that may be set on the layout to be used in binding expressions within the layout file.\n1 2 3 4 5 6  \u003cdata\u003e \u003cimport type=\"android.graphics.drawable.Drawable\"/\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003cvariable name=\"image\" type=\"Drawable\"/\u003e \u003cvariable name=\"note\" type=\"String\"/\u003e \u003c/data\u003e   The variable types are inspected at compile time, so if a variable implements Observable or is an observable collection, that should be reflected in the type. If the variable is a base class or interface that does not implement the Observable* interface, the variables will not be observed!\nWhen there are different layout files for various configurations (e.g. landscape or portrait), the variables will be combined. There must not be conflicting variable definitions between these layout files.\nThe generated binding class will have a setter and getter for each of the described variables. The variables will take the default Java values until the setter is called — null for reference types, 0 for int, false for boolean, etc.\nA special variable named context is generated for use in binding expressions as needed. The value for context is the Context from the root View's getContext(). The context variable will be overridden by an explicit variable declaration with that name.\nCustom Binding Class Names By default, a Binding class is generated based on the name of the layout file, starting it with upper-case, removing underscores ( _ ) and capitalizing the following letter and then suffixing “Binding”. This class will be placed in a databinding package under the module package. For example, the layout file contact_item.xml will generate ContactItemBinding. If the module package is com.example.my.app, then it will be placed in com.example.my.app.databinding.\nBinding classes may be renamed or placed in different packages by adjusting the class attribute of the data element. For example:\n1 2 3  \u003cdata class=\"ContactItem\"\u003e ... \u003c/data\u003e   This generates the binding class as ContactItem in the databinding package in the module package. If the class should be generated in a different package within the module package, it may be prefixed with “.”:\n1 2 3  \u003cdata class=\".ContactItem\"\u003e ... \u003c/data\u003e   In this case, ContactItem is generated in the module package directly. Any package may be used if the full package is provided:\n1 2 3  \u003cdata class=\"com.example.ContactItem\"\u003e ... \u003c/data\u003e   Includes Variables may be passed into an included layout's binding from the containing layout by using the application namespace and the variable name in an attribute:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:bind=\"http://schemas.android.com/apk/res-auto\"\u003e \u003cdata\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e \u003cLinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cinclude layout=\"@layout/name\" bind:user=\"@{user}\"/\u003e \u003cinclude layout=\"@layout/contact\" bind:user=\"@{user}\"/\u003e \u003c/LinearLayout\u003e \u003c/layout\u003e   Here, there must be a user variable in both the name.xml and contact.xml layout files.\nData binding does not support include as a direct child of a merge element. For example, the following layout is not supported:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:bind=\"http://schemas.android.com/apk/res-auto\"\u003e \u003cdata\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e \u003cmerge\u003e \u003cinclude layout=\"@layout/name\" bind:user=\"@{user}\"/\u003e \u003cinclude layout=\"@layout/contact\" bind:user=\"@{user}\"/\u003e \u003c/merge\u003e \u003c/layout\u003e   Expression Language Common Features The expression language looks a lot like a Java expression. These are the same:\n Mathematical + - / * % String concatenation + Logical \u0026\u0026 || Binary \u0026 | ^ Unary + - ! ~ Shift \u003e\u003e \u003e\u003e\u003e \u003c\u003c Comparison == \u003e \u003c \u003e= \u003c= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?:  Examples:\n1 2 3  android:text=\"@{String.valueOf(index + 1)}\" android:visibility=\"@{age \u0026lt; 13 ? View.GONE : View.VISIBLE}\" android:transitionName='@{\"image_\" + id}'   Missing Operations A few operations are missing from the expression syntax that you can use in Java.\n this super new Explicit generic invocation  Null Coalescing Operator The null coalescing operator (??) chooses the left operand if it is not null or the right if it is null.\n1  android:text=\"@{user.displayName ?? user.lastName}\"   This is functionally equivalent to:\n1  android:text=\"@{user.displayName != null ? user.displayName : user.lastName}\"   Property Reference The first was already discussed in the Writing your first data binding expressions above: short form JavaBean references. When an expression references a property on a class, it uses the same format for fields, getters, and ObservableFields.\n1  android:text=\"@{user.lastName}\"   Avoiding NullPointerException Generated data binding code automatically checks for nulls and avoid null pointer exceptions. For example, in the expression @{user.name}, if user is null, user.name will be assigned its default value (null). If you were referencing user.age, where age is an int, then it would default to 0.\nCollections Common collections: arrays, lists, sparse lists, and maps, may be accessed using the [] operator for convenience.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u003cdata\u003e \u003cimport type=\"android.util.SparseArray\"/\u003e \u003cimport type=\"java.util.Map\"/\u003e \u003cimport type=\"java.util.List\"/\u003e \u003cvariable name=\"list\" type=\"List\u0026lt;String\u003e\"/\u003e \u003cvariable name=\"sparse\" type=\"SparseArray\u0026lt;String\u003e\"/\u003e \u003cvariable name=\"map\" type=\"Map\u0026lt;String, String\u003e\"/\u003e \u003cvariable name=\"index\" type=\"int\"/\u003e \u003cvariable name=\"key\" type=\"String\"/\u003e \u003c/data\u003e … android:text=\"@{list[index]}\" … android:text=\"@{sparse[index]}\" … android:text=\"@{map[key]}\"   String Literals When using single quotes around the attribute value, it is easy to use double quotes in the expression:\n1  android:text='@{map[\"firstName\"]}'   It is also possible to use double quotes to surround the attribute value. When doing so, String literals should either use the \" or back quote (`).\n1 2  android:text=\"@{map[`firstName`}\" android:text=\"@{map[\u0026quot;firstName\u0026quot;]}\"   Resources It is possible to access resources as part of expressions using the normal syntax:\n1  android:padding=\"@{large? @dimen/largePadding : @dimen/smallPadding}\"   Format strings and plurals may be evaluated by providing parameters:\n1 2  android:text=\"@{@string/nameFormat(firstName, lastName)}\" android:text=\"@{@plurals/banana(bananaCount)}\"   When a plural takes multiple parameters, all parameters should be passed:\n1 2 3  Have an orange Have %d oranges android:text=\"@{@plurals/orange(orangeCount, orangeCount)}\"   Some resources require explicit type evaluation.\n   Type Normal Reference Expression Reference     String[] @array @stringArray   int[] @array @intArray   TypedArray @array @typedArray   Animator @animator @animator   StateListAnimator @animator @stateListAnimator   color int @color @color   ColorStateList @color @colorStateList    Data Objects Any plain old Java object (POJO) may be used for data binding, but modifying a POJO will not cause the UI to update. The real power of data binding can be used by giving your data objects the ability to notify when data changes. There are three different data change notification mechanisms, Observable objects, observable fields, and observable collections.\nWhen one of these observable data object is bound to the UI and a property of the data object changes, the UI will be updated automatically.\nObservable Objects A class implementing the Observable interface will allow the binding to attach a single listener to a bound object to listen for changes of all properties on that object.\nThe Observable interface has a mechanism to add and remove listeners, but notifying is up to the developer. To make development easier, a base class, BaseObservable, was created to implement the listener registration mechanism. The data class implementer is still responsible for notifying when the properties change. This is done by assigning a Bindable annotation to the getter and notifying in the setter.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  private static class User extends BaseObservable { private String firstName; private String lastName; @Bindable public String getFirstName() { return this.firstName; } @Bindable public String getLastName() { return this.lastName; } public void setFirstName(String firstName) { this.firstName = firstName; notifyPropertyChanged(BR.firstName); } public void setLastName(String lastName) { this.lastName = lastName; notifyPropertyChanged(BR.lastName); } }   The Bindable annotation generates an entry in the BR class file during compilation. The BR class file will be generated in the module package. If the base class for data classes cannot be changed, the Observable interface may be implemented using the convenient PropertyChangeRegistry to store and notify listeners efficiently.\nObservableFields A little work is involved in creating Observable classes, so developers who want to save time or have few properties may use ObservableField and its siblings ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, and ObservableParcelable. ObservableFields are self-contained observable objects that have a single field. The primitive versions avoid boxing and unboxing during access operations. To use, create a public final field in the data class:\n1 2 3 4 5 6 7  private static class User { public final ObservableField\u003cString\u003e firstName = new ObservableField\u003c\u003e(); public final ObservableField\u003cString\u003e lastName = new ObservableField\u003c\u003e(); public final ObservableInt age = new ObservableInt(); }   That's it! To access the value, use the set and get accessor methods:\n1 2  user.firstName.set(\"Google\"); int age = user.age.get();   Observable Collections Some applications use more dynamic structures to hold data. Observable collections allow keyed access to these data objects. ObservableArrayMap is useful when the key is a reference type, such as String.\n1 2 3 4  ObservableArrayMap\u003cString, Object\u003e user = new ObservableArrayMap\u003c\u003e(); user.put(\"firstName\", \"Google\"); user.put(\"lastName\", \"Inc.\"); user.put(\"age\", 17);   In the layout, the map may be accessed through the String keys:\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u003cdata\u003e \u003cimport type=\"android.databinding.ObservableMap\"/\u003e \u003cvariable name=\"user\" type=\"ObservableMap\u0026lt;String, Object\u003e\"/\u003e \u003c/data\u003e … \u003cTextView android:text='@{user[\"lastName\"]}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e \u003cTextView android:text='@{String.valueOf(1 + (Integer)user[\"age\"])}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   ObservableArrayList is useful when the key is an integer:\n1 2 3 4  ObservableArrayList\u003cObject\u003e user = new ObservableArrayList\u003c\u003e(); user.add(\"Google\"); user.add(\"Inc.\"); user.add(17);   In the layout, the list may be accessed through the indices:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  \u003cdata\u003e \u003cimport type=\"android.databinding.ObservableList\"/\u003e \u003cimport type=\"com.example.my.app.Fields\"/\u003e \u003cvariable name=\"user\" type=\"ObservableList\u0026lt;Object\u003e\"/\u003e \u003c/data\u003e … \u003cTextView android:text='@{user[Fields.LAST_NAME]}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e \u003cTextView android:text='@{String.valueOf(1 + (Integer)user[Fields.AGE])}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   Generated Binding The generated binding class links the layout variables with the Views within the layout. As discussed earlier, the name and package of the Binding may be customized. The Generated binding classes all extend ViewDataBinding.\nCreating The binding should be created soon after inflation to ensure that the View hierarchy is not disturbed prior to binding to the Views with expressions within the layout. There are a few ways to bind to a layout. The most common is to use the static methods on the Binding class.The inflate method inflates the View hierarchy and binds to it all it one step. There is a simpler version that only takes a LayoutInflater and one that takes a ViewGroup as well:\n1 2  MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater); MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false);   If the layout was inflated using a different mechanism, it may be bound separately:\n1  MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot);   Sometimes the binding cannot be known in advance. In such cases, the binding can be created using the DataBindingUtil class:\n1 2 3  ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent); ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId);   Views With IDs A public final field will be generated for each View with an ID in the layout. The binding does a single pass on the View hierarchy, extracting the Views with IDs. This mechanism can be faster than calling findViewById for several Views. For example:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003cdata\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e \u003cLinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\" android:id=\"@+id/firstName\"/\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\" android:id=\"@+id/lastName\"/\u003e \u003c/LinearLayout\u003e \u003c/layout\u003e   Will generate a binding class with:\n1 2  public final TextView firstName; public final TextView lastName;   IDs are not nearly as necessary as without data binding, but there are still some instances where access to Views are still necessary from code.\nVariables Each variable will be given accessor methods.\n1 2 3 4 5 6  \u003cdata\u003e \u003cimport type=\"android.graphics.drawable.Drawable\"/\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003cvariable name=\"image\" type=\"Drawable\"/\u003e \u003cvariable name=\"note\" type=\"String\"/\u003e \u003c/data\u003e   will generate setters and getters in the binding:\n1 2 3 4 5 6  public abstract com.example.User getUser(); public abstract void setUser(com.example.User user); public abstract Drawable getImage(); public abstract void setImage(Drawable image); public abstract String getNote(); public abstract void setNote(String note);   ViewStubs ViewStubs are a little different from normal Views. They start off invisible and when they either are made visible or are explicitly told to inflate, they replace themselves in the layout by inflating another layout.\nBecause the ViewStub essentially disappears from the View hierarchy, the View in the binding object must also disappear to allow collection. Because the Views are final, a ViewStubProxy object takes the place of the ViewStub, giving the developer access to the ViewStub when it exists and also access to the inflated View hierarchy when the ViewStub has been inflated.\nWhen inflating another layout, a binding must be established for the new layout. Therefore, the ViewStubProxy must listen to the ViewStub's ViewStub.OnInflateListener and establish the binding at that time. Since only one can exist, the ViewStubProxy allows the developer to set an OnInflateListener on it that it will call after establishing the binding.\nAdvanced Binding Dynamic Variables At times, the specific binding class won't be known. For example, a RecyclerView.Adapter operating against arbitrary layouts won't know the specific binding class. It still must assign the binding value during the onBindViewHolder(VH, int).\nIn this example, all layouts that the RecyclerView binds to have an \"item\" variable. The BindingHolder has a getBinding method returning the ViewDataBinding base.\n1 2 3 4 5  public void onBindViewHolder(BindingHolder holder, int position) { final T item = mItems.get(position); holder.getBinding().setVariable(BR.item, item); holder.getBinding().executePendingBindings(); }   Immediate Binding When a variable or observable changes, the binding will be scheduled to change before the next frame. There are times, however, when binding must be executed immediately. To force execution, use the executePendingBindings() method.\nBackground Thread You can change your data model in a background thread as long as it is not a collection. Data binding will localize each variable / field while evaluating to avoid any concurrency issues.\nAttribute Setters Whenever a bound value changes, the generated binding class must call a setter method on the View with the binding expression. The data binding framework has ways to customize which method to call to set the value.\nAutomatic Setters For an attribute, data binding tries to find the method setAttribute. The namespace for the attribute does not matter, only the attribute name itself. For example, an expression associated with TextView's attribute android:text will look for a setText(String). If the expression returns an int, data binding will search for a setText(int) method. Be careful to have the expression return the correct type, casting if necessary. Note that data binding will work even if no attribute exists with the given name. You can then easily \"create\" attributes for any setter by using data binding. For example, support DrawerLayout doesn't have any attributes, but plenty of setters. You can use the automatic setters to use one of these.\n1 2 3 4 5  \u003candroid.support.v4.widget.DrawerLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:scrimColor=\"@{@color/scrim}\" app:drawerListener=\"@{fragment.drawerListener}\"/\u003e   Renamed Setters Some attributes have setters that don't match by name. For these methods, an attribute may be associated with the setter through BindingMethods annotation. This must be associated with a class and contains BindingMethod annotations, one for each renamed method. For example, the android:tint attribute is really associated with setImageTintList(ColorStateList), not setTint.\n1 2 3 4 5  @BindingMethods({ @BindingMethod(type = \"android.widget.ImageView\", attribute = \"android:tint\", method = \"setImageTintList\"), })   It is unlikely that developers will need to rename setters; the android framework attributes have already been implemented.\nCustom Setters Some attributes need custom binding logic. For example, there is no associated setter for the android:paddingLeft attribute. Instead, setPadding(left, top, right, bottom) exists. A static binding adapter method with the BindingAdapter annotation allows the developer to customize how a setter for an attribute is called.\nThe android attributes have already had BindingAdapters created. For example, here is the one for paddingLeft:\n1 2 3 4 5 6 7  @BindingAdapter(\"android:paddingLeft\") public static void setPaddingLeft(View view, int padding) { view.setPadding(padding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); }   Binding adapters are useful for other types of customization. For example, a custom loader can be called off-thread to load an image.\nDeveloper-created binding adapters will override the data binding default adapters when there is a conflict.\nYou can also have adapters that receive multiple parameters.\n1 2 3 4  @BindingAdapter({\"bind:imageUrl\", \"bind:error\"}) public static void loadImage(ImageView view, String url, Drawable error) { Picasso.with(view.getContext()).load(url).error(error).into(view); }   1 2  \u003cImageView app:imageUrl=“@{venue.imageUrl}” app:error=“@{@drawable/venueError}”/\u003e   This adapter will be called if both imageUrl and error are used for an ImageView and imageUrl is a string and error is a drawable.\n Custom namespaces are ignored during matching. You can also write adapters for android namespace.  Binding adapter methods may optionally take the old values in their handlers. A method taking old and new values should have all old values for the attributes come first, followed by the new values:\n1 2 3 4 5 6 7 8 9  @BindingAdapter(\"android:paddingLeft\") public static void setPaddingLeft(View view, int oldPadding, int newPadding) { if (oldPadding != newPadding) { view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); } }   Event handlers may only be used with interfaces or abstract classes with one abstract method. For example:\n1 2 3 4 5 6 7 8 9 10 11 12  @BindingAdapter(\"android:onLayoutChange\") public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue, View.OnLayoutChangeListener newValue) { if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.HONEYCOMB) { if (oldValue != null) { view.removeOnLayoutChangeListener(oldValue); } if (newValue != null) { view.addOnLayoutChangeListener(newValue); } } }   When a listener has multiple methods, it must be split into multiple listeners. For example, View.OnAttachStateChangeListener has two methods: onViewAttachedToWindow() and onViewDetachedFromWindow(). We must then create two interfaces to differentiate the attributes and handlers for them.\n1 2 3 4 5 6 7 8  @TargetApi(VERSION_CODES.HONEYCOMB_MR1) public interface OnViewDetachedFromWindow { void onViewDetachedFromWindow(View v); } @TargetApi(VERSION_CODES.HONEYCOMB_MR1) public interface OnViewAttachedToWindow { void onViewAttachedToWindow(View v); }   Because changing one listener will also affect the other, we must have three different binding adapters, one for each attribute and one for both, should they both be set.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44  @BindingAdapter(\"android:onViewAttachedToWindow\") public static void setListener(View view, OnViewAttachedToWindow attached) { setListener(view, null, attached); } @BindingAdapter(\"android:onViewDetachedFromWindow\") public static void setListener(View view, OnViewDetachedFromWindow detached) { setListener(view, detached, null); } @BindingAdapter({\"android:onViewDetachedFromWindow\", \"android:onViewAttachedToWindow\"}) public static void setListener(View view, final OnViewDetachedFromWindow detach, final OnViewAttachedToWindow attach) { if (VERSION.SDK_INT \u003e= VERSION_CODES.HONEYCOMB_MR1) { final OnAttachStateChangeListener newListener; if (detach == null \u0026\u0026 attach == null) { newListener = null; } else { newListener = new OnAttachStateChangeListener() { @Override public void onViewAttachedToWindow(View v) { if (attach != null) { attach.onViewAttachedToWindow(v); } } @Override public void onViewDetachedFromWindow(View v) { if (detach != null) { detach.onViewDetachedFromWindow(v); } } }; } final OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener); if (oldListener != null) { view.removeOnAttachStateChangeListener(oldListener); } if (newListener != null) { view.addOnAttachStateChangeListener(newListener); } } }   The above example is slightly more complicated than normal because View uses add and remove for the listener instead of a set method for View.OnAttachStateChangeListener. The android.databinding.adapters.ListenerUtil class helps keep track of the previous listeners so that they may be removed in the Binding Adaper.\nBy annotating the interfaces OnViewDetachedFromWindow and OnViewAttachedToWindow with @TargetApi(VERSION_CODES.HONEYCOMB_MR1), the data binding code generator knows that the listener should only be generated when running on Honeycomb MR1 and new devices, the same version supported by addOnAttachStateChangeListener(View.OnAttachStateChangeListener).\nConverters Object Conversions When an Object is returned from a binding expression, a setter will be chosen from the automatic, renamed, and custom setters. The Object will be cast to a parameter type of the chosen setter.\nThis is a convenience for those using ObservableMaps to hold data. for example:\n1 2 3 4  \u003cTextView android:text='@{userMap[\"lastName\"]}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   The userMap returns an Object and that Object will be automatically cast to parameter type found in the setter setText(CharSequence). When there may be confusion about the parameter type, the developer will need to cast in the expression.\nCustom Conversions Sometimes conversions should be automatic between specific types. For example, when setting the background:\n1 2 3 4  \u003cView android:background=\"@{isError ? @color/red : @color/white}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   Here, the background takes a Drawable, but the color is an integer. Whenever a Drawable is expected and an integer is returned, the int should be converted to a ColorDrawable. This conversion is done using a static method with a BindingConversion annotation:\n1 2 3 4  @BindingConversion public static ColorDrawable convertColorToDrawable(int color) { return new ColorDrawable(color); }   Note that conversions only happen at the setter level, so it is not allowed to mix types like this:\n1 2 3 4  \u003cView android:background=\"@{isError ? @drawable/error : @color/white}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/\u003e   Android Studio Support for Data Binding Android Studio supports many of the code editing features for data binding code. For example, it supports the following features for data binding expressions:\n Syntax highlighting Flagging of expression language syntax errors XML code completion References, including navigation (such as navigate to a declaration) and quick documentation   Note: Arrays and a generic type, such as the Observable class, might display errors when there are no errors.\n The Preview pane displays default values for data binding expressions if provided. In the following example excerpt of an element from a layout XML file, the Preview pane displays the PLACEHOLDER default text value in the TextView.\n1 2 3  \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName, default=PLACEHOLDER}\"/\u003e   If you need to display a default value during the design phase of your project, you can also use tools attributes instead of default expression values, as described in Designtime Layout Attributes.\n转自：https://developer.android.com/topic/libraries/data-binding/index.html#attribute_setters\n","description":"","tags":["Data Binding","Android","转载"],"title":"Data Binding Library官方文档","uri":"/posts/data-binding-library/"},{"categories":null,"content":" 本文档讲解了怎样使用Data Binding库来声明布局，并且减少应用程序逻辑和布局所需的耦合代码，这在开发中是非常必要的。\n Data Binding库是一个引用库，兼容性非常好，适配了Android 2.1以上（API level 7+）的所有版本。\n 使用Data Binding的话，Gradle 版本需要在1.5.0-alpha1及以上。\n一、编译环境 使用Data Binding之前，需要先在Android SDK Manager的中下载Data Binding库。\n然后在build.gradle中加入dataBinding的配置。\n用下面的代码配置Data Binding:\n1 2 3 4 5 6  android { .... dataBinding { enabled = true } }   如果你的Module中已经有一个library引用了Data Binding，你的主项目的build.gradle中仍然需要配置一下。\n然后确认一下Android Studio版本是否支持，Android Studio 1.3及以上都支持data binding，描述文档。\n二、Data Binding 布局文件 马上来编写你的第一个data binding程序吧！ data binding的布局文件和原先xml写的布局文件有略微不同，首先要在根布局下面绑定一个data元素，这个视图元素是在非绑定布局文件中的基本元素(好拗口~)。例子如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003cdata\u003e \u003cvariable name=\"user\" type=\"com.example.User\"/\u003e \u003c/data\u003e \u003cLinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/\u003e \u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\"/\u003e \u003c/LinearLayout\u003e \u003c/layout\u003e   user变量是在数据中描述了，可以用在布局文件中。\n\u003cvariable name=\"user\" type=\"com.example.User\"/\u003e 在布局的属性中的语法是\"@{}\"，然后这个TextView的text属性就被user的fitstName字段赋值了。\n\u003cTextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/\u003e 三、数据结构 现在我们假定，你有一个纯java对象（POJO），User：\npublic class User { public final String firstName; public final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 这个类型的对象含有永不变化的数据，在程序中，一次读取，后来从不改变的现象，在程序中很常见，另外也可以使用一个javabean对象：\npublic class User { private final String firstName; private final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; } } 从data binding的角度出发，这两个类是相当的，在给一个android:text属性用@{user.firstName}这种写法赋值的时候，在前一个类里面被理解为firstName字段，在后一个类里面被理解为getFirstName()方法，或者也有可能被理解为firstName()方法，如果存在的话。\n绑定数据 一个数据绑定的类默认会依据layout文件的名字来创建，\n(未完待续)\n","description":"","tags":["Android","Data Binding","翻译"],"title":"Data Binding文档翻译","uri":"/posts/data_binding%E6%96%87%E6%A1%A3/"},{"categories":null,"content":"最近做了不少输入框，有储蓄卡卡号、信用卡卡号、验证码、用户名等，需要对每个输入框都做不同的输入限制，下面记录了常用的几种输入限制方式，以供以后参考。\n方法一：InputType InputType属性可以限制输入框需要显示何种键盘模式，可以输入哪些字符，下面是各个参数对应的类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  android:inputType=\"none\"--输入普通字符 android:inputType=\"text\"--输入普通字符 android:inputType=\"textCapCharacters\"--输入普通字符 android:inputType=\"textCapWords\"--单词首字母大小 android:inputType=\"textCapSentences\"--仅第一个字母大小 android:inputType=\"textAutoCorrect\"--前两个自动完成 android:inputType=\"textAutoComplete\"--前两个自动完成 android:inputType=\"textMultiLine\"--多行输入 android:inputType=\"textImeMultiLine\"--输入法多行（不一定支持） android:inputType=\"textNoSuggestions\"--不提示 android:inputType=\"textUri\"--URI格式 android:inputType=\"textEmailAddress\"--电子邮件地址格式 android:inputType=\"textEmailSubject\"--邮件主题格式 android:inputType=\"textShortMessage\"--短消息格式 android:inputType=\"textLongMessage\"--长消息格式 android:inputType=\"textPersonName\"--人名格式 android:inputType=\"textPostalAddress\"--邮政格式 android:inputType=\"textPassword\"--密码格式 android:inputType=\"textVisiblePassword\"--密码可见格式 android:inputType=\"textWebEditText\"--作为网页表单的文本格式 android:inputType=\"textFilter\"--文本筛选格式 android:inputType=\"textPhonetic\"--拼音输入格式 android:inputType=\"number\"--数字格式 数字键盘 android:inputType=\"numberSigned\"--有符号数字格式 数字键盘 android:inputType=\"numberDecimal\"--可以带小数点的浮点格式 数字键盘 android:inputType=\"phone\"--拨号键盘 android:inputType=\"datetime\" android:inputType=\"date\"--日期键盘 android:inputType=\"time\"--时间键盘   摘自android:inputType参数类型说明\n方法二：digits 使用方法： 1.在xml文件中设置digits参数：\n1  android:digits=\"0123456789 \"   通过xml文件设置digits的参数来控制这个EditText可以输入那些字符，但是无法控制键盘模式。 2.代码中动态设置KeyListener：\n1 2 3 4 5 6 7 8 9 10 11 12  nameEdi.setKeyListener(new NumberKeyListener() { @Override protected char[] getAcceptedChars() { char[] numberChars = {'1','2','3','4','5','6','7','8','9','0',' '}; return numberChars; } @Override public int getInputType() { return InputType.TYPE_CLASS_NUMBER; } });   这种方式可以同时设置InputType，而且在代码里面动态控制，更加灵活。\n EditText继承自TextView，同样这两个属性也是继承自TextView，所以InputType和digits同样可以用在TextView和所有继承自TextView的控件上面。\n","description":"","tags":["Android","EditText"],"title":"EditText的输入限制(InputType、digits)","uri":"/posts/edittext%E7%9A%84%E8%BE%93%E5%85%A5%E9%99%90%E5%88%B6inputtypedigits/"},{"categories":null,"content":"解决H5调用APP原生拍照的功能实现和兼容性问题。\n一句话总结： Android的话，自定义\u003cinput\u003e标签的accept属性，触发后原生做拍照操作，完成后把图片的Uri返给\u003cinput\u003e标签即可；\niOS的话，JSBridge即可。详情见[JS与OC互调，JS打开系统相机，JS获取iOS系统图片，iOS中JS调OC]1\n 重点：\n为了安全，H5不能通过真实路径访问手机的任何资源，解决方式是Android端用\u003cinput\u003e标签的沙盒机制；iOS的每个APP默认一个沙盒，WebView里面的H5可以访问到这个沙盒里面的资源，所以iOS获取到图片后保存到自己的沙盒里，沙盒路径用JSBridge扔给H5。\n","description":"","tags":null,"title":"H5调用原生APP拍照","uri":"/posts/h5%E8%B0%83%E7%94%A8%E5%8E%9F%E7%94%9Fapp%E6%8B%8D%E7%85%A7/"},{"categories":null,"content":"1，生成本地公钥 输入一下命令（邮箱修改成自己的 ^_^ ）：\n1  ssh-keygen -t rsa -f ~/.ssh/loanByWeex.osc -C \"your_email@youremail.com\"   然后按两次回车。\n 说明：\n-t后面的参数是数字签名算法方式，在这里一般使用dsa或者rsa方式，默认dsa(但是我个人习惯使用rsa方式^_^)；\n-f后面的参数是保存密钥的文件，可以根据项目名字和平台来自定义；\n命令执行成功后，会生成两个文件，一个密钥和一个公钥，密钥的名字是loanByWeex.osc，公钥的名字是loanByWeex.osc.pub，这两个文件是对应的，密钥放在本地，公钥用于绑定git服务器。\n 2，将公钥上传到OSChina平台 查看一下刚才生成的的公钥：\n1  cat ~/.ssh/loanByWeex.osc.pub   我的公钥截图如下：\n复制公钥内容到OSChina的SSH公钥添加界面：\n添加成功后，即可在自己的电脑上使·git clone命令克隆咱们的代码仓库了~O(∩_∩)O~\n","description":"","tags":["git"],"title":"OSChina绑定公钥—MAC","uri":"/posts/oschina%E7%BB%91%E5%AE%9A%E5%85%AC%E9%92%A5/"},{"categories":null,"content":"大家最初学习NDK开发的时候，写过的第一个.c文件内容应该都非常类似，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  #include \"hello-jni.h\"#include \u003cjni.h\u003e#include \u003cstdio.h\u003e#include \u003candroid/log.h\u003e#define TAG \"hello-jni\" // 这个是自定义的LOG的标识 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__)// 定义LOGD类型 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__)// 定义LOGI类型 #define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__)// 定义LOGW类型 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__)// 定义LOGE类型 #define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__)// 定义LOGF类型  jstring Java_jnitest_xhmsmd_top_hello_1jni_MainActivity_getKey(JNIEnv* env, jobject thiz) { LOGD(\"hello,jni\"); return (*env)-\u003eNewStringUTF(env,\"hello jni\"); }    这个.c文件的代码看起来是没有任何问题的，但是大多数人，一运行，就会爆出如下错误：\n1 2 3  /Users/lipeng/android_workspace/hello_jni/app/src/main/jni/hello-jni.c Error:(20) undefined reference to `__android_log_print' Error:error: ld returned 1 exit status   网上查到的资料绝大部分都是让在Android.mk文件中增加LOCAL_LDLIBS := -lm -llog类似的解决方案，而且很多人也确实用这种方式解决了这个问题，但是我用了这个方式，并没有效果。\n最终在StackOverFlow查到了另外一种解决方法：\n1 2 3 4  ndk { moduleName \"hello-jni\" ldLibs \"log\" }   这种方法解决了我这边的问题，看代码解决方式是引入log库，但是.c文件中已经引入了android/log.h，不知道为什么还要在Android.mk文件或者gradle配置文件中再引入的lib。\n","description":"","tags":["Android","NDK","jni"],"title":"undefined reference to `__android_log_print'解决方法","uri":"/posts/undefined-reference-to-__android_log_print%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"View的事件分发机制是非常核心的一个知识点，可以解决滑动冲突等很多棘手的问题，所以在这里梳理一下。 1. View的事件分发机制 2. 一些Listener的优先级\n\n1. View的事件分发机制 1）处理触摸事件会涉及到的三个类：Activity、ViewGroup、View，这三个类之间的事件传递顺序是： Activity--\u003eViewGroup(rootView)--\u003eViewGroup--\u003e . . . --\u003eView 2）三个类各自的事件分发方法： Activity ：dispatchTouchEvent()、onTouchEvent()\n Activity没有onInterceptTouchEvent()方法，无法拦截触摸事件，但是我们可以通过重写dispatchTouchEvent()方法进行整个Activity层面的触摸事件拦截。\n View ： dispatchTouchEvent()、onTouchEvent()\n View也没有onInterceptTouchEvent()方法，因为如果不是ViewGroup的话已经是最后一层了，所以不需要拦截。\n ViewGroup ： dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent()\n ViewGroup继承自View，实现了onInterceptTouchEvent()方法，默认返回false，也就是ViewGroup默认不拦截任何触摸事件。\n 事件分发三方法的关系 在点击屏幕的时候最先获取到点击事件的是当前的Activity，Activity的事件分发最终是调用所属的Window进行分发的，Window将事件分发给根ViewGroup，这样就开始了经典的事件分发流程。 下面的伪代码精确的表现出了事件分发的三个方法之间的关系：\npublic boolean dispatchTouchEvent(MotionEvent e){ boolean consume = false; if(onInterceptTouchEvent(e)){ consume = onTouchEvent(e); }else{ if(hasChild()){ consume = child.dispathTouchEvent(e); }else{ consume = onTouchEvent(e); } } return consume; } 配合下图食用。  由于最底层的View没有onInterceptTouchEvent()方法，所以View的dispatchTouchEvent()方法中会直接执行onTouchEvent()方法，默认返回值false，如果这个View对象没有重写ontouchEvent()方法，也没有设置一些点击事件，那么这个View的dispatchTouchEvent()方法就会返回false。\n \n2. 一些Listener的优先级 上面事件分发之后总归是要有View的事件来处理这个操作的，那么View的处理事件是在哪里调用的呢？\n答：假如view获得了触摸事件，要处理这个事件，调用的顺序可以在View源码的dispatchTouchEvent()方法里面看出：\n public boolean dispatchTouchEvent(MotionEvent event) { ... if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null \u0026\u0026 li.mOnTouchListener != null \u0026\u0026 (mViewFlags \u0026 ENABLED_MASK) == ENABLED \u0026\u0026 li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result \u0026\u0026 onTouchEvent(event)) { result = true; } } ... return result; } 先判断是否设置了mOntouchListener，如果设置了，执行mOntouchListener.ouTouch()方法，如果返回true，则不执行下面的onTouchEvent()了，也就是说mOntouchListener的优先级高于onTouchEvent()。\n咦，不对啊，我的onClickListener()跑哪里去了？\n通过查看View的源码我们发现，onClickListener()方法的调用是在一个performClick()的方法里面，这个方法在onTouchEvent()的MotionEvent.ACTION_UP下调用了，所以onClickListener()方法的优先级最低。\n结论：onTouchListener() \u003e onTouchEvent() \u003e onClickListener()  注意：setOnClickListener()方法会调用setClickable(true)方法，会覆盖掉原来的Clickable属性。\n","description":"","tags":["Android","笔记","Android开发艺术探索","事件分发"],"title":"View的事件分发机制","uri":"/posts/view%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"在工作中很多地方都使用到了WebView，尤其是现在这个hybird app盛行的时代，所以WebView的优化也显得尤为重要了。\n目录 性能优化 界面优化 业务逻辑优化 bug总结 相关扩展\n正文 \n一 性能优化 1. 图片加载逻辑 WebView下载完html代码后开始解析，过程中发现外部的js、css和图片，会异步发出网络请求，网络状况不好的情况下，会影响js和css文件加载完的时间，造成页面空白loading过久，解决方法是先不加载图片，等页面装载完毕，再加载图片。 在WebView初始化时设置如下代码：\n1 2 3 4 5 6 7  public void int () { if(Build.VERSION.SDK_INT \u003e= 19) { webView.getSettings().setLoadsImagesAutomatically(true); } else { webView.getSettings().setLoadsImagesAutomatically(false); } }   同时在WebView的WebViewClient实例中的onPageFinished()方法添加如下代码：\n1 2 3 4 5 6  @Override public void onPageFinished(WebView view, String url) { if(!webView.getSettings().getLoadsImagesAutomatically()) { webView.getSettings().setLoadsImagesAutomatically(true); } }   从上面的代码，可以看出我们对系统API在19以上的版本作了兼容。因为4.4以上系统在onPageFinished时再恢复图片加载时,如果存在多张图片引用的是相同的src时，会只有一个image标签得到加载，因而对于这样的系统我们就先直接加载。(博主暂时没有测试更高版本)\n2. 远程网页需访问本地资源 WebView加载的网页访问本地资源可以节省Web的加载时间，实现的方法有两种。 第一种： 重写shouldInterceptRequest(WebView view,String url)方法，监听url，如果url里加载的是本地有的图片，就直接返回图片资源，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  @Override public WebResourceResponse shouldInterceptRequest(WebView view,String url) { try { if (url.endsWith(\"icon.png\")) { InputStream is = appRm.getInputStream(R.drawable.icon); WebResourceResponse response = new WebResourceResponse(\"image/png\", \"utf-8\", is); return response; } else if (url.endsWith(\"jquery.min.js\")) { InputStream is = appRm.getInputStream(R.raw.jquery_min_js); WebResourceResponse response = new WebResourceResponse(\"text/javascript\", \"utf-8\", is); return response; } } catch (IOException e) { e.printStackTrace(); } return super.shouldInterceptRequest(view, url); }   第二种： 主动发网络请求获取html代码，然后WebView调用loadDataWithBaseURL()方法，把html代码穿进去，这样就可以在html代码里使用file:///android_asset/xxx.png的链接来引用包里面assets下的资源了。示例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  private void loadWithAccessLocal(final String htmlUrl) { new Thread(new Runnable() { public void run() { try { final String htmlStr = NetService.fetchHtml(htmlUrl); if (htmlStr != null) { TaskExecutor.runTaskOnUiThread(new Runnable() { @Override public void run() { loadDataWithBaseURL(htmlUrl, htmlStr, \"text/html\", \"UTF-8\", \"\"); } }); return; } } catch (Exception e) { Log.e(\"Exception:\" + e.getMessage()); } TaskExecutor.runTaskOnUiThread(new Runnable() { @Override public void run() { onPageLoadedError(-1, \"fetch html failed\"); } }); } }).start(); }   3. WebView缓存 开启WebView的缓存功能可以减少对服务器资源的请求，一般使用默认缓存策略就可以了。\n1 2 3 4  //设置 缓存模式 webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT); // 开启 DOM storage API 功能 webView.getSettings().setDomStorageEnabled(true);   4. 使用小技巧 展示webview的activity可以另开一个进程，这样就能和我们app的主进程分开了，即使webview产生了oom崩溃等问题也不会影响到主程序，如何实现呢，其实很简单，在androidmanifest.xml的activity标签里加上android:process=\"packagename.web\"就可以了。\n\n二 界面优化 1. 自定义error界面 当WebView加载页面出错时（一般为404 NOT FOUND），安卓WebView会默认显示一个卖萌的出错界面。但我们怎么能让用户发现原来我使用的是网页应用呢，我们期望的是用户在网页上得到是如原生般应用的体验，那就先要从干掉这个默认出错页面开始。当WebView加载出错时，我们会在WebViewClient实例中的onReceivedError()方法接收到错误，我们就在这里做些手脚：\n1 2 3 4 5 6 7 8  @Override public void onReceivedError (WebView view, int errorCode, String description, String failingUrl) { super.onReceivedError(view, errorCode, description, failingUrl); //清除掉默认错误页内容  loadDataWithBaseURL(null, \"\", \"text/html\", \"utf-8\", null); //让我们自定义的View得到显示  mErrorFrame.setVisibility(View.VISIBLE); }   mErrorFrame为蒙在WebView之上的一个LinearLayout布局，默认为View.GONE。\n2. 避免加载前白色页面 怎么让用户看不到WebView加载前的白色页面呢？首次加载后页面的跳转可以用上面的步骤进行优化，可以提供给用户一个很好的体验，那加载的第一页呢？我们需要WebView预加载页面，这个该怎么做到的呢？下面提供两种方法:\n 1，ViewPager，将欢迎页面与WebView页面一起放进ViewPager中，设置预加载页面个数，使WebView所在页面可以预加载，在加载完毕的时候切换到WebView所在页面。 2，FrameLayout，将欢迎页面与WebView页面的布局合在一起，显示在一个页面内，起始隐藏WebView布局，待WebView加载完毕，隐藏欢迎布局，显示WebView布局。\n 使用FrameLayout简单一些，两种方法都是需要对WebChromeClient的onProgressChanged进行监听，加载完毕进行页面切换，如下：\n1 2 3 4 5 6 7 8 9  webView.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { super.onProgressChanged(view, newProgress); if (newProgress \u003e= 100) { // 切换页面  } } });   \n三 业务逻辑优化 1. 滑动逻辑判断 ①是否存在滚动条 当我们做类似上拉加载下一页这样的功能的时候，页面初始的时候需要知道当前WebView是否存在纵向滚动条，如果有则不加载下一页，如果没有则加载下一页直到其出现纵向滚动条。首先继承WebView类，在子类添加下面的代码：\n1 2 3  public boolean existVerticalScrollbar () { return computeVerticalScrollRange() \u003e computeVerticalScrollExtent(); }   computeVerticalScrollRange得到的是可滑动的最大高度，computeVerticalScrollExtent得到的是滚动把手自身的高，当不存在滚动条时，两者的值是相等的。当有滚动条时前者一定是大于后者的。\n②是否已滚动到页面底部 同样我们在做上拉加载下一页这样的功能时，也需要知道当前页面滚动条所处的状态，如果快到底部，则要发起网络请求数据更新网页。同样继承WebView类，在子类覆盖onScrollChanged方法，具体如下：\n1 2 3 4 5 6 7 8 9 10 11 12  @Override protected void onScrollChanged(int newX, int newY, int oldX, int oldY) { super.onScrollChanged(newX, newY, oldX, oldY); if (newY != oldY) { float contentHeight = getContentHeight() * getScale(); // 当前内容高度下从未触发过, 浏览器存在滚动条且滑动到将抵底部位置  if (mCurrContentHeight != contentHeight \u0026\u0026 newY \u003e 0 \u0026\u0026 contentHeight \u003c= newY + getHeight() + mThreshold) { // TODO Something...  mCurrContentHeight = contentHeight; } } }   上面mCurrContentHeight用于记录上次触发时的网页高度，用来防止在网页总高度未发生变化而目标区域发生连续滚动时会多次触发TODO，mThreshold是一个阈值，当页面底部距离滚动条底部的高度差\u003c=这个值时会触发TODO。\n2. activity被动被杀之后，能够保存webview状态 进一步的优化，activity被动被杀之后，最好能够保存webview状态，这样用户下次打开时就看到之前的状态了，嗯，就这么干，webview支持saveState(bundle)和restoreState(bundle)方法，所以就简单了，哈哈，看看代码吧： 保存：\n1 2 3 4 5 6  @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); wv.saveState(outState); Log.e(TAG, \"save state...\"); }   恢复，在onCreate()中调用：\n1 2 3 4 5 6  if(null!=savedInstanceState){ wv.restoreState(savedInstanceState); Log.i(TAG, \"restore state\"); }else{ wv.loadUrl(\"http://3g.cn\"); }   \nbug总结 ViewPager里非首屏WebView点击事件不响应 如果你的多个WebView是放在ViewPager里一个个加载出来的，那么就会遇到这样的问题。ViewPager首屏WebView的创建是在前台，点击时没有问题；而其他非首屏的WebView是在后台创建，滑动到它后点击页面会出现如下错误日志：\n1  20955-20968/xx.xxx.xxx E/webcoreglue﹕ Should not happen: no rect-based-test nodes found   解决这个问题的办法是继承WebView类，在子类覆盖onTouchEvent方法，填入如下代码：\n1 2 3 4 5 6 7 8  @Override public boolean onTouchEvent(MotionEvent ev) { if (ev.getAction() == MotionEvent.ACTION_DOWN) { onScrollChanged(getScrollX(), getScrollY(), getScrollX(), getScrollY()); } return super.onTouchEvent(ev); }   WebView硬件加速导致页面渲染闪烁 4.0以上的系统我们开启硬件加速后，WebView渲染页面更加快速，拖动也更加顺滑。但有个副作用就是，当WebView视图被整体遮住一块，然后突然恢复时（比如使用SlideMenu将WebView从侧边滑出来时），这个过渡期会出现白块同时界面闪烁。解决这个问题的方法是在过渡期前将WebView的硬件加速临时关闭，过渡期后再开启，代码如下：\n1 2 3 4  if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.HONEYCOMB) { //关闭硬件加速 webview.setLayerType(View.LAYER_TYPE_SOFTWARE, null); }   避免addJavaScriptInterface带来的安全问题 使用开源项目Safe Java-JS WebView Bridge可以很好替代addJavaScriptInterface方法，同时增加了异步回调等支持，并且不存在了安全风险。\nWebView与上层父元素的TouchMove事件冲突 WebView进入后台依旧占用CPU的解决 WebView Memory Leak WebView内存泄漏 \n扩展 1、在WebView中尽可能不要使用GIFs、Marquee、Blink等动画和渲染效果 Marquee不要用，有四个以上页面会好卡，如果的确需要使用可以用程序写，JQUERY中应该有现成的。 2、Gif可以用但不要太多，页面加载状态的控制可以用一下，其他的不要考虑，当然GIF不显示出来，也不会占用CPU。\n参考资料： Android WebView开发问题及优化汇总\nAndroid WebView CPU高负荷问题\nAndroid WebView页面加载优化\nAndroid WebView常见问题及解决方案汇总\nWebView你真的熟悉吗？看了才知道\n","description":"","tags":["Android","WebView","优化"],"title":"WebView的优化总结","uri":"/posts/webview%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"最近做项目发现WebView有一些奇奇怪怪的现象，在这里记录下。\n一、Android版本4.4及一下，默认情况下\"_blank\"打开新标签页异常 H5通过_blank标签打开新标签页的时候，Android5.0及以上会在当前页面直接load这个url，但是Android版本4.4及一下，则会在当前的标签里面加载这个新页面！ 查了下资料，发现了能统一的办法。 第一步：设置WebSetting的setSupportMultipleWindows(true)：\n1 2  // 告诉webkit：你问我多窗口滋不滋次啊，我当然是滋次的！ webSettings.setSupportMultipleWindows(true);   第二步：在WebChromeClient中监听onCreateWindow()方法，判断参数符合条件就拦截并获取到打开新页面的url，让当前页面加载，要注意的事，点击页面链接，也属于打开心标签，在这里也会被拦截的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // 我不但要拦住你的去路(return true)，还要抢你的钱(url),你把钱塞裤裆里也给你掏出来(获取url方式比较淫秽呸隐晦)  public boolean onCreateWindow(final WebView webView, boolean isDialog, boolean isUserGesture, Message resultMsg) { // 打开_blank创建新标签和点击链接都会触发 add by xiaohongmao 2016/11/15 下午2:41  if(null != webView \u0026\u0026 !isDialog \u0026\u0026 isUserGesture \u0026\u0026 null != resultMsg \u0026\u0026 null != resultMsg.obj){ WebView newWebView = new WebView(webView.getContext()); newWebView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { webView.loadUrl(url); return true; } }); WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj; transport.setWebView(newWebView); resultMsg.sendToTarget(); return true; } return super.onCreateWindow(webView, isDialog, isUserGesture, resultMsg); }   ","description":"","tags":null,"title":"WebView的奇怪现象","uri":"/posts/%E4%B8%8D%E5%90%8Candroid%E7%89%88%E6%9C%AC%E7%9A%84webview%E7%9A%84%E5%A5%87%E6%80%AA%E7%8E%B0%E8%B1%A1/"},{"categories":null,"content":"患有习惯性妥协的疾病，且不自知。\n团队工作，很多时候会出现观点分歧，解决方式是其中一方的妥协，但势均力敌的分歧观点，某一方却一而再、再而三的妥协，那么就暴露问题了。\n","description":"","tags":null,"title":"习惯性妥协","uri":"/posts/%E4%B9%A0%E6%83%AF%E6%80%A7%E5%A6%A5%E5%8D%8F/"},{"categories":null,"content":"自己写了一个java servlet的小服务端程序，用app访问，在家里局域网没问题，但是公司路由设置问题，局域网相互ping不到，所以只能把这小程序放在我个人的vps上跑了，所以过程中用到了scp指令传输文件，在这里记录一下。\nscp -P port filepath vps_username@vps_ip:vps_filepath\n time: 2017-02-03 11:08:54 如果文件太大，可以尝试用压缩压缩后传输的方式，在端口后面增加-C： scp -P port -C filepath vps_username@vps_ip:vps_filepath\n","description":"","tags":["ssh","scp","vps","linux"],"title":"使用scp命令向vps传输文件","uri":"/posts/%E4%BD%BF%E7%94%A8scp%E5%91%BD%E4%BB%A4%E5%90%91vps%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"最近做了个日历相关的需求，发现了不少关于时间获取和转换的问题，特此记录。\n目录 根据年月日获取时间戳\n​\tTime\n​\tCalendar\n\n一：根据年月日获取时间戳 常用的有两种方式，一种是用Time，一种是用Calendar，代码如下：\n\nTime: 1 2 3 4 5 6  Time time = new Time(\"GMT+8\"); time.setToNow(); int year = time.year; // 年 int month = time.month; // 月 int day = time.monthDay; // 日 int timeStemp = time.toMillis(true); // 时间戳（忽略夏令时）   \nCalendar: 1 2 3 4 5 6  Calendar calendar = Calendar.getInstance(); calendar.setTimeZone(TimeZone.getTimeZone(\"GMT+8\")); // 设置时区无效  calendar.getTimeInMillis(); calendar.getTime().getYear(); calendar.getTime().getMonth(); calendar.getTime().getDay();    要注意的时，Calendar对象设置时区后，获得到的时间戳还是标准时间。\n","description":"","tags":["Android"],"title":"关于安卓的时间获取和转换","uri":"/posts/%E5%85%B3%E4%BA%8E%E5%AE%89%E5%8D%93%E7%9A%84%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E5%92%8C%E8%BD%AC%E6%8D%A2/"},{"categories":null,"content":"记录一些平时开发中遇到的奇葩问题。😄\n1.字符串空格替换问题 今天遇到一个替换空格的问题，但是无论怎么替换都替换不掉，一打印log，还是在。 后来看了一下这个字符串的组成，原来这不是空格啊，竟然是\"\u0026#160;\"，查了一下，虽然这个符号会显示成空格，但是直接replaceAll(\" \",\"\");是无法去掉的，如果位置固定，可以根据位置去掉。 资料\n2.back stack拼接问题 singleTask和singleInstance启动的activity，尽管可能不在同一个task，但是仍然会回到原来的activity；但是singleTask可能会存在back stack“拼接”的情况。 如图所示： 3.singleLine弃用了，用什么代替呢？ 1，singleLine弃用了，但是setSingleLine()方法并没有弃用。 2，可以看一下setSingleLine()方法都做了什么，可以看出用下面两个属性也能完成singleLine同样的效果：\n1 2  android:lines=\"1\" android:scrollHorizontally=\"true\"   4，\"/\"反斜杠替换问题-2016年04月26日 需求：在一段内容中，把输入框中用户输入的字符，按照全部匹配的原则，替换成红色。 我的处理方式是：\n1  String title = content.replaceAll(mKeys, \"\u003cfont color=\\\"#f84746\\\"\u003e\" + mKeys + \"\u003c/font\u003e\");   但是当用户输入的有\"/\"的时候，就出现了错误：java.util.regex.PatternSyntaxException: Unrecognized backslash escape sequence in pattern near index 1:\\^。 原因是：在java中\"\"（反斜杠）是转义符号，所以反斜杠后面没有东西的话是不对的，所以，在java中反斜杠要表示成\"\\\\\"; 另外，replaceAll方法实现原理使用了\"regex\"（正则表达式），在regex中同样要用\"\\\\\"来代表\"\"，所以上面的代码应该写成这样：\n1 2  String re = mKeys.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\"); String title = content.replaceAll(re, \"\u003cfont color=\\\"#f84746\\\"\u003e\" + mKeys + \"\u003c/font\u003e\");   这样就没问题了，特此记录。\n参考资料\n5，tab切换后界面自动上跳是什么鬼？-2016年06月13日 初始化第一个tab之后是这样的： 但是切换到第二个再切回来，就变成这样婶儿的了： 是焦点问题，但是具体原理还没搞懂,解决方法是在最外层布局文件中增加如下两行代码：\n1 2  android:focusableInTouchMode=\"true\" android:focusable=\"true\"   6，TextView自带上下Padding导致高度计算不准确的问题-2016年06月29日 TextView默认上下自带Padding的，所以根据TextView的sp计算文字高度是不准确的，所以要计算TextView高度需要去掉上下的Padding,方式就是在TextView中添加如下属性：\n1  android:includeFontPadding=\"false\"   或者：\n1  textview.setIncludeFontPadding(false);   这样去掉上下的padding就可以直接用sp来计算TextView的高度了。\n没有解决的疑问  1.activity启动模式  由于singleTask和singleInstance都可能启动另外一个task，那如果在这个新task里的activity启动一个standard的activity，是继续在新task里面继续压栈吗？\n 2.EditText无内容时，光标和hint的位置  这个问题很简单，我们只要修改EditText的gravity属性就好，left的话光标就在hint左边，right的话光标就在hint右边，center的话光标就在hint中间，但是今天试了一下，gravity无论是什么参数都无法生效，总是居右。。。暂未解决。\n 3.PullToRefresh动画卡住不动的bug  今天修改PullToRefresh动画，但是发现一个现象，刷新的时候动画会卡住不动。。。\n","description":"","tags":["bug","Android","笔记"],"title":"奇葩问题的记录","uri":"/posts/android%E5%BC%80%E5%8F%91%E5%A5%87%E8%91%A9%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":null,"content":"本文记录本思密达开发中用到的一些方便高效的小技巧。\n1，使用Fiddler进行接口断点调试 断点命令如下：\nbpu，在请求开始时中断,可以修改request参数； bpafter，在响应到达时中断,可以修改response数据； bps在特定http状态码时中断；(没有测试) bpv/bpm在特定请求method时中断。（没有测试） 举两个例子： bpu http://xhmsmd.com，监听到http://xhmsmd.com请求要发出前，拦截并进入调试模式。 bpafter http://xhmsmd.com，监听到http://xhmsmd.com请求返回数据后，拦截并进入调试模式。\n清除断点的命令是只输入头命令，例如bpu http://xhmsmd.com的清除命令就是bpu。\n","description":"","tags":["Android","Fiddler"],"title":"我有特殊的开发技巧","uri":"/posts/%E6%88%91%E6%9C%89%E7%89%B9%E6%AE%8A%E7%9A%84%E5%BC%80%E5%8F%91%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"挖坑。\n","description":"","tags":["Android","Hook","反射"],"title":"绕过Manifest对Activity注册检测启动","uri":"/posts/%E7%BB%95%E8%BF%87manifest%E5%AF%B9activity%E6%B3%A8%E5%86%8C%E6%A3%80%E6%B5%8B%E5%90%AF%E5%8A%A8activity/"},{"categories":null,"content":"在很多情况下，我们都会用到对自定义数据结构的排序，而最多的实际排序依据是对字符串的排序。\n举个例子： 联系人排序，contacts是一个我们自己定义的数据结构，里面有两个参数，name和tel，我们要根据name的拼音排序，首先要把汉字转成拼音，然后根据拼音进行排序。\n第一步： 汉字转拼音 资料（第二种方法貌似对\"亳州\"的\"亳\"识别有误）： java程序将汉字转成拼音的两种方法\n第二步： 根据拼音对数据结构排序 首先需要给数据结构制作一个比较的工具类：\npublic class PinyinComparator implements Comparator\u003cContactsEntry\u003e { public int compare(ContactsEntry o1, ContactsEntry o2) { if (o1.getSort_key().equals(\"@\") || o2.getSort_key().equals(\"#\")) { return -1; } else if (o1.getSort_key().equals(\"#\") || o2.getSort_key().equals(\"@\")) { return 1; } else { return o1.getSort_key().compareTo(o2.getSort_key()); } } } 然后通过Collections的sort方法来排序：\nCollections.sort(mCities, mComparator); 这样mCities里面的数据就根据PinyinComparator的排序规则排序了。\n","description":"","tags":["String","排序","字符串","Android"],"title":"自定义数据结构排序（字符串排序）","uri":"/posts/android%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F/"}]
