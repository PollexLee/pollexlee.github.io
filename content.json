{"pages":[{"title":"about","text":"Telegraml6376751@163.com","link":"/about/index.html"},{"title":"个人简历","text":"李朋Android软件工程师个人介绍 出生年月：1988年12月 联系方式：131-2686-6758 Email：l6376751@gmail.com github： https://github.com/xiaohongmaosimida/ blog：http://blog.pollex.me/ 工作年限：7年多 期望薪资：面议 工作地点：北京 经历简述：高中期间对手机软件产生浓厚兴趣，大学报考计算机软件专业。12年底参加工作，从事Android软件开发，15年上旬开始带领5人团队，负责产品研发，版本迭代，排期，技术方案调研，Code Review，技术分享等。 专业技能Android 精通Android核心组件，API控件，自定义View，动画，数据储存，多线程 精通WebView使用及优化，制定JSBridge方案和协议，路由表，DOM约定 熟练运用TCP/UDP、HTTP协议，设计接口交互API 熟练集成第三方SDK 熟练使用Sqlite、GreenDao、Realm 了解Android底层，熟练运用JNI开发 了解插件化，增量更新原理 设计模式 熟练运用单例，观察者等设计模式Java Java基础扎实，在个人VPS上使用Java Servlet+Nginx+Tomcat搭建图床 熟练运用数据结构和基本算法 熟练使用各种第三方开源库 熟练使用git/svn等版本管理工具 熟悉Android平台APP上线流程，搭建Jenkins持续集成环境并配置Android自动化打包环境 掌握OOP，AOP思想 了解MVC、MVP、MVVM开发架构测试 熟练运用Junit、TestNG单元测试框架 熟练运用Postman、Jmeter接口测试工具，Selenium自动化测试工具其他 使用Java Swing制作apk渠道包生成插件 使用Python + aapt制作渠道包验证脚本 对weex、react native等全平台解决方案有所涉猎 工作经验公司：北京决策信诚科技有限公司2016年3月-2017年11月 Android高级工程师 我的职责： 参与版本需求评审、UI评审，提出技术需求，制定项目方案，制定排期计划； 接口API协商，Android端方案制定，需求实现，框架优化，性能优化，APP瘦身； 负责Android端开发进度把控，Code review，内部技术学习及分享； 优化Android APP开发流程，加快项目开发进度； 优化Android整体上线流程； 新技术和新方案学习引进，增加技术积累。 工作成果： 采用Native+H5方案，通过自定义JsBridge、URL Router、DOM约定等技术实现Native和H5的无缝衔接； 通过自定义WebView规避API 17以下 Javascript注入漏洞，用onJsPrompt()曲线救国，保证用户信息安全； WebView支持多标签，解决第三方广告页面跳转的问题； 通过我设计的原生Javascript注入方式，我们的JsBridge方案相较微信JS SDK减少了H5端JS文件的引入，即方便了前端的开发，又保证了安全性； 项目实现组件化，将不同业务模块拆分成多个组件，在Gradle文件中配置引入，即增加了模块编译的速度，又满足了单独功能APP动态拆分的需求； 使用Java Swing + apktool + AAPT制作了一款渠道包生成工具，通过配置文件设置渠道信息，自动生成渠道包；代码中预设三种生成渠道包方式：反编译方式、美团方式、豌豆荚方式。 遇到的问题： WebView视频播放问题； H5嵌入第三方广告页面导致加载无法完成问题； JsBridge调用原生拍照图片数据返回问题； Glide图片预加载与缓存检测问题； URL Router生成问题等。 个人荣誉： 多次荣获技术部季度优秀员工称号及奖励（技术部40人仅限3个名额）； 荣获2016年度最佳员工奖（公司80人仅限5个名额）； 第一个破例转正的员工。 项目介绍： 我爱卡信用卡APP：我爱卡信用卡是我爱卡移动端主要产品，主要模块有信用卡管理、申卡、贷款、社区。 我爱贷APP：我爱卡信用卡拆分贷款模块、用户模块、社区模块合并而成的专门从事贷款业务的APP。 渠道包生成工具：为了减少渠道包生成的成本，我制作了渠道包生成工具，提高了渠道包生成和检测效率。 公司：北京美秒科技有限公司2014年2月-2016年3月 Android高级工程师（组长） 我的职责： 参与版本需求讨论，实现方案商讨，制定排期计划； 接口API协商，Android端方案制定，需求实现，框架优化，性能优化； 负责Android端开发进度把控，Code review，内部技术学习及分享； 优化Android APP开发流程，加快项目开发进度； 优化Android整体上线流程； 新技术学习，新方案引进； Android技术人员培训。 工作成果： 使用JsBridge和H5交互； 客户端植入JavaScript解析器，执行动态JavaScript脚本，实现网页数据采集； 自定义Scheme，实现路由表功能； 单列、双列、瀑布流三视图切换； APP常驻内存优化； 实现锁屏功能，自定义控件实现手势跟随功能； 广告数据自动优化推荐算法。 遇到的问题： AlermManager定时提醒不及时问题； WebView硬件加速造成部分设备花屏问题； 图片特殊适配问题； SingleTask造成堆栈异常； Fragment内存回收后恢复异常问题； 内存泄漏问题； 项目代码规范问题。 个人荣誉： 半个月时间将公司项目重构，代码结构调整，代理分层，View封装，Net层、Cache层优化，增加全局消息机制等； 试用期三个月，两个月提前转正，并加薪（幅度25%）； 2015年初，加薪（幅度30%）。 项目介绍： 抢购助手APP：本项目是一款导购APP，主要模块有商品模块、团购模块、微商模块、闹钟模块、用户模块等。 红包悬赏锁屏APP：本项目是积分墙APP，模仿酷划，使用了有米、多盟、点乐等多家的积分墙。 表情文APP：本项目是一款将文字转换为emoji表情的游戏APP，通过答题进阶、分享的方式获得经验值升级。 公司：北京电通兴业科技发展有限公司2012年12月-2014年2月 Android工程师 我的职责： Android APP开发； 串口数据调试； Android手机root及系统参数修改； 电梯黑盒子功能测试； 工作成果： 0o制作了密云市政巡查APP； 制作了油库监管APP。 遇到的问题： 后台服务上报定位信息不及时； 禁止手机返回到桌面； 项目介绍：密云市政巡查APP：密云市政机构使用的巡查APP，安装在定制设备上，主要功能有：实时定位信息采集，故障上报，紧急电话拨打等功能。 个人项目小红帽远控APP设计初衷 由于Android的模拟器在桌面系统上操作非常不便，制作的一款实体机操控模拟器的方案。 使用场景 实现将手机端的触屏操作即时反映在模拟器上，可扩展为外网的Android端远程操控功能，数位板功能等。 技术方案 Android ：控制端（不需要ROOT权限）、被控制端（需要ROOT权限） 通讯协议：Socket长连接 触屏协议：Linux触屏协议A/B 流程简述：控制端监听触屏事件，将本地坐标转换成通用坐标，通过Socket长连接发送到被控制端，被控制端将通用坐标转换为本地坐标，通过JNI调用C++代码写入/dev/input/eventx文件写入触屏事件的组合数据。开发过程中遇到了Linux触屏协议造成的sendevent事件混乱问题，adb shell命令执行效率问题，/dev/input/eventx文件写入权限问题等，同时熟悉了下C++，再次感慨底层代码执行效率之高。 SmartTranslation插件设计初衷 在即时通讯工具日渐普及的现在，我们势必会遇到很多国际友人，外语不好不要紧，本项目是为了消除沟通语言障碍而开发的一款翻译插件。 使用场景 当你在和国际友人聊天时，复制对方的消息内容，插件即可帮你将消息内容翻译成预先设置好的语言。 技术方案 翻译API：Google Translate、百度翻译API、有道翻译API 流程简述：常驻内存优化；启动Service监听设备剪切板；悬浮窗提示快捷翻译按钮；调用翻译API，获取翻译后内容，通过悬浮窗展示给用户。 遇到的问题： 悬浮窗交互问题； 常驻内存问题； Google Translate的翻译API付费问题。 最牛口袋设计初衷 现在丢手机的人越来越多，为了在手机被盗之时做出提醒，我们团队设计了一款防盗报警软件，在手机被盗时，发出报警声。 使用场景 当手机从口袋中掏出，15秒后没有解锁，播放报警音！ 技术方案 Service监听到锁屏后，启动光线传感器监听； 当符合报警条件，播放警报声音； AudioManager控制音量到最大； 监听物理按键，实现快捷关闭报警音。 遇到的问题： 传感器耗电问题。 工作经历 2017年11月-至今 就职于 北京中化能源科技有限公司 2016年3月-至2017年11月 就职于 北京决策信诚科技有限公司(我爱卡) 2014年2月-2016年3月 就职于 北京美秒科技有限公司 2012年12月-2014年2月 就职于 北京电通科技发展有限公司 学习方式常逛平台Github，CSDN，OSChina，InfoQ，V2EX，TED 阅读过的书籍《Android源码设计模式》、《Android开发艺术探索》、《算法的乐趣》等 解决问题方式Source code，Stackoverflow，Google 自我评价 良好的代码编写风格，架构设计能力 开发完成后有自测和优化代码的习惯 对于棘手的问题能够很快定位并解决 喜欢引入新技术，激发团队学习氛围 积极推进项目开发规范化、流程化、标准化 积极参与需求评审，主动提出个人建议 良好的沟通表达能力，能很好的与产品等同事沟通协调 工作认真负责，积极主动，抗压能力强，多次带领团队奋战在深夜，善于把控项目节点 组织能力强，多次组织团队技术分享，注重团队协作，工作积极配合，最大化的服务于团队 性格开朗，心态平稳，喜欢分享，乐于助人 教育经历 2010年-2013年 河北工业职业技术学院/移动软件开发（荣获国家一等奖学金） 2017年-2020年 中国石油大学（远程教育）/计算机科学与技术","link":"/about/my_resume.html"}],"posts":[{"title":"从产品和运营的角度来看待技术转变","text":"我们要从产品和运营的角度来看待技术转变。 独立开发者 &amp; 行业活动家 Oasis Feng（冯森林） 如是说。 《Android研发的昨天、今天与明天》的学习笔记。 冯老师是我非常喜欢的Android开发带路者，他个人开发的应用和行业活动，都极大的推进了Android生态的优化和进步。 行业活动家 2013年发布个人应用：绿色守护 - 推动改善Android设备体验 2018年 推动应用提升Target SDK Version 28+ 2017年 Android绿色应用公约（green-android.org） 2017年 游说Google规范手机厂商的应用后台管控行为 即将到来的根本变革 移动互联网的范式转义 从产品和运营的角度看待技术转变 一切皆为转化和留存 昨天 - 流量圈地时代，2016年底结束 Native应用抢占顶级流量入口，web成为次级入口 今天 - 流量攻守，虎口拔牙 大型应用转为免安装应用 Android 9和iOS 12都发布了应用时间统计，流量黑洞，过于庞大的应用会降低平台的效能 流量思维 -&gt; 服务思维 争夺高端用户 目地导向的快捷交互路径 在对的时间透出对的内容 启动：启动图标 + 推送 Android启动入口 Shortcut Android Actions Contextual Push Nearby Rich Notification Widget -&gt; Android Slices 产业格局 合纵连横 合纵以求生 开放入口 开放内容 开放接口 加入公约 连横以顺势 明天 - 心智的渗透时代 针对不同群体塑造差异化认知 跨越物理设备的立体化裹挟 移动应用的技术栈跃迁 将应用解构，局部拆解，针对设备形态灵活的重组 服务端逐渐消亡，低成本转栈，没有服务端 分布式研发 Android研发的演进 迭代效率 团队 小型团队，拿来主义 中型团队，组建化 大型团队，组建化 + 并行构建 组建化 昨天 - 插件画框架，组件化框架，轻组件化 今天 - 基于Android App Bundle 部署弹性 产品阶段决定部署弹性的诉求 初创产品，敏捷发布 -&gt; 为组件化打下基础 成长产品，迭代发布 -&gt; 通过「轻组件化」实现独立迭代发布 规模产品，可重组的动态部署 -&gt; 基础上升及动态部署 国际化产品，兼容并充分利用Google Play -&gt; 国际动态部署双轨制 研发成本 团队解构决定研发成本的优化思路 粗放型团队，QA难 -&gt; 可靠性隔离，面向组建的分层测试 精英型团队，对个性的包容与激发 -&gt; 职称研发语言，技术选型等自由度，提供尝新的土壤 大规模团队，降低研发耦合式内耗 -&gt; 组建粒度的独立集成、发布、部署，支撑高效并行迭代 996团队，提升交付窗口弹性，优化研发内趋力 -&gt; 主人翁意识 Android App Bundle Google Play Instant PlayCore Library 免安装 - 按需下载，动态部署 组件化 + 动态部署 （PackageInstaller.MODE_INHERAtE_EXISTING) 国内 Android领域挑战 - 微博/Twitter放出 Android Oreo 开启铁幕时代 推送的末路 or 新生？ 国际化的「文明冲突」","link":"/2020/02/2月16日/"},{"title":"Android插件化路在何方","text":"紧密的Follow官方，平滑过度才是插件化最稳妥的道路。 京东商城资深 Android 系统架构师 张志强 如是说。 《当插件化遇上Android P》的学习笔记。 Android P禁止调用非SDK接口，对插件化技术有很大的挑战，但更禁止了不良开发者利用非SDK接口做对用户不利的行为，总体来说，利大于弊，支持官方。 Android P 禁令 禁止应用程序调用非SDK接口 浅灰名单 深灰名单 黑名单 Android AppBundles Legacy APK - 所有资源一个包 Dynamic Delivery - 动态下发 将APK拆分成多个，动态下发用户需要的 AAB的整体流程 上传Base apk 和AAB到Google Play 用户下啊在Base apk，根据需求下载AAB资源 限制 必须通过Google Play发布 最低版本支持Android 5.0 不是很成熟，单纯的减少了包的体积，无法通过动态下发修复bug或者增加新功能 成本 AS 3.2 集成Play Core Library 加入SplitCompat库以支持6.0以下的手机Dynamic feature apk 所有模块必须位于同一个工程 如果之前的Library想改造成Dynamic Feature Module必须手动改造 Android插件化路在何方 用到了哪些黑科技 Hook app中关键技术点，达到动态劫持页面请求 动态加载插件中的Class，大量使用反射 单ClassLoader 多ClassLoader 动态加载插件中的资源 反射调用AssetsManager中的addAssetPath()方法 ###京东架构升级和重构 为什么需要插件化 65536 模块解偶 多团队并行开发 加快编译速度 动态部署，修复bug和发布新功能 我们的需求 去除黑科技 平稳过度 边界隔离 并行开发 独立调试 快速编译 动态部署 路在何方 Follow官方 组件化 大前端技术 RN 快应用 Weex 步骤 增加组件化功能 组件化 + 插件化 AAB、前端技术 持续改进和优化 重构 去除插件化黑科技 平稳过度 JdLib去中心化 插件组件随时互转 京东架构升级 Aura插件化架构升级 -&gt; Aura Plus 插件和组件灵活互转 无缝调用 优势互补 去中心化 平台支撑 重构后架构图 一切皆组件 解密关键技术点 高内聚低耦合 以Project和Module为边界进行组件间隔离 一主工程多字工程开发模型 多个仓库：一主多子 Library无需转换到Application 一切皆组件 小团队独立开发 使用暴露API的方法达到组件间灵活通讯和调用的目地 组件编译产物 Api.jar Full.aar 处理组件的依赖关系 组件无依赖传递，边界隔离 武林秘籍 通过Gradle插件实现方便的依赖引用 预防资源id冲突：resourcePrefix 统一管理第三方库：ThirdBundle 统一管理公共资源：BaseResBundle","link":"/2020/02/2月17日/"},{"title":"秒开秒用，用完即走","text":"快应用最大的特点就是秒开妙用，用完即走。 小米快应用前端负责人 董永清 如是说。 《快应用开发与实现指南》的学习笔记。 ​ 作为原生APP开发者，对H5开发并不是很了解，尤其是涉及到架构方面，学习快应用相关知识，主要是了解现在手机应用开发的趋势，各种技术的实现原理和特点。 ​ 快应用在实现方案上，对标微信小程序，体验上应该也比较类似，只是提供原生支持的从微信应用换到了手机厂商的内置支持。 背景介绍 什么是快应用，视频介绍 秒开 用完即走 3月20日，小米及其它9家厂商宣布快应用诞生，统一了标准 多家手机厂商内置到room中 多场景应用 -1屏、浏览器入口、全局搜索入口、应用商店入口等 技术如何做到 移动网页 - 无需安装，升级容易；性能差，功能确实 原生应用 - 性能好，功能完整 ；需要下载安装，版本问题 快应用 - 秒开，容易管理，性能好，功能完整 开发体验：接入成本大？ 和H5开发体验类似 静态页面 标签 样式 脚本 调整样式 flex css属性子集 多种选择器 系统能力 import引入系统能力，import prompt from '@system.prompt‘ 调用方法 prpmpt.showToast() 其它功能 我理解的系统能力，就是系统内置一套快应用专用的web框架，和微信的小程序的方案完全相同。 响应事件 模块定义 ViewModel 数据模型 public，protected，private 组件事件 click，appear，focus 声明周期 页面创建 页面可见性 页面销毁 按键响应 - 实体按键，虚拟按键 开发体验 组件化 自定义组件 引入组件 使用组件 原生组件 List，list-item，tabs等 动画 调试开发 devtools Elements 查看dom结构 Style 修改节点样式 Source 调试js代码 Console 输出日志，数据结构 总结 前端概念 + MVVM + 组件化 架构概述 编译时 ux页面：html + style + script js页面：json+js 页面UI：DOM树 运行时 rpk压缩文件 流程 UX =&gt; 编译时 =&gt; JS页面 =&gt; 运行时 =&gt; 页面UI 多页面 =&gt; 编译时 =&gt; rpk压缩文件 =&gt; 运行时 =&gt; 应用 编译时工具 hap-toolkit工具 脚手架 编译器 调试器/服务器 运行时 js引擎 渲染引擎 JS层架构 架构输出 MVVM 组件化 数据驱动 Diff实现 应用管理 页面 生命周期 DOM模型 样式计算 基础能力 组件 系统能力 第三方服务 回调机制 DOM模型 样式计算引擎 编译样式 元素更新 合并计算 优化 选择器规则分类 缓存元素子节点匹配规则 懒合并计算 页面渲染 创建页面 -&gt; 建立DOM模型 -&gt; 节点转换、布局 -&gt; Android OS层","link":"/2020/02/2月18日/"},{"title":"基于AAB的插件化方案：Qigsaw","text":"AAB的开发套件太爽了，不想就这样暴殄天物。 爱奇艺资深工程师 陈家威 如是说。 《基于Android App Bundle动态化方案探索》的学习笔记。 爱奇艺的Qigsaw方案脱胎于AAB，紧跟Google的脚步又适应国内环境，高大上又接地气。 Google减少APK体积的发展历程 以前的发布过程，周期长，占用更多空间 包含所有so库 包含所有资源 包体积和安装成功率呈反比 Multiple APK Google Play支持 通过不同配置，下发不同apk 通过Gradle 的split配置打包 像素配置 架构配置 推广使用并不好 Android App Bundle apk转换为 aab 上传aab到Google Play Google Play将aab拆分成多个apk Base APK Configuration APK 下载是根据配置下载：Base APK + Configuration APK + xxhdpi APK + arm64 APK Dynamic Feature 根据设备配置继续拆分 国内插件化发展回顾及原理分析 国内插件化 AndroidDynamicLoad DynamicLoadAPK Neptune OpenAtlas DroidPlugin 原理 BaseDexClassLoader加载class Resources AssetManager BaseDexLassLoader加载lib中的so AndroidManifest记录四大组件 单类加载器 Element 对应 DexFile，加载Dex NativeLibraryElement 对应 File 记录so目录 多类加载器 替换系统ClassLoader 每个插件，独立的ClassLoader加载 资源加载 资源文件ID PP（系统应用还是第三方 7F）TT（资源类型）EEEE（顺序） AAPT|AAPT2生成资源ID 调用AssetManager#addAssetPath(String) 加载Asset资源 系统资源 PP01 PP02 PP03 App资源 PP7F 插件 PP7E 资源隔离 资源分区 启动未在宿主AndroidManifest文件注册的Activity 插状预埋方式 startActivity后，execStartActivity时替换Class信息，newActivity时还原Class信息 Android App Bundle原理介绍 Split APK Android 5.0提供 减少包体积 签名相同 同一个应用 如何安装？ adb 安装：adb install-multiple [base-apk,split1-apk] PackageInstaller安装 在运行期间，安装Split APKs 安装后，宿主应用进程会被杀死 系统应用可以静默安装Split APKs 如何加载的 - LoadedAPK 用于保存当前已加载APK的本地状态 mClassLoader 创建PathClassLoader ：createOrUpdateClassLoaderLocked(List addedPaths) 增加Split APks路径 mResources getSplitRources mApplication AAB如何加载插件 Play Core Library，Google Play支持 SplitCompat 为了可以及时插件生效，与国内插件化很类似 国内无法使用Google Play Qigsaw简介及原理分析 利用AAB开发套件，爱奇艺自研的动态组件化方案 设计原因 开发者希望插件和基线能在同一工程写作开发 体验好 共同学习 Android P对私有API访问限制 利用AAB强大的开发套件 便于国际化 开发初体验 全新的打包插件 dynamic-feature 插件和Base 可以同一开发调试 部分插件可以和主apk打包在一起，部分插件apk上传到cdn 核心优势 “山寨”Play Core Library公开接口实现，开发者阅读官方文档即可开发 Hook，少量私有API访问（Grey list） 利用AAB开发工具 支持Android4.0及以上 任何进程均可加载插件 国际化和AAB无缝切换 对比其它插件化框架 接入方便 无需关心插件上传，分发 插件安装加载过程 与AAB过程类似 如何工作的 单类加载器 资源加载使用Qigsaw独有方式，插件提供代码插入 1234public Resources getResources(){ SplitInstallHelper.loadResources(this,super.getResources()); return super.getResources();} 扩展功能 多进程支持 解决“那个进程发起插件请求，插件就加载到哪个进程里”问题 捕获ClassNotFoundException异常然后在game进程中加载已安装单未加载的插件 Hook PathClassLoader 支持插件的Application，在插件启动时创建Application实例，并调用生命周期方法 支持插件的Provider 进程启动时移除插件Provider 插件启动时再进行Provider安装 与Tinker融合 通过Tinker Patch下发插件更新 assets文件中的文件记录版本号 在爱奇艺的应用场景 爱奇艺小游戏和小程序框架，是通过Qigsaw加载的 19年初上线，经受数亿用户考研 崩溃率接近于0% 开源计划 已开源 地址：https://github.com/iqiyi/Qigsaw","link":"/2020/02/2月19日/"},{"title":"没有办法一劳永逸，所以我们面面俱到","text":"我们确实找不到一套方案来解决所有问题，所以我们都做了。 美团点评资深技术专家 方锦涛 如是说。 《美团客户端动态化实践》的学习笔记。 除了一些重交互的效率工具，其它的都是JS的天下。 关于美团业务 200+个品类 美团客户端平台 众口难调 业务发展阶段不一样 团队技术栈不一样 历史包袱不一样 移动端开发的痛点 Native 多端开发 升级慢 H5 功能弱 体验差 Native优化 提高迭代效率 开发效率 更新效率 H5优化 功能问题 体验问题 已知方案 百度 轻应用，小程序，DynamicLoadAPK，ReactNative，HtmlNative 阿里巴巴 支付宝小程序，Weex，Atlas，Tangram 腾讯 微信小程序，VasSonic，ReactNative Google Android Instant App，Progressive Web App，Flutter Facebook ReactNative 携程 DynamicAPK，Ctrip ReactNative（CRN） 滴滴 VirtualAPK，DynamicCocoa 其它 快应用 动态化技术方案总结 布局动态化 虚拟运行环境 业务插件化 Web容器增强 美团动态化方案的选择 特点 迁移效率 开发效率 更新效率 稳定性 流畅度 Web容器增强 流畅度太差 业务插件化 开发效率稍差 布局动态化 方案简单，稳定，用在了美团首页 虚拟运行环境 迁移效率低 开发效率高 美团“发现”Tab 使用的ReactNative 美团客户端动态化的痛点 动态化诉求不一致 业务发展阶段不同 团队技术栈不同 历史包袱不同 确定 多套解决方案 布局动态化 MTFlexbox 美团首页、搜索结果页、外卖首页、美食首页等 业务插件化 美团插件化框架 Hydra 搜索业务，火车票、机票、周边游、到餐旗舰店、金融闪付等 虚拟运行环境 MRN 收藏业务、内容业务、火车票部分页面、外卖退款页等 Web容器增强 TitansX 各种运营活动页面 移动端动态化未来之路 PC年代 CS - 纯客户端开发 生产力工具，重交互效率 PS - 网页 功能专一 移动年代 类似PC 编辑工具，效率工具 还是Native的天下 交易工具 BS方向，小程序，快应用，PWA，RN 资讯工具 小程序、PWA 通讯工具 业务插件化","link":"/2020/02/2月20日/"},{"title":"越复杂的需求，就要做越简单的设计","text":"即使后台数据服务挂了，C端还是能拿到数据的。 美团点评高级架构师 蒋国宝 如是说。 《打造稳定、灵活、高效的运营配置平台》的学习笔记。 为每一个应用场景开发一个页面，效率是非常差的，设计一套可灵活组合的动态化运营后台，才能更好地满足多变的业务需求。 运营平台是什么？ 打断是扼杀搞效率工作的一大原因 让产品自己发布 高效 难点：多样展示、跨团队 方案 模块化拆分，达到可配置 不同模块进行组合，称为商户样式 商户样式什么决定？ 版本 商户类型 城市 模块化配置运营 可复用的模块列表（模块池） 运营通过后台可以配置模块组合 灵活 为每一个应用场景开发一个页面？ 缺点：需求易变，开发效率低，维护成本高 构建多个维度下的动态运营界面 优点：界面动态声场，无需开发，界面灵活可定制 方案：Json存储页面配置 稳定 配置内置到app内部一套，保证没有拉取到最新配置 配置完成流程 审核 + 测试预览 = 上线的可靠性 数据域划分 &amp; 审核上线 测试设备注册，保证上线前预览效果 第一个版本 C端 -&gt; 业务接入层 -&gt; 配置后台数据服务 -&gt; Redis缓存/数据库 演进1 C端 -&gt; 业务接入层 -&gt; 配置后台数据服务/本地缓存 -&gt; Redis缓存/数据库 优点：解决Redis抖动造成的问题 缺点：单击内存大小限制，中心化带来堵塞问题 演进2 C端 -&gt; 业务接入层/数据缓存SDK，做部分数据缓存 -&gt; 配置后台数据服务 -&gt; -&gt; Redis缓存/数据库 优点：各业务缓存各自的数据，去中心化 缺点：数据一致性如何保证？数据时效性如何实现？SDK本地缓存如何监控？ 演进3 将SDK植入C端，正在开发","link":"/2020/02/2月21日/"},{"title":"无线持续交付平台助力移动端开发","text":"重复造轮子是不好，但是适合自己的轮子才是最好的。 携程开发总监 刘李丰如是说。 《携程无线技术平台化研发实践》的学习笔记。 持续交付平台 - MCD MCD之前 专人打包 最多2-3个包 per day 开发测试流程完成通过人工协调 发版时迟迟不能定版 最和新问题：没有版本信息，包名相同，自动化测试不清楚验证包信息 MCD 1.0 解放生产力，随时打包 自动化流程，打包流程由环境演变成pipeline CI/CD 定时打包 代码扫描 自动化验证包 - 白屏检测 持续继承 + 冒烟测试 代码扫描 infer &amp; sonar 冒烟测试 多机型兼容测试 页面内容长度 + 图像比对 超级App改造 同一个代码库 基于源码打包，编译错误阻塞打包 打包时间仍然过长，8分钟 超级App改造 - MCD 2.0 重新定义MCD 集成 测试 发布 运营 基于Bundle打包 引入Bundle发布状态（L，RC） 进一步优化流程 从项目创建覆盖到定版 急速出包 2-3分钟 发布升级 发布对象 hotfix Bundle Hybrid/RN 升级之路 存储云化 灰度发布 白名单/百分比 差分 全量 文本 二进制 动态差分 实时查看 基于设备ID查看 整体趋势 配置中心 移动端配置中心化 支持平台，版本，渠道下发 支持分流，AB App启动全量拉取 崩溃收集 Bugly很专业，无法定制 基于代码打标签，MCD无缝对接 实时报警 多维度搜索 各种样式Dashboard App Size管理 基于业务线模块进行统计 和历史版本比较 各自比较 刨除法计算 MCD Arch Not Just Jenkins MQ 解决 Jenkins Cluster 支撑数量 打包：10000+ 每年 发布：10000+ 每年 性能监控平台 - APM APM背景 缺乏质量大盘 缺乏精细化运营数据 缺乏多维度查看数据 Hive拉取数据过漫 APM质量大盘 网络性能 网络成功率 崩溃率 启动时间 定位成功率 APM多维度分析 热门地区 运营商 网络 APM服务大盘 成功率 耗时 请求大小 报文大小 Error code占比 APM报警 设定阈值 与上周数据比较 有问题数据进行冒烟 精细化运营 - Server IP下发 背景 运营商 网络质量存在差异 方案 海外：国家 国内：城市 目标 下发高质量的IP列表 测试结果 成功率1个点提升 踩过的坑 噪音数据过滤 数据处理性能，延迟监控 埋点监控 数据处理的准确性 Hive数据比对 数据Trade off 无线请求可以花粉为App版本、平台、网络类型、国家、城市等 维度降低 设计细节 Metric 100+ 日处理数据量 100亿+ 写入数据量 100GB+ 处理流程： app采集数据 -&gt; Storm数据清洗聚合 -&gt; DownSample数据归集 -&gt; ES数据存储 -&gt; Dashboard数据展示 Down sample设计 多级聚合 错误监听 状态监听 日志排障平台 - MTS MTS背景 全链路打通 Native App TCP服务调用 Hybrid/H5 调用 Base Page请求 图片请求 用户轨迹流，崩溃路径 用户服务访问流程，各自的报文 无线技术平台 - MTP 无线平台建设背景 缺乏Meta信息维护 重复造轮子，质量不高 研发效率不高，App代码导出拷贝 缺乏通用解决方案 移动技术产品 Platform Communication Framework Business 通用技术方案 MTP 注册应用，组件，开发控制台 MCD 集成，测试，发布 APM 运营，监控 MTS 排障 MTP控制台 平台治理 开放 注册服务，注册回调 排障 查询数据及调用链 熔断 服务请求过载 报告 查看调用 未来方向 打造无线中台 大数据赋能","link":"/2020/02/2月22日/"},{"title":"端智能是什么？","text":"不确定性是对人的最大挑战和锻炼。 阿里巴巴高级无线技术专家 吕承飞（吕行）如是说。 《淘宝端智能探索和实践》的学习笔记。 由于个人对深度学习了解有限，只记录了一些比较书面的内容，作为个人拓宽视野的资料。 端智能背景介绍 端智能应用示例 人脸贴纸 人脸交互动作 图像物体识别 试装 端上AI优势，不做模型训练 实时性 个性化 数据隐私 离线服务 应用场景 AI手机 AI摄影、AI图片编辑 AI提升性能 App OCR 短视频/直播、特效 安全风控 互动活动 试装 个性化推荐 业界趋势 AI芯片 麒麟970 A11 骁龙845 AI框架 FB Caffe2 Google TF-Lite 苹果CoreML Android NNAPI 腾讯NCNN 百度MDL/Anakin 小米MACE 华为HiAI 端智能已成为趋势，各大公司积极布局AI芯片和AI框架； 端智能已在手机和App中发回巨大价值，未来可期； 手机摄像，短视频特效，端计算，IOT智能硬件是终点应用方向。 系统模块 面临的问题 适合移动端的算法模型 如何解决模型文件过大问题 如何解决端侧模型推理问题，需要一个深度推理框架 如何解决深度模型部署更新问题 如何解决部署后的模型安全问题 如何解决端上计算力有限情况下的性能问题 端智能工作流程 模型训练 模型压缩 模型发布 推理预测 模型压缩平台 基础方案 支持TF/TF-Lite量化模型/直接量化工具 门槛低，对算法透明 压缩率低，精度有一定下降 高级方案 低精度计算（8bits/3bits）/剪枝/稀疏 压缩率搞，基本无精度损失 对算法不透明，修改框架，重新训练 模型管理下发度量平台 模型管理 模型转换 模型列表 模型详情 模型发布cdn 发布管理 版本管理 版本详情 发布 单机 灰度 AB 回滚 发布 数据管理 发布度量 成功率 异常 模型度量 推理耗时 内存消耗 成功率 使用统计 端侧的推理框架 核心指标 通用性，跨系统 轻量性 高性能 安全性 易用性 挑战 设备资源局限性 性能挑战 模型文件 适配挑战 方案选择 开源方案 TF-Lite 不同模型格式 模型转换困难 支持PO和Layer不同 Caffe2 性能优化不够充分 功能支持不充分（OP有限） 系统方案 Android-NN API Android 8.1 iOS CoreML iOS 11 自研方案 AliNN 统计部署 异构设备优化 模型安全 ALiNN完整体系 模型转换工具 模型编译器 ALiNN性能优化思路 转换工具 模型优化 内存优化 计算加速 NCHW内存布局问题 ALiNN NCoHWCi(4)内存布局 如何在业务场景应用端智能 业务触发 理解端智能 个人感想 移动互联网下半场出路？ 效率 大规模团队协同开发方案 自动化UI还原 代码腐化问题 体验 突破自己 脱离舒适区 怎么过去 因为相信，所以看见，关键怎么过去 不确定性 不确定性是对人的最大挑战和锻炼","link":"/2020/02/2月23日/"},{"title":"AR发展，未来可期","text":"AR是一个瓶子，这个瓶子可以装天下。 沪江网架构师 李超如是说。 《AR在直播系统中的应用》的学习笔记。 了解VR/AR/MR的概念和特点，了解当前AR技术的发展阶段。 VR/AR/MR介绍 VR：虚拟现实，可以完全沉浸到该环境中 AR：增强现实，将虚拟世界与现实世界结合到一起，并能进行互动 MR：混合现实技术，虚拟环境中引入真实场景 AR技术与现状 2017年6月5日，苹果发布ARKit Tango，Google眼镜 AR应用场景 游戏 电商 教育 直播 AR核心概念 特征点：计算机视觉中的一种关键技术，通常用在人脸识别中。 特种点是指图像灰度值发生剧烈变化的点或者在图像边缘上曲率较大的点。像边缘特征点，角点等都是常见的特征点。 运动追踪：ARKit使用视觉惯性测距技术获取手机的姿态 通过采集对的图像序列进行计算机视觉分析，找出其特征点在连续的图像帧之间的位置变化，再通过设备的运动传感器，最终得到设备的位置和方向。 场景理解：平面检测，识别地面，桌子等平面。 识别的方法，区域中Y值为0的区域 光线评估：估算当前环境的光线强度，使虚拟物更真实。 ARKit运行机制 ARKit三个核心类 ARCamera：不停的获取手机拍到的图像 ARSession：三大概念处理 ARSCNView：展示 ARKit虚拟物品 SCNScene：画布 SCNNode：虚拟物品 SCNMaterial：纹理，材质 ARKit运行机制 ARConfiguration ARFrame：AR帧 ARAnchor：锚点，控制虚拟物品的位置 ARKit Demo任意门 Demo演示 ARCore运行机制 ARCore核心Session类 运动跟踪、场景理解、光照评估 ARCore运行机制 Session OpenGL ES GLSurfaceView View组件 Surface、SurfaceTexture、SurfaceView、GLSurfaceView、TextureView等组件 OpenGL ES 矩阵变化 什么是EGL OpenGL ES API：控制GPU ARCore与ARKit区别 核心算法相同 ARKit API相对完整，ARCore只关注核心算法 ARKit可以商用，ARCore只能在有限的机型上测试。 AR在直播系统中的应用 视频通话与AR 音视频通话的基本原理：采集，编码，传输，解码，渲染。AR在视频通话中的实现与本地的AR应用有着本质的区别。 难点： AR与非AR客户端如何交互，ARKit和ARCore如何互通？ AR端无法直接从ARCamera获取视频 帧率过高导致传书码流过大 设置参数及启动Session 获得锚点及设置虚拟物品 展望 裸3D离我们还很遥远，但通过手机我们可以实现部分黑科技，可以将AR认为是一个瓶子，这个瓶子可以装天下 目前AR才刚刚起步，未来可期","link":"/2020/02/2月24日/"},{"title":"在浏览器上打王者荣耀？","text":"在生态链上，完成自己的角色。 上海木鸡网络科技有限公司联合创始人 杨轶如是说。 《移动Web上玩转原生游戏》的学习笔记。 了解当前移动端Web游戏开发的历程、技术瓶颈和作者产品的功能。 当今移动端浏览器为游戏开发准备了啥 HTML5，CSS3，JS，WelGL Web API：Web Audio API, XHR/Fetch, WebSocket, WebRTC, Web Workder, Touch/Accelerometer 存储，IndexedDB PWA，Service Worker JS引擎：V8，SquirrelFish Extrem，JaegerMonkey Web上游戏开发之现状 纯Web游戏引擎 COCOS 2DX，Egret，LayaBox，Construct 2，three.js 原生游戏引擎Web版 Unity，移动端游戏王者，50%占有率，可用资源多 Unreal，大，占有率不高 Emscripten Web游戏渠道平台 小游戏框架，国内环境 标准HTML5，WebView渠道，海外渠道 移动Web上能玩原生游戏吗 移动Web环境，Unity WASM模块：函数多，加载慢，编译慢，内存占用高 Web天生不支持阻塞调用，加载大资源是问题 使用MultiThreading，BSD Socket的游戏 WEB-IR，Unity引擎游戏通过WEB-IR处理，达到可以在移动Web环境可以运行，轻游戏2.0时代 代码动态Profiling，Code Size减直1/3，加载启动提速2X 编译器支持的阻塞机制，虚拟上下文切换，支持资源渐进式加载，支持TCP/UDP select/poll 虚拟协程来模拟多线程 软件栈 OS Layer WebView Client, Browser Client Game Engine Core / WebAPI 和设备打交道，平台SDK Game Logic Native Part / Game Logic Web Part 游戏逻辑 内存使用是Web游戏的第一阻碍 案例分析 贪吃蛇游戏 代码动态Profilling，Code Size缩小到1/3，编译加载时间缩短 支持阻塞调用，资源文件可以同步读取，仅需要8M内存来做Cache，按需下载的数据很小，加载耗时明显见效 对原始WASM代码进行重编译，插入控制指令，并奇怪Patch Unity的IL2CPP库以支持虚拟的多线程调用和UDP连接，解决了原生游戏所依赖的网络连接问题 MMO 3D游戏 3D游戏，需要更大的计算量和更多的资源，同事也真实了Unity 3D游戏的表现力 由于原生游戏依赖了很多第三方库，UNity WebGL版执行代码有超过60K个函数 Demo版的资源有300M，意味着完整游戏会在GB级别，占用内存也就在GB级，在手机浏览器环境是完全不可界首的 MMO游戏，要用到BSD Socket和MUlti-Threading，不做调整的Unity WebGL版依旧无法运行 通过我们处理，有效函数控制在20K个，为了满足iOS对编译WASM的限制采取了WASM和JS混搭的Hybrid模式，同事配以IndexedDB来满足资源持续储存并作为Cache加速再次加载的速度 3D 动作游戏 中量级，3D单击游戏，内容丰富，移植速度快 解密类游戏 适合Web化，操作要求不高 实践中的关键 WASM程序所要编译的函数 游戏首帧启动时间 游戏运行时内存占用 WEB-IR，这种方案所要解决的关键问题 WEB-IR解决问题的关键-重构Unity WebGL 动态Profilling 资源渐进加载 大块文件切割成若干个Chunks Chunks预加载 Chunks多种方式存储 解析出来的资源数据会被保存到内存Cache中提高访问速度 Chunk渐进加载以阻塞I/O为前提 云端跟踪前端资源的加载情况，为后面的加载做准备 渐进加载无需开发者修改代码 阻塞I/O 阻塞IO是保存文章的调用栈，以做恢复使用 虚拟线程 协程方式代替线程 WEB-IR工具链 WEB-IR以一种中间语言的代码格式支持整个技术框架，工具链所BUild产出的任何代码都是基于WEB-IR中间语言之上 WEB-IR中间语言是和WebAssembly在相同级别的低级语言，基于的是CFG而不是AST WEB-IR中间语言以纯文本的形式保存，方便修改调试 WEB-IR中间语言可以通过源代码（C/C++）和WebAssembly 二进制码生成 我们的感悟 用好前人的肩膀，尽量不要重复造轮子，在生态链上，完成自己的角色 拓展思维，尝试做一些不一样的事情 很少有火箭科技，更没有黑魔法，在实践中不断地改良 时刻不要忘记真实环境的适配能力","link":"/2020/02/2月25日/"},{"title":"Fuchsia - 来自 Google 的全新开源操作系统","text":"在未来Fuchsia会成为一个非常重要的操作系统。 重德智能工程师 许中兴如是说。 《世界需要新的操作系统-Fuchsia设计解读》的学习笔记。 了解Fuchsia操作系统的基本情况、设计原理和优点，了解市场上各个操作系统的境况。 Fuchsia的基本情况 全新的操作系统 Google开发 微内核，基于能力的访问控制，Vulkan图形接口，3D桌面渲染Scenic，Flutter应用开发框架，目前支持的编程语言：C/C++，Go，Rust，Dart 2016年，Google放出所有代码，但是没有正式宣布项目目标，一个IRC频道交流 支持的架构X86-64和ARM 64，支持的设备从IoT到服务器 Google为什么要从头设计权限的操作系统 737问题：当系统总体设计出现问题的时候，用再多的技巧去弥补，也只会造成最终的灾难 现代通用、开放OS需要面对的方面 上游硬件厂商 下游应用开发者 设备友商 用户 黑客 Fuchsia解决现代OS痛点 原生进程沙箱，解决应用安全和分发问题 Linux：Namespace，Control group，Unionfs =&gt; Docker 稳定的驱动接口，硬件厂商可独立维护硬件驱动 系统模块化，分层，设备厂商可以灵活定制专有系统 基于Vulkan和物理渲染的纯3D UI，全局光照 Flutter应用开发框架 Fuchsia重新思考四个Unix的基础抽象机制 全局文件系统 Unix，存在一个全局的跟文件系统 他是每个进程共享的基础资源 文件系统涵盖了非文件资源：/proc, /sys, … Fuchsia里，没有全局根文件系统 文件和文件系统成为一个局部概念，从而在进程内核数据结构里没有file 用Namespace来定义一个进程能够访问的资源，每个name对应一个资源进程channel的handle 用户 Unix中，User本来是用作不同的用户登录，共享服务器的机制 User是真正的用户 后来主要用作权限控制，弱化的沙箱机制 Fuchsia中，在底层（Zircon，Garnet）没有用户的概念 用namespace来控制进程能够访问的资源 Capability-based access control 从而在进程里没有uid 进程的创建 Unix中，新的进程由老的进程fork而来 新的进程继承父进程的全部资源 偷懒的设计 Andrew Baumann, a fork() in the road, ACM Hot Topics in OS, May 2019 Fuchsia中，新进程需要从头开始创建 创建process，Thread 父进程建立初始的namespace到资源channel handle的映射 调用process_start显式的告诉内核新的进程可以跑了 在Fuchsia内核的process数据结构中，没有file和uid 系统调用 Unix中，通过中断调用内核服务：int 0x80，syscall,sysenter 系统调用的方式是确定的，直接的 内核接口不能变 可以被任意注入的代码调用 Zircon里系统调用通过vDSO进行，意图是防止用户代码直接通过固定的中断代码调用system call，达到内核详细接口的隔离，保持C层面的接口稳定：名字 + 参数。而不是内核入口汇编指令层面的稳定 注入的代码无法直接调用vDSO里的接口，虽然加载地址固定，但是计算出入口地址很难，如果不是不可能的话 内核会验证调用指定的地址，而vDSO的加载地址是固定的，并且在编译的时候会验证有限的入口符号，这些符号在编译时位移生成，防止用户进程绕过vDSO 这里主要的目地是隔离system call的调用方式，不是绝对已以上的不可注入调用 仿佛是专门针对漏洞利用作出的设计 典型的漏洞利用步骤 通过系统调用fork()/exec()直接创建反向shell 继承uid获得泛在授权 访问全局文件系统 在Fuchsia里，以上机制都不存在 没有固定的系统调用入口 船舰进程时显式建立root namespace 没有user，从而没有ambient authority (DAC/MAC) Capability-based access control 能访问的资源是父进程赋予的namespace，看不到初始namespace之外的任何资源 Kernel的本质是什么？ 不是 管理硬件 执行特权指令 引导启动过程 处理中断 作者的理解：地址空间切换 不同进程唯一共享内存地址空间的场合 切换地址空间是进入内核的标志 不同的进程通过共享内核地址空间来交换信息 切换地址空间是切换进程的关键步骤 Zircon主要内核态共跟你个 虚拟内存和物理内存管理 进程和线程管理 进程间通信 以内存为中心的设计 VMO代表一个内存对象，懒分配 VMO通过向channel发送handle在进程之间传递，进程拿到VOM handle，把VMP重新映射到自己的地址空间里 Unix是以文件为中心的设计 Channel 是进程间通信的唯一机制 一个channel有两个handle，h1，h2，从一头写入ixaoxi，从另一头读出消息 进程进程，有一些初始channel handle 要与一个服务建立通信，h1自己拿着，h2发送给响应的服务做监听 channel_write() 必须是一个系统调用 系统调用vDSO 微内核 性能问题 上下文切换 线程切换 Fuchsia在各个平台上的可能的优势 服务器平台，原生进程沙箱机制将带来新的安全特性和容器机制 桌面平台，无缝兼容Android 移动平台，系统的模块化方便第三方设备厂商的全面定制 Fuchsia分层 四层，后两层可以替换掉，不影响兼容性 用户体验层 应用层 内核层 系统服务层 Fuchsia 目前的运行环境 在Qemu中可以直接运行 Booloader加载到0x40080000 内核加载到0x40090000 Ramdisk加载到0x48000000 0x40000000 - 0x40080000之间是FDT flattened device tree 系统软件研发能力的获得 系统软件与应用软件不同 大量缄默知识 工具链：gcc，Id，as，clang，ELF 微处理器 周边设备UEFI，ACPI，APIC，PCIE，USB，STATA，AHCI，GPU… 知识存在与代码中，硬件标准文档内容太多 产品级的设计非常困难 总结 Fuchsia重新思考了操作系统设计的各个方面，是一次男的的从头开始的机会 在未来Fuchsia会成为一个非常重要的操作系统 世界需要新的操作系统 每一个大型软件系统都值得尊重 Windows老迈龙钟，历史负担太重，微软自己的创新Midori胎死腹中，因为无法承受在新的框架中重新实现一遍Windows的全部功能，只能在原地进行重构 Linux里大部分开发人员只关心服务器的世界，就像一个专注与在加班下面锅炉房里干活的锅炉工 MacOS，iOS封闭在苹果的硬件生态里 Android微了弥补Linux的缺点打上了一个厚厚的中间层，不断在做着妥协 GNU Hurd作为GNU项目“最后的组件”一直未能产品化，原因是“微内核消息传递机制debug态困难”？ Unix的后继者 Plan 9 与2002年发布了最后一个版本，他的余热随着作者融入了Go","link":"/2020/02/2月26日/"},{"title":"提高开发效率的秘密武器：结对编程","text":"我为我们团队的高效而感到自豪。 触宝研发总监 孟雷如是说。 《如何通过结对编程进行高质量的软件开发》的学习笔记。 了解结对编程的概念，是否符合我们的团队，具体改如何实施。 软件研发模式的演化 瀑布模型 快速原型模型 螺旋模型 敏捷开发 ？？？ 开发和测试的困境 困难 在敏捷的短周期里面实现的其实是瀑布模式 在强调交付速度的过程中，开发飞擦画那个容易急功近利，为完成手头的工作而在架构方面做很多的妥协和折中，从而为日后的维护升级买下很多隐患。 水平参差不齐，很多地方写的很山寨，后面很多问题都是给前面的疏忽买单，产品一直处于不定加不定的状态 有质量的code review没空做 代码量大了，没空仔细review 研发过程当中的团队分工角色较多，因此从上游到下游的过程中，会有很多沟通方面的损耗，团队管理消耗更多。 正确的方法 从源头提高代码质量 注重代码的框架和设计，杜绝补丁加补丁 建立标准化的设计模型和代码风格 培养功能 + 测试 + 监控 关于结对编程 两人共用一台电脑 一起设计，写代码，测试 没有专门的测试环节，完成即上线 结对编程与传统软件开发流程的主要区别 利于只是的传递 避免没有明确文档的潜规则的坑 强迫接触不熟悉的领域，有利于培养全栈 代码风格，设计思想，强一致，不存在项目移交的风险 没有单点瓶颈，不怕人员流失 结对编程最佳实施方法 两个人必须使用同一台电脑，不能两台点啊弄，坐在一起 不准带手机，写程序的人有义务监督观察者使其注意力集中 每半天或者一天轮换一次（驾驶员、领航员） 固定时间，中间休息 搭档定期更换，但必须有梯度 必须开发测试都做 使用场景，成功案例 周日程 周一 发布上一个正式版本 周二 开发测试 周三 开发测试 周四 代码冻结，公测 周五 观察，新需求 天日程 10:00 - 10:30 站会讨论 10:30 - 12:00 结对编程 1:30 - 3:00 结对编程 3:30 - 6:00 结对编程 必须遇到的问题 执行力！执行力！执行力！ 组员：想做自己的事情，我是不是在浪费时间？ Leader的顾虑：影响项目进度 两人会有性格等各方面的问题，会有争议，争吵；Leader介入参与讨论 没有测试不放心 必然要抓住的重点 确保团队成员对于业务目标以及研发流程的理解和认同 帮助团队成员摆脱固有的研发角色的分工 重点关注架构设计，模块重用 增强开发人员的自我测试意识 必须付出的代价 组员：很少有私人控件 leader：需要尽可能的带大家做靠谱的事 适用场景 偏极客分为的公司或团队 公司规模较小，但业务形态相对来说比较稳定 业务需求较多，迭代较快 有一定逻辑复杂性，需要较好的基础架构的项目 人员流动较大，缺乏系统化文档 相关数据 线上Crash率下降 完成任务数 / 人 先降后升 关于测试 美欧专门的功能测试不代表没有测试 跟单纯的功能测试说再见！ 以自动化持续继承测试作为研发的基础 注重多平台，性能测试，压力测试，耗电量测试等高级测试，以及测试工具和框架的研发 注重线上实时监控，研发，测试，监控一体化","link":"/2020/02/2月27日/"},{"title":"工程师的个人成长离不开心理学","text":"开口说，动手做，放手管。 科大讯飞研究主管 李鑫如是说。 《工程师个人成长中的若干心理学问题》的学习笔记。 心理学讲什么？ 心理咨询 搞心理咨询的都是半路出家 脑科学 用高精尖技术，测量人体和外接的反映指标，来分析人类怎么思考，更偏向与理科 组织学 研究人与人之间是怎么协作的。 工程师成长的三个时期 职场新人 - 入门期 技术你不懂… 我们领导说… 职场老人 - 平台期 这些东西都是我玩剩下的… 嗤之以鼻，高姿态 画饼对我没有用… 对画饼有免疫力 带团队 - 展业期 我们部门… 本位姿态看问题 你这也不会？… 心态：做了技术管理，是不是技术要丢掉？ 心理学与成长状态的对应 从众心态 人在社会压力下会说出明显错误的答案！避免从众：离线收集意见，会上开始讨论 人云亦云 人会顺从地服从权利者行动，且很少人会意识到这点！避免服从：当被问到，这周我要做什么 时，反问，你觉得你自己应该做什么？ 自我中心 人（特别是前运算阶段的儿童）具有自我中心主义降低自我中心：儿童 - 互相玩对方的玩具；工程师 - 轮岗，熟悉别的部门都在干什么 舒适区 走出舒适区：引入新技术时，讲清楚和现有技能的关联，和工程师个人发展的关系，给予熟悉感。 全局意识 培训基层技术管理者，使其拥有全局经营思维； 损失厌恶 面对得到时，我们考虑盈利面对损失时，我们考虑冒险要让工程师们快速行动起来，与其画饼（承诺事后奖励），不如来点实惠（先给予后评价）。 判断错误 理性化 -&gt; 情绪化资源有限 -&gt; 杀鸡用牛刀贪得无厌 -&gt; 可满足即可 鼓励机制 你期望什么，你就会得到什么 软化冲突、淡化权威、强化边界","link":"/2020/03/3月1日/"},{"title":"Activity的启动模式和标志位","text":"Activity启动模式四种：standard singleTop singleTask singleInstance standard，标准模式 标准的启动模式，每次StartActivity() 都会创建实例。注意：需要Activity对象的context，如果是Application的context，需要加一个flag，FLAG_ACTIVITY_NEW_TASK。 singleTop,栈顶复用模式 有实例在栈顶的时候才复用。 singleTask,栈内复用模式 只要栈中有实例，就会复用。自带clearTop属性ABCD-&gt;D调用singleTask属性的B-&gt;AB singleInstance,栈外复用模式（单实例模式） 会新启动一个栈，创建实例。 注意复用：调用的onNewIntent()方法。 问题singleInstance的Activity调用startActivity创建的standard属性的Activity，这个新的实例在那个栈里呢？ 标记位总结：Activity的标记位功能不确定，需要自己去测试，并且文档里的描述也是不准确的。","link":"/2016/02/Activity的启动模式和标志位/"},{"title":"Android Service在手机cpu休眠之后还会运行吗？","text":"作为Android开发者，大家都知道，在Android开发中， Service是非常常用的四大组件之一，大部分后台操作的工作都要在Service中执行，Service连接网络发送数据是很普遍的业务，但是Service在手机cpu休眠之后还会继续执行吗？连接网络发送数据正常吗？挖个坑，后续填。 date: 2017-01-31趁着过年瘫在家，来填坑啦~~~~想要分析这个问题是因为工作过程中遇到过心跳数据发送不及时的现象，测试过程中是没有遇到过的，所以怀疑是系统休眠造成的影响，下面就分析一下这种异常的原因。 测试1，服务是否会异常：后台服务定时写入日志，每隔1s写入一个Timestamp，手机静止10min查看日志文件； ### 测试2，网络是否会异常：如果测试1结果为服务运行正常，则执行测试2： 测试结果测试1结果：服务运行正常；测试2结果：网络运行异常，每1s发送一次的网络请求，在手机休眠后，变成了每5s左右发送一次。 结果分析手机休眠后，后台服务仍然在运行，但是网络CPU进入休眠状态，应用无法访问网络，网络CPU每隔一段时间被Baseband Processor（BP）唤醒一次，应用可以访问网络，然后继续进入休眠状态，依次循环。 注意手机插着数据线调试的时候，是不会进入休眠状态的。 更多资料android设备休眠PowerManagerst=>start: 创建一个Service logout=>operation: 每隔1s写入一个Timestamp到日志文件 delay=>operation: 锁屏静置手机10分钟 showlog=>condition: 检查日志是否正常 ServiceisRight=>end: 服务运行正常 ServiceisWrong=>end: 服务运行异常 st->logout->delay->showlog showlog(yes)->ServiceisRight showlog(no)->ServiceisWrong{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);st=>start: 创建一个Service logout=>operation: 每隔1s发送一个网络请求 fiddler=>operation: fiddler抓包检测网络请求 delay=>operation: 锁屏静置手机10分钟 showlog=>condition: Fiddler抓包是否正常 ServiceisRight=>end: 服务和网络正常 ServiceisWrong=>end: 服务和网络异常 st->logout->fiddler->delay->showlog showlog(yes)->ServiceisRight showlog(no)->ServiceisWrong{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-1-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-1-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-1\", options);","link":"/2016/02/Android Service在手机cpu休眠之后还会运行吗？/"},{"title":"Android Studio修改包名","text":"Android Studio修改包需要两步（资源文件访问路径一并修改）：第一步：右击要修改的包名，Refactor&gt;Rename，点击点击Rename package：然后修改，点击Refactor，然后等： 第二步：手动修改Manifest里面的package。","link":"/2016/08/Android Studio修改包名/"},{"title":"Android多渠道包生成方案学习记录(V1签名)","text":"基于V1签名方式生成渠道包方法汇总。 关于Android渠道包生成，以前写过一些小工具，集成了三种渠道包生成方案：反编译方案、美团渠道包生成方案、豌豆荚渠道包生成方案，还有一种比较有效率的打包方案是修改zip文件。 反编译方案方案简述：通过apktool等工具反编译base.apk，修改Manifest.xml中的meta-data值，重打包，签名。 特点：过程繁琐，效率低下，无需侵入Android代码。 美团渠道包生成方案方案简述：在APK中的签名文件夹META-INF中，放入空文件，名字为渠道信息，APK运行过程中读取APK源文件中的渠道信息。 特点速度快，过程简单，侵入Android代码(重)。 豌豆荚渠道包生成方案方案简述：通过Android SDK提供的AAPT命令，向apk的assert文件夹中加入有内容的渠道文件，重签名，APK运行过程中读取assert目录下的渠道文件。 特点：速度一般，过程简单，侵入Android代码(低)。 修改zip文件方案方案简述：APK是zip压缩包，末尾是zip压缩包的注释，向其中添加渠道信息，APK运行过程中读取APK源文件中的注释信息，提取出渠道信息。 特点：速度快，过程简单，侵入Android代码(重)。 以上是对四种渠道包生成方案的简介，最近发现360加固保的多渠道包生成是修改Manifest.xml中的内容，生成速度速度炒鸡快，但是生成后需要重签名。 新发现最近在使用360渠道包生成工具，生成渠道包速度非常快，而且是直接修改了Manifest.xml中的渠道号，根据这一思路我开始查APK中Manifest.xml文件导出，二进制解码，xml解析修改，Manifest.xml重编码等相关资料，后来发现，其它过程都没问题，只有Manifest.xml重编码没有相关资料，又查了几天，发现自己进入了一个误区，为什么要把Manifest.xml二进制解码再编码？，直接修改二进制文件不就好了，然后查到了这个项目：（apkeditor）AndroidManifest.xml二进制编辑和签名工具，学习了Manifest.xml二进制文件的参数替换和修改等技巧。 这种Manifest.xml二进制数据替换方案，从打包效率上说比不上美团方案和ZIP注释方案，但是贵在直接修改Manifest.xml中meta-data的数据，不侵入Android代码，最大化兼容了第三方平台渠道号的读取（极光推送只支持从Manifest中读取渠道，不支持动态设置）。","link":"/2017/06/Android多渠道包生成方案学习记录(V1签名)/"},{"title":"自定义数据结构排序（字符串排序）","text":"在很多情况下，我们都会用到对自定义数据结构的排序，而最多的实际排序依据是对字符串的排序。 举个例子：联系人排序，contacts是一个我们自己定义的数据结构，里面有两个参数，name和tel，我们要根据name的拼音排序，首先要把汉字转成拼音，然后根据拼音进行排序。 第一步： 汉字转拼音资料（第二种方法貌似对”亳州”的”亳”识别有误）：java程序将汉字转成拼音的两种方法 第二步： 根据拼音对数据结构排序首先需要给数据结构制作一个比较的工具类： 1234567891011121314public class PinyinComparator implements Comparator&lt;ContactsEntry&gt; { public int compare(ContactsEntry o1, ContactsEntry o2) { if (o1.getSort_key().equals(&quot;@&quot;) || o2.getSort_key().equals(&quot;#&quot;)) { return -1; } else if (o1.getSort_key().equals(&quot;#&quot;) || o2.getSort_key().equals(&quot;@&quot;)) { return 1; } else { return o1.getSort_key().compareTo(o2.getSort_key()); } }} 然后通过Collections的sort方法来排序： 1Collections.sort(mCities, mComparator); 这样mCities里面的数据就根据PinyinComparator的排序规则排序了。","link":"/2016/03/Android字符串排序/"},{"title":"奇葩问题的记录","text":"记录一些平时开发中遇到的奇葩问题。😄 1.字符串空格替换问题今天遇到一个替换空格的问题，但是无论怎么替换都替换不掉，一打印log，还是在。后来看了一下这个字符串的组成，原来这不是空格啊，竟然是”&amp;#160;“，查了一下，虽然这个符号会显示成空格，但是直接replaceAll(&quot; &quot;,&quot;&quot;);是无法去掉的，如果位置固定，可以根据位置去掉。资料 2.back stack拼接问题singleTask和singleInstance启动的activity，尽管可能不在同一个task，但是仍然会回到原来的activity；但是singleTask可能会存在back stack“拼接”的情况。如图所示： 3.singleLine弃用了，用什么代替呢？1，singleLine弃用了，但是setSingleLine()方法并没有弃用。2，可以看一下setSingleLine()方法都做了什么，可以看出用下面两个属性也能完成singleLine同样的效果：12android:lines=\"1\"android:scrollHorizontally=\"true\" 4，”/“反斜杠替换问题-2016年04月26日需求：在一段内容中，把输入框中用户输入的字符，按照全部匹配的原则，替换成红色。我的处理方式是： 1String title = content.replaceAll(mKeys, \"&lt;font color=\\\"#f84746\\\"&gt;\" + mKeys + \"&lt;/font&gt;\"); 但是当用户输入的有”/“的时候，就出现了错误：java.util.regex.PatternSyntaxException: Unrecognized backslash escape sequence in pattern near index 1:\\^。原因是：在java中”\\”（反斜杠）是转义符号，所以反斜杠后面没有东西的话是不对的，所以，在java中反斜杠要表示成”\\\\“;另外，replaceAll方法实现原理使用了”regex”（正则表达式），在regex中同样要用”\\\\“来代表”\\”，所以上面的代码应该写成这样： 12String re = mKeys.replaceAll(\"\\\\\\\\\",\"\\\\\\\\\\\\\\\\\");String title = content.replaceAll(re, \"&lt;font color=\\\"#f84746\\\"&gt;\" + mKeys + \"&lt;/font&gt;\"); 这样就没问题了，特此记录。 参考资料 5，tab切换后界面自动上跳是什么鬼？-2016年06月13日初始化第一个tab之后是这样的：但是切换到第二个再切回来，就变成这样婶儿的了：是焦点问题，但是具体原理还没搞懂,解决方法是在最外层布局文件中增加如下两行代码：12android:focusableInTouchMode=\"true\"android:focusable=\"true\" 6，TextView自带上下Padding导致高度计算不准确的问题-2016年06月29日TextView默认上下自带Padding的，所以根据TextView的sp计算文字高度是不准确的，所以要计算TextView高度需要去掉上下的Padding,方式就是在TextView中添加如下属性：1android:includeFontPadding=\"false\" 或者：1textview.setIncludeFontPadding(false); 这样去掉上下的padding就可以直接用sp来计算TextView的高度了。 没有解决的疑问 1.activity启动模式由于singleTask和singleInstance都可能启动另外一个task，那如果在这个新task里的activity启动一个standard的activity，是继续在新task里面继续压栈吗？ 2.EditText无内容时，光标和hint的位置这个问题很简单，我们只要修改EditText的gravity属性就好，left的话光标就在hint左边，right的话光标就在hint右边，center的话光标就在hint中间，但是今天试了一下，gravity无论是什么参数都无法生效，总是居右。。。暂未解决。 3.PullToRefresh动画卡住不动的bug今天修改PullToRefresh动画，但是发现一个现象，刷新的时候动画会卡住不动。。。","link":"/2016/08/Android开发奇葩问题记录/"},{"title":"Android通过包名启动任意APP","text":"123456789101112131415 /* * 启动一个app * QQ的包名：\"com.tencent.mobileqq\" * 支付宝包名： */ public static boolean openAppWithPackageName(Activity activity,String appPackageName){ try{ Intent intent = activity.getPackageManager().getLaunchIntentForPackage(appPackageName); activity.startActivity(intent); return true; }catch(Exception e){ return false; } }","link":"/2016/08/Android通过包名启动任意APP/"},{"title":"Android资源文件混淆思路解析","text":"挖坑。","link":"/2016/12/Android资源文件混淆思路解析/"},{"title":"Application的label和Activity的label","text":"近日需求，要根据渠道修改应用的名称，涉及到了在Manifest中的label属性了，特此记录。label属性在两个地方都有，Application、Activity，Activity的优先级高于Application，也就是说两者都设置这个标签的话，Activity的值覆盖Application。 对于app名字，优先级最高的是主Activity的label，其次是Application的label。","link":"/2016/04/Application的label和Activity的label/"},{"title":"BaseActivity封装技巧","text":"在项目的开发中，一般都是要封装一个BaseActivity来做一些常用的动作的，下面就是我在项目中用到的一些简单封装。 1，统计在BaseActivity的生命周期中调用统计部分的代码，这样可以省去在不同的界面重复编写统计代码的工作。 1234567891011@Overridepublic void onResume() { super.onResume(); AnalyticsHelper.getInstance().onResume(this);} @Overrideprotected void onPause() { super.onPause(); AnalyticsHelper.getInstance().onPause(this);} 2，ProgressDialog配置一个通用的ProgressDialog是非常有用的，这样在接口请求的时候，直接调用显示，数据返回后调用消失，超级爽！！！ 1234567891011121314151617181920//显示ProgressDialog public ProgressDialog progressDialog; public void showProgressDialog() { if (progressDialog == null) { progressDialog = new ProgressDialog(this); progressDialog.show(); } else { if (!progressDialog.isShowing()) { progressDialog.show(); } } } //隐藏ProgressDialog public void cancelProgressDialog() { if (progressDialog != null &amp;&amp; progressDialog.isShowing()) { progressDialog.dismiss(); } } 注意：要在OnDestory()中调用cancelProgressDialog()一下，防止Activity has leaked window错误。 4，全局handler如果习惯用Thread+Handler来异步操作数据并刷新界面的话，每个界面都定义一遍Handler对象是非常烦人的，所以可以在BaseActivity中定义一个Handler对象，快捷又方便。 123456789101112131415161718public Handler mHandler = new Handler(){ @Override public void handleMessage(Message msg) { HandleMessage(msg); }};/** * 复写来处理mHandler发来的消息 * @param msg */public void HandleMessage(Message msg){};@Overrideprotected void onDestroy() { mHandler.removeCallbacksAndMessages(null); super.onDestroy();} 注意：要在OnDestory()中调用mHandler.removeCallbacksAndMessages()方法，否则会出现handler内存泄露问题。 5，全局的观察者模式未完待续","link":"/2016/08/BaseActivity封装技巧/"},{"title":"H5调用原生APP拍照","text":"解决H5调用APP原生拍照的功能实现和兼容性问题。一句话总结：Android的话，自定义&lt;input&gt;标签的accept属性，触发后原生做拍照操作，完成后把图片的Uri返给&lt;input&gt;标签即可； iOS的话，JSBridge即可。详情见JS与OC互调，JS打开系统相机，JS获取iOS系统图片，iOS中JS调OC 重点： 为了安全，H5不能通过真实路径访问手机的任何资源，解决方式是Android端用&lt;input&gt;标签的沙盒机制；iOS的每个APP默认一个沙盒，WebView里面的H5可以访问到这个沙盒里面的资源，所以iOS获取到图片后保存到自己的沙盒里，沙盒路径用JSBridge扔给H5。","link":"/2016/09/H5调用原生APP拍照/"},{"title":"EditText的输入限制(InputType、digits)","text":"最近做了不少输入框，有储蓄卡卡号、信用卡卡号、验证码、用户名等，需要对每个输入框都做不同的输入限制，下面记录了常用的几种输入限制方式，以供以后参考。 方法一：InputTypeInputType属性可以限制输入框需要显示何种键盘模式，可以输入哪些字符，下面是各个参数对应的类型： 1234567891011121314151617181920212223242526272829android:inputType=\"none\"--输入普通字符android:inputType=\"text\"--输入普通字符 android:inputType=\"textCapCharacters\"--输入普通字符 android:inputType=\"textCapWords\"--单词首字母大小 android:inputType=\"textCapSentences\"--仅第一个字母大小 android:inputType=\"textAutoCorrect\"--前两个自动完成 android:inputType=\"textAutoComplete\"--前两个自动完成 android:inputType=\"textMultiLine\"--多行输入 android:inputType=\"textImeMultiLine\"--输入法多行（不一定支持） android:inputType=\"textNoSuggestions\"--不提示 android:inputType=\"textUri\"--URI格式android:inputType=\"textEmailAddress\"--电子邮件地址格式android:inputType=\"textEmailSubject\"--邮件主题格式android:inputType=\"textShortMessage\"--短消息格式android:inputType=\"textLongMessage\"--长消息格式android:inputType=\"textPersonName\"--人名格式android:inputType=\"textPostalAddress\"--邮政格式android:inputType=\"textPassword\"--密码格式android:inputType=\"textVisiblePassword\"--密码可见格式android:inputType=\"textWebEditText\"--作为网页表单的文本格式android:inputType=\"textFilter\"--文本筛选格式android:inputType=\"textPhonetic\"--拼音输入格式android:inputType=\"number\"--数字格式 数字键盘android:inputType=\"numberSigned\"--有符号数字格式 数字键盘android:inputType=\"numberDecimal\"--可以带小数点的浮点格式 数字键盘android:inputType=\"phone\"--拨号键盘 android:inputType=\"datetime\"android:inputType=\"date\"--日期键盘android:inputType=\"time\"--时间键盘 摘自android:inputType参数类型说明 方法二：digits使用方法：1.在xml文件中设置digits参数： 1android:digits=\"0123456789 \" 通过xml文件设置digits的参数来控制这个EditText可以输入那些字符，但是无法控制键盘模式。2.代码中动态设置KeyListener： 123456789101112nameEdi.setKeyListener(new NumberKeyListener() { @Override protected char[] getAcceptedChars() { char[] numberChars = {'1','2','3','4','5','6','7','8','9','0',' '}; return numberChars; } @Override public int getInputType() { return InputType.TYPE_CLASS_NUMBER; }}); 这种方式可以同时设置InputType，而且在代码里面动态控制，更加灵活。 EditText继承自TextView，同样这两个属性也是继承自TextView，所以InputType和digits同样可以用在TextView和所有继承自TextView的控件上面。","link":"/2016/03/EditText的输入限制(InputType、digits)/"},{"title":"Compilation is not supported for following modules:app","text":"Unsupported Modules Detected:Compilation is not supported for following modules:app. Unfortunately you can't have non-Gradle Java modules and Android-Gradle modules in one project.如果出现上面的提示，并且as代码检测通不过，但是编译可以通过，一般是由于as升级造成的，升级后打开旧的项目就会出现这样的问题，解决方法是：File -&gt; Invalidate Caches / Restart -&gt; Invalidate Caches &amp; Restart. 通过上面的方法as代码检测确实通过了，编译也没问题，但是还是有如题的提示，但是正常使用没问题了，问题保留。 资料","link":"/2016/02/Unsupported Modules Detected/"},{"title":"View的事件分发机制","text":"View的事件分发机制是非常核心的一个知识点，可以解决滑动冲突等很多棘手的问题，所以在这里梳理一下。1. View的事件分发机制2. 一些Listener的优先级 1. View的事件分发机制1）处理触摸事件会涉及到的三个类：Activity、ViewGroup、View，这三个类之间的事件传递顺序是：Activity–&gt;ViewGroup(rootView)–&gt;ViewGroup–&gt; . . . –&gt;View2）三个类各自的事件分发方法：Activity ：dispatchTouchEvent()、onTouchEvent() Activity没有onInterceptTouchEvent()方法，无法拦截触摸事件，但是我们可以通过重写dispatchTouchEvent()方法进行整个Activity层面的触摸事件拦截。 View ： dispatchTouchEvent()、onTouchEvent() View也没有onInterceptTouchEvent()方法，因为如果不是ViewGroup的话已经是最后一层了，所以不需要拦截。 ViewGroup ： dispatchTouchEvent()、onTouchEvent()、onInterceptTouchEvent() ViewGroup继承自View，实现了onInterceptTouchEvent()方法，默认返回false，也就是ViewGroup默认不拦截任何触摸事件。 事件分发三方法的关系在点击屏幕的时候最先获取到点击事件的是当前的Activity，Activity的事件分发最终是调用所属的Window进行分发的，Window将事件分发给根ViewGroup，这样就开始了经典的事件分发流程。下面的伪代码精确的表现出了事件分发的三个方法之间的关系： 12345678910111213public boolean dispatchTouchEvent(MotionEvent e){ boolean consume = false; if(onInterceptTouchEvent(e)){ consume = onTouchEvent(e); }else{ if(hasChild()){ consume = child.dispathTouchEvent(e); }else{ consume = onTouchEvent(e); } } return consume;} 配合下图食用。 由于最底层的View没有onInterceptTouchEvent()方法，所以View的dispatchTouchEvent()方法中会直接执行onTouchEvent()方法，默认返回值false，如果这个View对象没有重写ontouchEvent()方法，也没有设置一些点击事件，那么这个View的dispatchTouchEvent()方法就会返回false。 2. 一些Listener的优先级上面事件分发之后总归是要有View的事件来处理这个操作的，那么View的处理事件是在哪里调用的呢？ 答：假如view获得了触摸事件，要处理这个事件，调用的顺序可以在View源码的dispatchTouchEvent()方法里面看出： 12345678910111213141516171819 public boolean dispatchTouchEvent(MotionEvent event) {... if (onFilterTouchEventForSecurity(event)) { //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnTouchListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result &amp;&amp; onTouchEvent(event)) { result = true; } } ... return result; } 先判断是否设置了mOntouchListener，如果设置了，执行mOntouchListener.ouTouch()方法，如果返回true，则不执行下面的onTouchEvent()了，也就是说mOntouchListener的优先级高于onTouchEvent()。 咦，不对啊，我的onClickListener()跑哪里去了？ 通过查看View的源码我们发现，onClickListener()方法的调用是在一个performClick()的方法里面，这个方法在onTouchEvent()的MotionEvent.ACTION_UP下调用了，所以onClickListener()方法的优先级最低。 结论：onTouchListener() &gt; onTouchEvent() &gt; onClickListener() 注意：setOnClickListener()方法会调用setClickable(true)方法，会覆盖掉原来的Clickable属性。","link":"/2016/04/View的事件分发机制/"},{"title":"Windows查询进程PID，关闭进程","text":"背景近日在做网页模拟才做的业务，最初想到的方案是按键精灵，无奈这玩意对网页端的操作支持不太好，所以想到用Web端的自动化测试框架Selenium来实现需求，Selenium驱动Chrome浏览器需要官网下载的驱动，但是程序异常退出后，驱动进程依然存在，所以在程序下一次启动的时候，检测驱动进程是否存在，如果存在，全都kill掉，再进行正常的业务流程。 根据进程名字查询PID1tasklist /nh /FI &quot;IMAGENAME eq &lt;taskName&gt;&quot; 关闭进程1234// 根据名字关闭进程taskkill /F /IM &lt;taskName&gt;// 根据PID关闭进程taskkill /F /PID &lt;taskPid&gt;","link":"/2017/03/Windows查询进程PID，关闭进程/"},{"title":"c语言学习笔记之执行shell命令","text":"为了方便，在bash增加了一个路径，放自己写的一些shell脚本，但是terminal执行的时候，后面总是有.sh后缀名，感觉怪怪的，现在学习c语言，发现编译后的可执行文件没有后缀名，可以直接执行，所以把shell脚本换成了c语言写的可执行程序，具体替换示例如下： activity.sh12cd /Users/lipeng/hexohexo g -d activity.c123456#include &lt;stdlib.h&gt;int main(){ system(\"cd /Users/lipeng/hexo &amp;&amp; hexo g -d\");}","link":"/2017/01/c语言学习笔记之执行shell命令/"},{"title":"Data Binding文档翻译","text":"       本文档讲解了怎样使用Data Binding库来声明布局，并且减少应用程序逻辑和布局所需的耦合代码，这在开发中是非常必要的。       Data Binding库是一个引用库，兼容性非常好，适配了Android 2.1以上（API level 7+）的所有版本。        使用Data Binding的话，Gradle 版本需要在1.5.0-alpha1及以上。 一、编译环境使用Data Binding之前，需要先在Android SDK Manager的中下载Data Binding库。 然后在build.gradle中加入dataBinding的配置。 用下面的代码配置Data Binding: 123456android { .... dataBinding { enabled = true }} 如果你的Module中已经有一个library引用了Data Binding，你的主项目的build.gradle中仍然需要配置一下。 然后确认一下Android Studio版本是否支持，Android Studio 1.3及以上都支持data binding，描述文档。 二、Data Binding 布局文件马上来编写你的第一个data binding程序吧！data binding的布局文件和原先xml写的布局文件有略微不同，首先要在根布局下面绑定一个data元素，这个视图元素是在非绑定布局文件中的基本元素(好拗口~)。例子如下： 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; user变量是在数据中描述了，可以用在布局文件中。 1&lt;variable name=&quot;user&quot; type=&quot;com.example.User&quot;/&gt; 在布局的属性中的语法是”@{}“，然后这个TextView的text属性就被user的fitstName字段赋值了。 123&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@{user.firstName}&quot;/&gt; 三、数据结构现在我们假定，你有一个纯java对象（POJO），User： 12345678public class User { public final String firstName; public final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; }} 这个类型的对象含有永不变化的数据，在程序中，一次读取，后来从不改变的现象，在程序中很常见，另外也可以使用一个javabean对象： 1234567891011121314public class User { private final String firstName; private final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; }} 从data binding的角度出发，这两个类是相当的，在给一个android:text属性用@{user.firstName}这种写法赋值的时候，在前一个类里面被理解为firstName字段，在后一个类里面被理解为getFirstName()方法，或者也有可能被理解为firstName()方法，如果存在的话。 绑定数据一个数据绑定的类默认会依据layout文件的名字来创建， (未完待续)","link":"/2016/05/data_binding文档/"},{"title":"OSChina绑定公钥—MAC","text":"暂时只做了Mac绑定OSChina公钥的小教程，Windows的大家自己百度吧 ^_^ 1，生成本地公钥输入一下命令（邮箱修改成自己的 ^_^ ）： 1ssh-keygen -t rsa -f ~/.ssh/loanByWeex.osc -C \"your_email@youremail.com\" 然后按两次回车。 说明： -t后面的参数是数字签名算法方式，在这里一般使用dsa或者rsa方式，默认dsa(但是我个人习惯使用rsa方式^_^)； -f后面的参数是保存密钥的文件，可以根据项目名字和平台来自定义； 命令执行成功后，会生成两个文件，一个密钥和一个公钥，密钥的名字是loanByWeex.osc，公钥的名字是loanByWeex.osc.pub，这两个文件是对应的，密钥放在本地，公钥用于绑定git服务器。 2，将公钥上传到OSChina平台查看一下刚才生成的的公钥： 1cat ~/.ssh/loanByWeex.osc.pub 我的公钥截图如下： 复制公钥内容到OSChina的SSH公钥添加界面： 添加成功后，即可在自己的电脑上使·git clone命令克隆咱们的代码仓库了~O(∩_∩)O~","link":"/2016/11/oschina绑定公钥/"},{"title":"undefined reference to `__android_log_print'解决方法","text":"大家最初学习NDK开发的时候，写过的第一个.c文件内容应该都非常类似，如下：123456789101112131415161718#include \"hello-jni.h\"#include &lt;jni.h&gt;#include &lt;stdio.h&gt;#include &lt;android/log.h&gt;#define TAG \"hello-jni\" // 这个是自定义的LOG的标识#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG,TAG ,__VA_ARGS__)// 定义LOGD类型#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG ,__VA_ARGS__)// 定义LOGI类型#define LOGW(...) __android_log_print(ANDROID_LOG_WARN,TAG ,__VA_ARGS__)// 定义LOGW类型#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG ,__VA_ARGS__)// 定义LOGE类型#define LOGF(...) __android_log_print(ANDROID_LOG_FATAL,TAG ,__VA_ARGS__)// 定义LOGF类型jstring Java_jnitest_xhmsmd_top_hello_1jni_MainActivity_getKey(JNIEnv* env, jobject thiz){ LOGD(\"hello,jni\"); return (*env)-&gt;NewStringUTF(env,\"hello jni\");} 这个.c文件的代码看起来是没有任何问题的，但是大多数人，一运行，就会爆出如下错误：123/Users/lipeng/android_workspace/hello_jni/app/src/main/jni/hello-jni.cError:(20) undefined reference to `__android_log_print'Error:error: ld returned 1 exit status 网上查到的资料绝大部分都是让在Android.mk文件中增加LOCAL_LDLIBS := -lm -llog类似的解决方案，而且很多人也确实用这种方式解决了这个问题，但是我用了这个方式，并没有效果。 最终在StackOverFlow查到了另外一种解决方法：1234ndk { moduleName \"hello-jni\" ldLibs \"log\"} 这种方法解决了我这边的问题，看代码解决方式是引入log库，但是.c文件中已经引入了android/log.h，不知道为什么还要在Android.mk文件或者gradle配置文件中再引入的lib。","link":"/2017/01/undefined reference to `__android_log_print'解决方法/"},{"title":"WebView的奇怪现象","text":"最近做项目发现WebView有一些奇奇怪怪的现象，在这里记录下。 一、Android版本4.4及一下，默认情况下”_blank”打开新标签页异常H5通过_blank标签打开新标签页的时候，Android5.0及以上会在当前页面直接load这个url，但是Android版本4.4及一下，则会在当前的标签里面加载这个新页面！查了下资料，发现了能统一的办法。第一步：设置WebSetting的setSupportMultipleWindows(true)：12// 告诉webkit：你问我多窗口滋不滋次啊，我当然是滋次的！webSettings.setSupportMultipleWindows(true); 第二步：在WebChromeClient中监听onCreateWindow()方法，判断参数符合条件就拦截并获取到打开新页面的url，让当前页面加载，要注意的事，点击页面链接，也属于打开心标签，在这里也会被拦截的：1234567891011121314151617181920// 我不但要拦住你的去路(return true)，还要抢你的钱(url),你把钱塞裤裆里也给你掏出来(获取url方式比较淫秽呸隐晦) public boolean onCreateWindow(final WebView webView, boolean isDialog, boolean isUserGesture, Message resultMsg) { // 打开_blank创建新标签和点击链接都会触发 add by xiaohongmao 2016/11/15 下午2:41 if(null != webView &amp;&amp; !isDialog &amp;&amp; isUserGesture &amp;&amp; null != resultMsg &amp;&amp; null != resultMsg.obj){ WebView newWebView = new WebView(webView.getContext()); newWebView.setWebViewClient(new WebViewClient() { @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { webView.loadUrl(url); return true; } }); WebView.WebViewTransport transport = (WebView.WebViewTransport) resultMsg.obj; transport.setWebView(newWebView); resultMsg.sendToTarget(); return true; } return super.onCreateWindow(webView, isDialog, isUserGesture, resultMsg); }","link":"/2016/12/不同Android版本的WebView的奇怪现象/"},{"title":"习惯性妥协","text":"患有习惯性妥协的疾病，且不自知。 团队工作，很多时候会出现观点分歧，解决方式是其中一方的妥协，但势均力敌的分歧观点，某一方却一而再、再而三的妥协，那么就暴露问题了。","link":"/2016/10/习惯性妥协/"},{"title":"使用scp命令向vps传输文件","text":"自己写了一个java servlet的小服务端程序，用app访问，在家里局域网没问题，但是公司路由设置问题，局域网相互ping不到，所以只能把这小程序放在我个人的vps上跑了，所以过程中用到了scp指令传输文件，在这里记录一下。scp -P port filepath vps_username@vps_ip:vps_filepath time: 2017-02-03 11:08:54如果文件太大，可以尝试用压缩压缩后传输的方式，在端口后面增加-C：scp -P port -C filepath vps_username@vps_ip:vps_filepath","link":"/2017/02/使用scp命令向vps传输文件/"},{"title":"关于安卓的时间获取和转换","text":"最近做了个日历相关的需求，发现了不少关于时间获取和转换的问题，特此记录。 目录根据年月日获取时间戳 ​ Time ​ Calendar 一：根据年月日获取时间戳常用的有两种方式，一种是用Time，一种是用Calendar，代码如下： Time:123456Time time = new Time(\"GMT+8\");time.setToNow();int year = time.year; // 年int month = time.month; // 月int day = time.monthDay; // 日int timeStemp = time.toMillis(true); // 时间戳（忽略夏令时） Calendar:123456Calendar calendar = Calendar.getInstance();calendar.setTimeZone(TimeZone.getTimeZone(\"GMT+8\")); // 设置时区无效calendar.getTimeInMillis();calendar.getTime().getYear();calendar.getTime().getMonth();calendar.getTime().getDay(); 要注意的时，Calendar对象设置时区后，获得到的时间戳还是标准时间。","link":"/2016/08/关于安卓的时间获取和转换/"},{"title":"绕过Manifest对Activity注册检测启动","text":"挖坑。","link":"/2016/12/绕过Manifest对Activity注册检测启动Activity/"},{"title":"我有特殊的开发技巧","text":"本文记录本思密达开发中用到的一些方便高效的小技巧。1，使用Fiddler进行接口断点调试断点命令如下：1234bpu，在请求开始时中断,可以修改request参数；bpafter，在响应到达时中断,可以修改response数据；bps在特定http状态码时中断；(没有测试)bpv/bpm在特定请求method时中断。（没有测试） 举两个例子：bpu http://xhmsmd.com，监听到http://xhmsmd.com请求要发出前，拦截并进入调试模式。bpafter http://xhmsmd.com，监听到http://xhmsmd.com请求返回数据后，拦截并进入调试模式。 清除断点的命令是只输入头命令，例如bpu http://xhmsmd.com的清除命令就是bpu。","link":"/2016/08/我有特殊的开发技巧/"},{"title":"WebView的优化总结","text":"在工作中很多地方都使用到了WebView，尤其是现在这个hybird app盛行的时代，所以WebView的优化也显得尤为重要了。 目录性能优化界面优化业务逻辑优化bug总结相关扩展 正文 一 性能优化1. 图片加载逻辑WebView下载完html代码后开始解析，过程中发现外部的js、css和图片，会异步发出网络请求，网络状况不好的情况下，会影响js和css文件加载完的时间，造成页面空白loading过久，解决方法是先不加载图片，等页面装载完毕，再加载图片。在WebView初始化时设置如下代码： 1234567public void int () { if(Build.VERSION.SDK_INT &gt;= 19) { webView.getSettings().setLoadsImagesAutomatically(true); } else { webView.getSettings().setLoadsImagesAutomatically(false); }} 同时在WebView的WebViewClient实例中的onPageFinished()方法添加如下代码： 123456@Overridepublic void onPageFinished(WebView view, String url) { if(!webView.getSettings().getLoadsImagesAutomatically()) { webView.getSettings().setLoadsImagesAutomatically(true); }} 从上面的代码，可以看出我们对系统API在19以上的版本作了兼容。因为4.4以上系统在onPageFinished时再恢复图片加载时,如果存在多张图片引用的是相同的src时，会只有一个image标签得到加载，因而对于这样的系统我们就先直接加载。(博主暂时没有测试更高版本) 2. 远程网页需访问本地资源WebView加载的网页访问本地资源可以节省Web的加载时间，实现的方法有两种。第一种：重写shouldInterceptRequest(WebView view,String url)方法，监听url，如果url里加载的是本地有的图片，就直接返回图片资源，代码如下： 12345678910111213141516171819@Overridepublic WebResourceResponse shouldInterceptRequest(WebView view,String url) { try { if (url.endsWith(\"icon.png\")) { InputStream is = appRm.getInputStream(R.drawable.icon); WebResourceResponse response = new WebResourceResponse(\"image/png\", \"utf-8\", is); return response; } else if (url.endsWith(\"jquery.min.js\")) { InputStream is = appRm.getInputStream(R.raw.jquery_min_js); WebResourceResponse response = new WebResourceResponse(\"text/javascript\", \"utf-8\", is); return response; } } catch (IOException e) { e.printStackTrace(); } return super.shouldInterceptRequest(view, url);} 第二种：主动发网络请求获取html代码，然后WebView调用loadDataWithBaseURL()方法，把html代码穿进去，这样就可以在html代码里使用file:///android_asset/xxx.png的链接来引用包里面assets下的资源了。示例如下： 1234567891011121314151617181920212223242526private void loadWithAccessLocal(final String htmlUrl) { new Thread(new Runnable() { public void run() { try { final String htmlStr = NetService.fetchHtml(htmlUrl); if (htmlStr != null) { TaskExecutor.runTaskOnUiThread(new Runnable() { @Override public void run() { loadDataWithBaseURL(htmlUrl, htmlStr, \"text/html\", \"UTF-8\", \"\"); } }); return; } } catch (Exception e) { Log.e(\"Exception:\" + e.getMessage()); } TaskExecutor.runTaskOnUiThread(new Runnable() { @Override public void run() { onPageLoadedError(-1, \"fetch html failed\"); } }); } }).start();} 3. WebView缓存开启WebView的缓存功能可以减少对服务器资源的请求，一般使用默认缓存策略就可以了。 1234//设置 缓存模式webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT); // 开启 DOM storage API 功能webView.getSettings().setDomStorageEnabled(true); 4. 使用小技巧展示webview的activity可以另开一个进程，这样就能和我们app的主进程分开了，即使webview产生了oom崩溃等问题也不会影响到主程序，如何实现呢，其实很简单，在androidmanifest.xml的activity标签里加上android:process=”packagename.web”就可以了。 二 界面优化1. 自定义error界面当WebView加载页面出错时（一般为404 NOT FOUND），安卓WebView会默认显示一个卖萌的出错界面。但我们怎么能让用户发现原来我使用的是网页应用呢，我们期望的是用户在网页上得到是如原生般应用的体验，那就先要从干掉这个默认出错页面开始。当WebView加载出错时，我们会在WebViewClient实例中的onReceivedError()方法接收到错误，我们就在这里做些手脚： 12345678@Overridepublic void onReceivedError (WebView view, int errorCode, String description, String failingUrl) { super.onReceivedError(view, errorCode, description, failingUrl); //清除掉默认错误页内容 loadDataWithBaseURL(null, \"\", \"text/html\", \"utf-8\", null); //让我们自定义的View得到显示 mErrorFrame.setVisibility(View.VISIBLE);} mErrorFrame为蒙在WebView之上的一个LinearLayout布局，默认为View.GONE。 2. 避免加载前白色页面怎么让用户看不到WebView加载前的白色页面呢？首次加载后页面的跳转可以用上面的步骤进行优化，可以提供给用户一个很好的体验，那加载的第一页呢？我们需要WebView预加载页面，这个该怎么做到的呢？下面提供两种方法: 1，ViewPager，将欢迎页面与WebView页面一起放进ViewPager中，设置预加载页面个数，使WebView所在页面可以预加载，在加载完毕的时候切换到WebView所在页面。2，FrameLayout，将欢迎页面与WebView页面的布局合在一起，显示在一个页面内，起始隐藏WebView布局，待WebView加载完毕，隐藏欢迎布局，显示WebView布局。 使用FrameLayout简单一些，两种方法都是需要对WebChromeClient的onProgressChanged进行监听，加载完毕进行页面切换，如下： 123456789webView.setWebChromeClient(new WebChromeClient() { @Override public void onProgressChanged(WebView view, int newProgress) { super.onProgressChanged(view, newProgress); if (newProgress &gt;= 100) { // 切换页面 } } }); 三 业务逻辑优化1. 滑动逻辑判断①是否存在滚动条当我们做类似上拉加载下一页这样的功能的时候，页面初始的时候需要知道当前WebView是否存在纵向滚动条，如果有则不加载下一页，如果没有则加载下一页直到其出现纵向滚动条。首先继承WebView类，在子类添加下面的代码： 123public boolean existVerticalScrollbar () { return computeVerticalScrollRange() &gt; computeVerticalScrollExtent();} computeVerticalScrollRange得到的是可滑动的最大高度，computeVerticalScrollExtent得到的是滚动把手自身的高，当不存在滚动条时，两者的值是相等的。当有滚动条时前者一定是大于后者的。 ②是否已滚动到页面底部同样我们在做上拉加载下一页这样的功能时，也需要知道当前页面滚动条所处的状态，如果快到底部，则要发起网络请求数据更新网页。同样继承WebView类，在子类覆盖onScrollChanged方法，具体如下： 123456789101112@Overrideprotected void onScrollChanged(int newX, int newY, int oldX, int oldY) { super.onScrollChanged(newX, newY, oldX, oldY); if (newY != oldY) { float contentHeight = getContentHeight() * getScale(); // 当前内容高度下从未触发过, 浏览器存在滚动条且滑动到将抵底部位置 if (mCurrContentHeight != contentHeight &amp;&amp; newY &gt; 0 &amp;&amp; contentHeight &lt;= newY + getHeight() + mThreshold) { // TODO Something... mCurrContentHeight = contentHeight; } }} 上面mCurrContentHeight用于记录上次触发时的网页高度，用来防止在网页总高度未发生变化而目标区域发生连续滚动时会多次触发TODO，mThreshold是一个阈值，当页面底部距离滚动条底部的高度差&lt;=这个值时会触发TODO。 2. activity被动被杀之后，能够保存webview状态进一步的优化，activity被动被杀之后，最好能够保存webview状态，这样用户下次打开时就看到之前的状态了，嗯，就这么干，webview支持saveState(bundle)和restoreState(bundle)方法，所以就简单了，哈哈，看看代码吧：保存： 123456 @Overrideprotected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); wv.saveState(outState); Log.e(TAG, \"save state...\");} 恢复，在onCreate()中调用： 123456 if(null!=savedInstanceState){ wv.restoreState(savedInstanceState); Log.i(TAG, \"restore state\");}else{ wv.loadUrl(\"http://3g.cn\");} bug总结ViewPager里非首屏WebView点击事件不响应如果你的多个WebView是放在ViewPager里一个个加载出来的，那么就会遇到这样的问题。ViewPager首屏WebView的创建是在前台，点击时没有问题；而其他非首屏的WebView是在后台创建，滑动到它后点击页面会出现如下错误日志：120955-20968/xx.xxx.xxx E/webcoreglue﹕ Should not happen: no rect-based-test nodes found 解决这个问题的办法是继承WebView类，在子类覆盖onTouchEvent方法，填入如下代码： 12345678@Overridepublic boolean onTouchEvent(MotionEvent ev) {if (ev.getAction() == MotionEvent.ACTION_DOWN) { onScrollChanged(getScrollX(), getScrollY(), getScrollX(), getScrollY());}return super.onTouchEvent(ev);} WebView硬件加速导致页面渲染闪烁4.0以上的系统我们开启硬件加速后，WebView渲染页面更加快速，拖动也更加顺滑。但有个副作用就是，当WebView视图被整体遮住一块，然后突然恢复时（比如使用SlideMenu将WebView从侧边滑出来时），这个过渡期会出现白块同时界面闪烁。解决这个问题的方法是在过渡期前将WebView的硬件加速临时关闭，过渡期后再开启，代码如下：1234if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) {//关闭硬件加速webview.setLayerType(View.LAYER_TYPE_SOFTWARE, null);} 避免addJavaScriptInterface带来的安全问题使用开源项目Safe Java-JS WebView Bridge可以很好替代addJavaScriptInterface方法，同时增加了异步回调等支持，并且不存在了安全风险。 WebView与上层父元素的TouchMove事件冲突WebView进入后台依旧占用CPU的解决WebView Memory Leak WebView内存泄漏 扩展1、在WebView中尽可能不要使用GIFs、Marquee、Blink等动画和渲染效果Marquee不要用，有四个以上页面会好卡，如果的确需要使用可以用程序写，JQUERY中应该有现成的。2、Gif可以用但不要太多，页面加载状态的控制可以用一下，其他的不要考虑，当然GIF不显示出来，也不会占用CPU。 参考资料：Android WebView开发问题及优化汇总 Android WebView CPU高负荷问题 Android WebView页面加载优化 Android WebView常见问题及解决方案汇总 WebView你真的熟悉吗？看了才知道","link":"/2016/08/WebView优化技巧/"},{"title":"Android N for Developers","text":"原文链接：https://developer.android.com/preview/api-overview.html Android N for DevelopersAndroid N 仍处于活动的开发状态，但现在您可以将其作为 N Developer Preview 的一部分进行试用。以下部分重点介绍面向开发者的部分新功能。 请务必查阅行为变更以了解平台变更可能影响您的应用的领域，看看开发者指南，了解有关关键功能的更多信息，并下载 API 参考以获取新 API 的详细信息。 多窗口支持在 Android N 中，我们为该平台引入了一个新的而且非常需要的多任务处理功能 — 多窗口支持。 现在，用户可以一次在屏幕上打开两个应用。 在运行 Android N 的手机和平板电脑上，用户可以并排运行两个应用，或者处于分屏模式时一个应用位于另一个应用之上。用户可以通过拖动两个应用之间的分隔线来调整应用。在 Android TV 设备上，应用可以将自身置于画中画模式，从而让它们可以在用户浏览或与其他应用交互时继续显示内容。如需了解详细信息，请参阅下文。 多窗口支持为您提供新的吸引用户方式，特别是在平板电脑和其他更大屏幕的设备上。您甚至可以在您的应用中启用拖放，从而使用户可以方便地将内容拖放到您的应用或从其中拖出内容—这是一个非常好的增强用户体验的方式。 向您的应用添加多窗口支持并配置多窗口显示的处理方式非常简单。例如，您可以指定您的 Activity 允许的最小尺寸，从而防止用户将 Activity 调整到该尺寸以下。您还可以为应用禁用多窗口显示，这可确保系统将仅以全屏模式显示应用。 如需了解详细信息，请参阅多窗口支持开发者文档。 通知增强功能在 Android N 中，我们重新设计了通知，使其更易于使用并且速度更快。部分变更包括： 模板更新：我们正在更新通知模板，新强调了英雄形象和化身。开发者将能够充分利用新模板，只需进行少量的代码调整。绑定的通知：系统可以将消息组合在一起（例如，按消息主题）并显示组。用户可以适当地进行 Dismiss 或 Archive 等操作。如果您已实现 Android Wear 的通知，那么您已经很熟悉此模型。直接回复：对于实时通信应用，Android 系统支持内联回复，以便用户可以直接在通知界面中快速回复短信。自定义视图：两个新的 API 让您在通知中使用自定义视图时可以充分利用系统装饰元素，如通知标题和操作。 如需了解如何实现新功能的信息，请参阅通知指南。 配置文件指导的 JIT/AOT 编译在 Android N 中，我们添加了 Just in Time (JIT) 编译器，对 ART 进行代码分析，让它可以在应用运行时持续提升 Android 应用的性能。JIT 编译器对 Android 运行组件当前的 Ahead of Time (AOT) 编译器进行了补充，有助于提升运行时性能，节省存储空间，加快应用更新和系统更新速度。 配置文件指导的编译让 Android 运行组件能够根据应用的实际使用以及设备上的情况管理每个应用的 AOT/JIT 编译。例如，Android 运行组件维护每个应用的热方法的配置文件，并且可以预编译和缓存这些方法以实现最佳性能。对于应用的其他部分，在实际使用之前不会进行编译。 除提升应用的关键部分的性能外，配置文件指导的编译还有助于减少整个 RAM 占用，包括关联的二进制文件。此功能对于低内存设备非常尤其重要。 Android 运行组件在管理配置文件指导的编译时，可最大程度降低对设备电池的影响。仅当设备处于空闲状态和充电时才进行编译，从而可以通过提前执行该工作节约时间和省电。 快速的应用安装路径Android 运行组件的 JIT 编译器最实际的好处之一是应用安装和系统更新的速度。即使在 Android 6.0 中需要几分钟进行优化和安装的大型应用，现在只需几秒钟就可以完成安装。系统更新也变得更快，因为省去了优化步骤。 外出瞌睡模式…Android 6.0 推出了瞌睡模式，即设备处于空闲状态时，通过推迟应用的 CPU 和网络活动以实现省电目的的系统模式，例如，设备放在桌上或抽屉里时。 现在，在 Android N 中，瞌睡模式又前进了一步，在外出时也可以省电。只要屏幕关闭了一段时间，且设备未插入电源，瞌睡模式就会对应用使用熟悉的 CPU 和网络限制。这意味着用户即使将设备放入口袋里也可以省电。 屏幕关闭片刻后，设备在使用电池时，瞌睡模式将限制网络访问，同时延迟作业和同步。在短暂的维护时间范围后，其允许应用访问网络，并执行延迟的作业/同步。打开屏幕或将设备插入电源会使设备退出瞌睡模式。 当设备再次处于静止状态时，屏幕关闭且使用电池一段时间，瞌睡模式针对 PowerManager.WakeLock, AlarmManager 警报和 GPS/Wi-Fi 扫描应用完整 CPU 和网络限制。 无论设备是否处于运动状态，将应用调整到瞌睡模式的最佳做法均相同，因此，如果您已更新应用以妥善处理瞌睡模式，则一切就绪。如果不是，请立即开始将应用调整到瞌睡模式。 Project Svelte：后台优化Project Svelte 在持续改善，以最大程度减少生态系统中一系列 Android 设备中系统和应用使用的 RAM。在 Android N 中，Project Svelte 注重优化在后台中运行应用的方式。 后台处理是大多数应用的一个重要部分。处理得当，可让您实现非常棒的用户体验 — 即时、快速和情境感知。如果处理不得当，后台处理会毫无必要地消耗 RAM（和电池），同时影响其他应用的系统性能。 自 Android 5.0 发布以来，JobScheduler 已成为执行后台工作的首选方式，其工作方式有利于用户。应用可以在安排作业的同时允许系统基于内存、电源和连接情况进行优化。JobScheduler 可实现控制和简洁性，我们想要所有应用都使用它。 另一个非常好的选择是 GCMNetworkManager（Google Play 服务的一部分），其在旧版 Android 中提供类似的作业安排和兼容性。 我们在继续扩展 JobScheduler 和 GCMNetworkManager，以符合多个用例 — 例如，在 Android N 中，现在，您可以基于内容提供程序中的更改安排后台工作。同时，我们开始弃用一些较旧的模式，这些模式会降低系统性能，特别是低内存设备的系统性能。 在 Android N 中，我们删除了三个常用隐式广播 — CONNECTIVITY_ACTION、ACTION_NEW_PICTURE 和 ACTION_NEW_VIDEO — 因为这些广播可能会一次唤醒多个应用的后台进程，同时会耗尽内存和电池。如果您的应用收到这些广播，请充分利用 N Developer Preview 以迁移到 JobScheduler 和相关的 API。 如需了解详情，请查看后台优化文档。 Data Saver在移动设备的整个生命周期，蜂窝数据计划的成本通常会超出设备本身的成本。对于许多用户而言，蜂窝数据是他们想要节省的昂贵资源。 Android N 推出了 Data Saver 模式，这是一项新的系统服务，有助于减少应用使用的蜂窝数据，无论是在漫游，账单周期即将结束，还是使用少量的预付费数据包。Data Saver 让用户可以控制应用使用蜂窝数据的方式，同时让开发者打开 Data Saver 时可以提供更多有效的服务。 用户在 Settings 中启用 Data Saver 且设备位于按流量计费的网络上时，系统屏蔽后台数据使用，同时指示应用在前台尽可能使用较少的数据 — 例如，通过限制用于流媒体服务的比特率、降低图片质量、延迟最佳的预缓冲等方法来实现。用户可以将特定应用加入白名单以允许后台按流量的数据使用，即使在打开 Data Saver 时也是如此。 Android N 扩展了 ConnectivityManager，以便为应用检索用户的 Data Saver 首选项并监控首选项变更提供一种方式。所有应用均应检查用户是否已启用 Data Saver 并努力限制前台和后台数据的使用。 快速设置图块 API“快速设置”通常用于直接从通知栏显示关键设置和操作，非常简单。在 Android N 中，我们已扩展“快速设置”的范围，使其更加有用更方便。 我们为额外的“快速设置”图块添加了更多空间，用户可以通过向左或向右滑动跨分页的显示区域访问它们。我们还让用户可以控制显示哪些“快速设置”图块以及显示的位置 — 用户可以通过拖放图块来添加或移动图块。 对于开发者，Android N 还添加了一个新的 API，从而让您可以定义自己的“快速设置”图块，使用户可以轻松访问您应用中的关键控件和操作。 对于急需或频繁使用的控件和操作，保留“快速设置”图块，且不应将其用作启动应用的快捷方式。 定义图块后，您可以将它们显示给用户，用户可通过拖放将图块添加到“快速设置”。 如需创建应用图块的更多信息，请参阅可下载的 API 参考中的 android.service.quicksettings.Tile。 号码屏蔽Android N 现在支持在平台中进行号码屏蔽，提供框架 API，让服务提供商可以维护屏蔽的号码列表。默认短信应用、默认手机应用和提供商应用可以对屏蔽的号码列表进行读取和写入操作。其他应用则无法访问此列表。 通过使号码屏蔽成为平台的标准功能，Android 为应用提供一致的方式来支持广泛的设备上的号码屏蔽。应用可以利用的其他优势包括： 还会屏蔽已屏蔽的来电号码发出的短信通过 Backup &amp; Restore（备份和还原）功能可以跨重置和设备保留屏蔽的号码多个应用可以使用相同的屏蔽号码列表此外，通过 Android 的运营商应用集成表示运营商可以读取设备上屏蔽的号码列表，并为用户执行服务端屏蔽，以阻止不需要的来电和短信通过任何介质（如 VOIP 端点或转接电话）到达用户。 如需了解详细信息，请参阅可下载的 API 参考中的 android.provider.BlockedNumberContract。 来电过滤Android N 允许默认的手机应用过滤来电。手机应用执行此操作的方式是实现新的 CallScreeningService，该方法允许手机应用基于来电的 Call.Details 执行大量操作，例如： 拒绝来电不允许来电到达呼叫日志不向用户显示来电通知如需了解详细信息，请参阅可下载的 API 参考中的 android.telecom.CallScreeningService。 多区域设置支持、多语言Android N 现在允许用户在设置中选择多个区域设置，以更好地支持双语用例。应用可以使用新的 API 获取用户选择的区域设置，然后为多区域设置用户提供更成熟的用户体验 — 如以多个语言显示搜索结果，并且不会以用户了解的语言翻译网页。 除多区域设置支持外，Android N 还扩展了用户可用的语言范围。它针对常用语言提供超过 25 种的变体，如英语、西班牙语、法语和阿拉伯语。它还针对 100 多种新语言添加了部分支持。 应用可以通过调用 LocaleList.GetDefault() 获取用户设置的区域设置列表。为支持扩展的区域设置数量，Android N 正在改变其解析资源的方式。请务必使用新的资源解析逻辑测试和验证您的应用是否能如期运行。 如需有关新资源解析行为和应遵循的最佳做法的更多信息，请参阅多语言支持。 Android 中的 ICU4J APIAndroid N 目前在 Android 框架（位于 android.icu 软件包下）中提供 ICU4J API 的子集。迁移很简单，主要是需要从 com.java.icu 命名空间更改为 android.icu。如果您已在您的应用中使用 ICU4J 捆绑包，切换到 Android 框架中提供的 android.icu API 可以大量节省 APK 大小。 如果要了解有关 Android ICU4J API 的更多信息，请参阅 ICU4J 支持。 OpenGL™ ES 3.2 APIAndroid N 添加了框架接口和对 OpenGL ES 3.2 的平台支持，包括： 来自 Android 扩展包 (AEP) 的所有扩展（EXT_texture_sRGB_decode 除外）。针对 HDR 的浮点帧缓冲和延迟着色。BaseVertex 绘图调用可实现更好的批处理和流媒体服务。强大的缓冲区访问控制可减少 WebGL 开销。Android N 上适用于 OpenGL ES 3.2 的框架 API 与 GLES32 类一起提供。使用 OpenGL ES 3.2 时，请务必通过 标记和 android:glEsVersion 属性在您的清单文件中声明要求。 如需了解有关使用 OpenGL ES 的信息，包括如何在运行时检查设备支持的 OpenGL ES 版本，请参阅 OpenGL ES API 指南。 Android TV 录制Android N 通过新的录制 API 添加了从 Android TV 输入服务录制和播放内容的功能。构建在现有时移 API 之上，TV 输入服务可以控制能够录制的渠道数据、保存录制的会话的方式，同时可通过录制的内容管理用户交互。 如需了解详细信息，请参阅 Android TV 录制 API。 Android for WorkAndroid for Work 针对运行 Android N 的设备添加了许多新功能和 API。部分重要内容如下— 有关与 Android N 相关的 Android for Work 更新的完整列表，请参阅 Android for Work 变更。 托管配置文件安全性挑战配置文件所有者可以指定为托管配置文件中运行的应用指定单独的安全性挑战。当用户尝试打开任何工作应用时将显示工作挑战。成功完成安全性挑战可解锁托管配置文件并将其解密（如果需要）。对于配置文件所有者，ACTION_SET_NEW_PASSWORD 提示用户设置工作挑战，ACTION_SET_NEW_PARENT_PROFILE_PASSWORD 提示用户设置设备锁。 配置文件所有者可以使用 setPasswordQuality()、setPasswordMinimumLength() 和相关方法针对工作挑战设置不同的密码策略（例如，PIN 必须多长，或是否可以使用指纹解锁配置文件）。配置文件所有者还可以使用新的 getParentProfileInstance() 方法返回的 DevicePolicyManager 实例设置设备锁定。此外，配置文件所有者可以使用新的 setOrganizationColor() 和 setOrganizationName() 方法针对工作挑战自定义凭据屏幕。 关闭工作在具有托管配置文件的设备上，用户可以切换工作模式。工作模式关闭时，管理的用户临时关闭，其禁用托管配置文件应用、后台同步和通知。这包括配置文件所有者应用。关闭工作模式时，系统显示永久状态图标，以提醒用户他们无法启动工作应用。启动器指示该工作应用和小组件无法访问。 Always on VPN设备所有者和配置文件所有者可以确保工作应用始终通过指定的 VPN 连接。系统在设备启动后自动启动该 VPN。 新的 DevicePolicyManager 方法为 setAlwaysOnVpnPackage() 和 getAlwaysOnVpnPackage()。 由于 VPN 服务无需应用交互即可由系统直接绑定，因此，VPN 客户端必须针对 Always on VPN 处理新的入口点。和以前一样，由与操作匹配的 Intent 过滤器将服务指示给系统。android.net.VpnService。 用户还可以使用 Settings&gt;More&gt;Vpn 在主要用户中手动设置实现 VPNService 方法的 Always on VPN 客户端。 辅助工具增强功能Android N 现在针对新的设备设置直接在欢迎屏幕上提供“Vision Settings”。这使用户可以更容易发现和配置他们设备上的辅助工具功能，包括放大手势、字体大小、显示屏尺寸和 TalkBack。 随着这些辅助工具功能更为突出，在启用这些功能后，您的用户更可能试用您的应用。请务必提前启用这些设置测试您的应用。您可以通过 Settings &gt; Accessibility 启用它们。 还是在 Android N 中，辅助工具服务现在可以帮助具有动作障碍的用户触摸屏幕。全新的 API 允许使用人脸追踪、眼球追踪、点扫描等功能构建服务，以满足这些用户的需求。 如需了解详细信息，请参阅可下载的 API 参考 中的 android.accessibilityservice.GestureDescription 。 直接启动直接启动可以缩短设备启动时间，让注册的应用具有有限的功能，即使在意外重启后。例如，如果当用户睡觉时加密的设备重启，那么注册的警报、消息和来电现在可以和往常一样继续通知用户。这也意味着重启后辅助工具服务会立即可用。 在 Android N 中，直接启动充分利用基于文件的加密，以针对系统和应用数据启用细化的加密策略。为系统和应用数据。系统针对选定的系统数据和显式注册的应用数据使用设备加密的存储。默认情况下，凭据加密的存储可用于所有其他系统数据、用户数据、应用及应用数据。 启动时，系统在受限的模式中启动，仅访问设备加密的数据，不会对应用或数据进行常规访问。如果您有想要在此模式下运行的组件，您可以通过在清单文件中设置标记注册它们。重启后，系统通过广播 LOCKED_BOOT_COMPLETED Intent 激活注册的组件。系统确保注册的设备加密的应用数据在解锁前可用。所有其他数据在用户确认锁定屏幕凭据进行解密前均不可用。 如需了解详细信息，请参阅直接启动。 密钥认证使用硬件支持的密钥库，可更安全地在 Android 设备上创建、存储和使用加密密钥。它们可保护密钥免受 Linux 内核、潜在的 Android 漏洞的攻击，也可防止从已取得 root 权限的设备提取密钥。 为了让硬件支持的密钥库使用起来更简单和更安全，Android N 引入了密钥认证。应用和关闭的设备可使用密钥认证以坚决地确定 RSA 或 EC 密钥对是否受硬件支持、密钥对的属性如何，以及其使用和有效性有何限制。 应用和关闭的设备服务可以通过 X.509 认证证书（必须由有效的认证密钥签署）请求有关密钥对的信息。认证密钥是一个 ECDSA 签署密钥，其在出厂时被注入设备的硬件支持的密钥库。因此，有效的认证密钥签署的认证证书可确认硬件支持的密钥库是否存在，以及该密钥库中密钥对的详细信息。 为确保设备使用安全的官方 Android 出厂映像，密钥认证要求设备 bootloader 向可信执行环境 (TEE) 提供以下信息： 设备上安装的操作系统版本和补丁级别验证的启动公钥和锁定状态。如需了解有关硬件支持的密钥库功能的详细信息，请参阅硬件支持的密钥库指南。 除密钥认证外，Android N 还推出了指纹绑定密钥，在指纹注册时不会撤销。 网络安全性配置在 Android N 中，通过使用说明性网络安全性配置（而不是使用传统的易出错的编程 API（例如，X509TrustManager）），应用可以安全地自定义其安全（HTTPS、TLS）连接的行为，无需任何代码修改。 支持的功能： 自定义信任锚。让应用可以针对其安全连接自定义哪些证书颁发机构 (CA) 受信任。例如，信任特定的自签署证书或受限的公共 CA 集。仅调试重写。让应用开发者可以安全调试其应用的安全连接，而不会增加安装基础的风险。明文流量退出。让应用可以防止自身意外使用明文流量。固定证书。这是一项高级功能，让应用可以针对安全连接限制哪些服务器密钥受信任。如需了解详细信息，请参阅网络安全性配置。 默认受信任的证书颁发机构默认情况下，针对 Android N 的应用仅信任系统提供的证书，且不再信任用户添加的证书颁发机构 (CA)。如果针对 Android N 的应用希望信任用户添加的 CA，则应使用网络安全性配置以指定信任用户 CA 的方式。 APK signature scheme v2PackageManager 类现在支持使用 APK signature scheme v2 验证应用。APK signature scheme v2 是一个整个文件签名架构，通过检测对 APK 文件进行的任何未经授权更改，可大幅提高验证速度，同时也可加强完整性保证。 为保持向后兼容，在使用 v2 签名架构签署之前，APK 必须先使用 v1 签名架构（JAR 签名架构）签署。对于 v2 签名架构，如果在使用 v2 架构签署后使用额外的证书签署 APK，验证将失败。 APK signature scheme v2 支持稍后将在 N Developer Preview中推出。 作用域目录访问在 Android N 中，应用可以使用新的 API 请求访问特定的外部存储目录，包括可移动媒体上的目录，如 SD 卡。新 API 大大简化了应用访问标准外部存储目录的方式，如 Pictures 目录。应用（如照片应用）可以使用这些 API（而不是使用 READ_EXTERNAL_STORAGE），其授予所有存储目录的访问权限或存储访问框架，从而让用户可以导航到目录。 此外，新的 API 简化了用户向应用授予外部存储访问权限的步骤。当您使用新的 API 时，系统使用一个简单的权限 UI，其清楚地详细介绍应用正在请求访问的目录。 如需了解详细信息，请参阅作用域目录访问开发者文档。","link":"/2016/05/Android N for Developers/"},{"title":"最好的移动软件开发方案","text":"我们的宗旨是，做最好的移动软件开发方案。 小学没毕业就出国了的 Google Flutter 团队高级工程师 于潇 如是说。 学习《使用Flutter快速构建集美观与高性能于一体的移动应用》笔记。 学习地址：https://time.geekbang.org/dailylesson/detail/100016434 当前移动软件开发中的阻碍 开发太贵 开发太慢 高质量太难 工程资源太难共享 Flutter的研发设计路线 跨平台 高开发效率 简单的表达出UI设计师期望的效果 不牺牲原生的运行速度 Flutter的性能与特点 Hot Reload（热重载） 作为一名Android开发人员，非常能体会到，等待代码编译的过程是多么的让人无奈…想象一下，现在是晚上九点钟，今晚必须上线，测试小伙伴坐在你旁边，等待着你修复最后一个Bug，你的Wife还在不停的Call你回家恰饭，你飞速的浏览代码定位问题思考正确逻辑飞速敲击键盘完成修改点击Run一气呵成，接下来就是长达8分钟的等待… 编译完成后，测试小伙伴飞速复测，发现还是有问题，继续修改… 这一来一回，十多分钟过去了，修改bug的时间成本太高了！ 保守估计，用上热重载功能的话，能够提高原生客户端开发效率10%以上。 声明式+响应式开发模式 具体场景：原生开发中，很多运行时异常不做特殊处理的话，会直接Crash掉，我们需要分析Crash log，修改代码，再重新编译运行来测试；而有了这个功能之后，异常只影响错误的部分，修改掉错误代码后，通过Hot Reolad功能，快速应用到已运行的程序中，既不会Crash，又不需要重新编译运行，这是APP开发前所未有的体验！ 组合性API “万物皆Widget”，提供了一套强大的可特制设计的UI系统 内置Material和Cupertino风格设计组建 直接GPU渲染 系统架构其它全平台方案架构性能链路 原生平台的性能是很快的，但是跨平台代码和原生交互时，链路很长，性能很差。 Flutter架构性能链路 Flutter的代码执行链路非常简单，执行效率高。 性能优化 - 布局 由于Flutter的单个Element是比较简单的，可以从上到下，单次布局，加快运行速度。 Flutter的使用体验闲鱼移动团队分享Flutter的使用体验，实现了Flutter和原生APP的混合开发。 社区支持 Github：https://github.com/flutter/flutter Flutter官网： https://flutter.dev Flutter国内社区： https://flutter.cn 版本计划 Flutter : Release 1.12 Flutter Web : Beta阶段 Flutter Desktop : Dev阶段 由于本视频是2018年GMTC的，时间比较久了，直到现在（2020年2月10日），Flutter又有了长足的发展，项目应用也越来越成熟，希望感兴趣的同学多多关注。 2018年GMTC视频PPT下载：https://con.infoq.cn/archives/?conf=gmtc","link":"/2020/02/flutter/2月10日/"},{"title":"移动端是个大坑-Flutter在贝壳的接入实践学习笔记","text":"很后悔从后端转到移动端，这个大坑。 头发日渐稀疏的贝壳找房移动端资深工程师 张华峰 如是说。 《Flutter在贝壳的接入实践》的学习笔记。 Flutter贝壳接入案例 Android工程师，在不熟悉的情况下，Flutter比原生花费1.1 -1.2倍的时间，iOS端同步运行 “海神”监控Exception率，原生是万分之0.7，Flutter低于万分之0.7 Flutter工程基础 SDK pub_cache bin packages 工程类型 Flutter Application - Flutter标准应用程序 DartLib Android子工程 iOS子工程 Flutter Plugin - 封装Native工程的基础拓展 Flutter Package - 纯Dart库 Flutter Module - FLutter作为子Module 原生工程接入Flutter 官方方案 - Flutter Module引入原生项目 耦合度高 - 所有的Flutter代码都在同一个Module里 编译成本比较高 - 原生编译 + Flutter Module编译 闲鱼接入方案 Flutter产物放入远端，当作Lib引入到原生 贝壳接入方案 原生解偶 - 对原生影响最小 屏蔽平台 - 工程师会Dart和Flutter UI即可 业务分离 - 同基础，分散业务 保证开发效率 方便继承 - 减少人工干预，少量维护 开发时，是Flutter Application，各个业务以package存在，运行在原生的壳工程中，速度相对较快。通过Target文件和透传原生的Flavor实现不同资源/渠道的打包。 Flutter接入方案介绍与理论基础 Flutter编译模式 Flutter构建流程Debug模式 Flutter构建流程Release模式 Flutter构建工具链 Flutter构建工具 Flutter gradle脚本修改 Flutter构建工具flutter_tools修改 Flutter日常开发构建流程（Android） Flutter持续继承构建流程（Android） Flutter热更新探索 动态产物下载 只支持Android 实现简单 DSL - 动态语言映射FLutter UI 实现复杂 在Flutter生态中比较危险 双端都适用 贝壳的热更新方案 Android - 使用原生的插件化框架将Flutter业务做成单独插件 iOS - 避免审核异常，暂不实现热更新 Flutter for Web - 和app UI几乎完全一致，通过开关控制Flutter和Flutter web的切换 干货很多，值得认真学习。","link":"/2020/02/flutter/2月12日/"},{"title":"好奇心 + 懒惰是「工程师」最大的美德","text":"好奇心 + 懒惰 是 工程师 最大的美德。 在福厂修福报修了7年的福娃 于佳（宗心） 如是说。 《闲鱼基于Flutter技术的架构演进与创新》的学习笔记。 演讲PPT下载，InfoQ登录可下载。 Flutter在闲鱼的优势与挑战 Flutter吸引作者的几点 Flutter的Skia底层跨端渲染保证了效率和各平台的一致性； Dbug链路、Hot Reolad等功能在客户端开发商非常先进； 开箱即用的Widget，加快开发速度。 什么样的团队适合使用Flutter 开发人力资源匮乏的团队； 双端用户不均，不想维护1:1的开发人员； 大公司的APP工厂，业务打法。 如今闲鱼主业务已使用大量Flutter来实现 闲鱼的架构演进与创新 如何将Flutter融入到现有原生APP中 - Flutter Boost Navigator管理 Native生命周期感知 Flutter页面嵌入原生控件 拍摄视频/图片到显示的链路过长，通过传递TextureId实现更短链路，更少的CPU和更少的内存 如何让整个团队快速上手Flutter Fish-Redux 解决Big cell问题，使用Adapter完成多List的合并 关于闲鱼在Flutter上的的视频/图片优化，有在其它文章中看到过 研发智能化在闲鱼的应用 高速公路上换轮胎是很危险的 数据驱动 - 数据化每个过程 bug数量、运行时间、开发时间、数据报表、commit绑定任务id等 自动化 - 持续继承 2-1-7 原则 Exception率 - error收集 ErrorWidget Exception handler isolate Exception WidgetsFlutterBinding 统计FPS/加载时长 PerformanceFlutterBindingObserver - dispatchEvent 总结与展望 好奇心 + 懒惰 是 工程师 最大的美德","link":"/2020/02/flutter/2月11日/"},{"title":"Flutter要运行在所有能显示的设备上","text":"Flutter要运行在所有能显示的设备上。 密歇根大学人机交互博士、Google Flutter团队高级研究员 董韬 如是说。 《Flutter：最新进展和未来展望》的学习笔记。 今天的学习内容，并不高深，都是一些基础知识，但是学到了几个非常实用的语法，也促使我要好的看一下Dart的各个版本更新内容文档了！ Flutter基本介绍和在中国的发展状况 什么是Flutter 18年 Flutter Live 发布1.0版本 特点 美观、快速、高效、开放 非常受开发者欢迎 在中国的发展 闲鱼的一位开发者提交的PR数量超过了Google专职Flutter开发的工程师的个人提交数量 （震惊） Flutter多平台：Mobile、Web、Desktop、Enbedded多平台远景：Flutter for Web 代码库已合并到Flutter主SDK中 SDK 和移动端最大条件的复用 Flutter framework in Dart（widgets, gestures, etc） Flutter Web engine 类似原生的 C++ Flutter engine Flutter Web engine HTML + CSS 来绘制图形 利用浏览器自身的性能优化 不担心尺寸兼容 Canvas 2D 备用绘图选项 性能和缩放问题 未来计划 CSS Paint API 代替 Canvas以提高性能，不过浏览器支持不太好 依赖Flutter框架 Dart2js compiler 在Google应用广泛 ：Google广告业务体系等 高效、成熟 应用场景 作为移动应用的配套程序 先体验后下载 覆盖更多用户 使用桌面端的输入输出需求 高度交互元素复用 性能 桌面浏览器 60FPS以上 移动浏览器 一般手机 60FPS 差手机 达不到60FPS 开发体验 Widget API 和移动端一致 局限和后续研发 合并到Flutter SDK 保证所有widgets正确渲染 性能优化 完善对浏览器无障碍功能的支持 添加插件系统来使用现有的JS库 加强开发调试工具的可用性 生态建设：与社区共建的状态管理解决方案 社区开发者设计的状态管理解决方案 [地址][state] 官方推荐 provider ChangeNotifier ChangeNotifierProvider Consumer 开发体验：“UI as Code” - 编程语言和IDE的改进 Dart代码编写Flutter UI的优点和改进空间 声明式UI 改进空间 复杂UI逻辑会使用命令式语法，打破代码结构和UI视觉结构的一致性 死亡嵌套！ 新语法 Controll Flow Elements in Collections 在集合中使用if 和for来操作UI Spread Operator‘…’ - 展开操作符 构建集合时，可以更方便的将小集合动态组合起来，非常实用 IDE优化 UI Guides child 和children的缩写优化探索 以往的改进 new关键字非必须 UI as Code UI Guides Flutter/Dart近期展望 改进Flutter和原生混编的机制和开发体验（add-to-app） Dart语言演进 non-nullable, extension methods, Dart runtime增加FFI(C/C++ interop) 更容易理解的报错信息 Flutter Web性能优化，Flutter Desktop功能完善，FLutter路线图","link":"/2020/02/flutter/2月13日/"},{"title":"偷懒是一种美德","text":"偷懒是一种美德 阿里巴巴技术专家 陈新新 如是说。 《基于FLutter &amp; Dart的全栈开发》的学习笔记。 了解到了闲鱼是如何将Flutter &amp; Dart应用到前后端一体化开发的，没想到FLutter结合Dart Server能够实现这么令人惊艳的开发模式！ 闲鱼移动端框架演进 原生 + H5 + WEEX 原生 + Flutter 原生性能 - 渲染引擎、AOT、无锁GC 快速开发 - 亚秒级、有状态的热重载 统一的应用开发体验 - 两端一致的开发方式，Material和Cupertino ###Flutter快速开发 Hot Reload Flutter在闲鱼应用过程 2个人3个月，做出闲鱼国际版本 接近Native的效果 关键问题解决 混合开发：工程管理和混合栈管理 Flutter产物引入原生项目 外接纹理播放视频 图片缓存优化 无反射JSON序列化 私有PUB库、阿里生态适配 Flutter两端统一开发，提高效率 协议定义 接口实现 一个人开发三端 不一样的开发和思维方式 部署运维让客户端开发人员觉得很复杂 增加很多工作量 胶水层 - Dart实现 胶水层多变，领域层少改 详情页所有流量由Dart Server服务 运行时长 - 长时间运行稳定 RT 单机QPS 让Flutter同学快速上手服务端 All in IDE - 制作了很多IDE插件 新建服务 快速部署 本地执行 隔离调试 日志回传 错误定位 服务集合 领域服务 代码转换 - java转Dart工具 服务索引 - 文档索引 简化运维 监控 告警 开关 降级 限流 秒级部署 - Dart Isolate 无需代码提交 运行时隔离 远程热部署 本地测试 本地调用远程服务 - http 单次请求所有日志回传 - Dart Zone 无冲突调试 - Isolate隔离 Isolate 加载每个人的代码 只调试指定Isolate 三端一体化新开发模式 数据模型 - 前后端一致 业务逻辑 - 分拆实现 视图 - 统计两端UI 协议 - 前后端协议用工具生成一套 全链路日志 一体化开发的好处 开发灵活，扩展性好，降低沟通成本 协议三端一致，提高性能和效率 一体化开发，全链路日志和调试 服务端更专注领域服务的通用性和性能 未来和研发自动化的结合 研发自动化 UI2Code - UI生成代码 Fluttter代码生成 Data Bind - 生成协议 即将开源 Dart Server Framework Dart Server IDE Plugins","link":"/2020/02/flutter/2月14日/"},{"title":"回调地狱就像龟派气功","text":"多重回调的回调地狱，就像是龟派气功。 饿了么资深Android工程师 张涛 如是说。 《领略Kotlin协程的力量》的学习笔记。 Kotlin的协程功能确实非常强大，类似Flutter的async/await使用。 什么是协程 进程 - 进程间切换要保存状态数据 单CPU 时间分片 多CPU 并行执行 线程 - 多线程切换，寄存器保存状态 线程阻塞 协程概念：通过提升CPU利用率，减少线程切换，进而提升CPU运行效率 协程的特点 可控制 - 协程能做到可被控制的发起子任务 轻量级 - 协程非常小，占用资源比线程还少 语法糖 - 使多任务或多线程切换不再使用回调方法 如何使用Kotlin协程 例子：第三方登录，多个顺序接口请求 不用协程：需要多重回调，陷入了回调地狱 使用协程： runBlocking - T 用于执行协程任务，通常用于启动最外层协程 launch：Job 协程内启动协程 123fun setText(name: String) = launch(UI){ textView.text = name} async/await：Defered 成对出现，用于执行协程并获取返回值 123suspend fun requestToken() = async(CommonPool){ return@async \"curl http://www.example.com\"}.await() suspend关键字 suspend修饰的函数（或lambda），只能被suspend修饰的函数（或lambda）调用 1234567891011// 编译前suspend fun requestToken():String {...}// 编译后Object requestToken(Continuation&lt;String&gt; c) {...}// Continuation接口interface Continuation&lt;in T&gt; { val context: CoroutineContext fun resume(value: T) // 成功回调 fun resumeWithException(e: Throwable) // 失败回调} 如何在现有的项目中引入协程 使用扩展方法，扩展已有方法 123456interface Service { fun requestToken(): Call&lt;Token&gt;}suspend fun requestToken(): String = serverInterface.requestToken().await() 改进I/O操作 12345678fun save(textView: TextView, file: File) = runBlocking { val text = textView.text.toString() val deferred = async(CommonPool) { file.appendText(text) file.readText() } deferred.await()} 引入协程时充分利用协程的特性 不要滥用协程","link":"/2020/02/kotlin/2月15日/"},{"title":"怎样做好 Tech Leader","text":"“不求有功，但求无过。”是陋习。 阿里巴巴高级技术专家 孔凡勇（云狄）如是说。 《细说Tech Leader在开发团队的核心职责》的学习笔记。 分享者分别从技术和团队两个角度讲述了自己作为技术领导的总结和感悟，涉及面比较广；在当前疫情期间，我们可以找出具体可实施的点来实践。 技术 协作流程 项目启动 需求阶段 设计阶段 研发阶段 项目交付 开发规范 - java开发手册 降低故障率 提升协作效率 工匠精神 配置规范 统一代码formatter 统一git ignore 命名规范 lowerCameCase：方法名，参数名，成员变量，局部变量 UpperCameCase：类，接口包，常量命名 领域模型（DO/DTO/BO/VO） 其它 API规范 RPC REST API GateWay 异常处理规范 直接返回 抛出异常 重试处理 熔断处理 降级处理 分支开发规范 分支的定义 分支命名规范 checkout、merge request流程 提测流程 上线流程 hotfix流程 代码commit规范 Angular的提交规范 Type：feat/fix/docs/style/refactor/perf/test Commitizen / IDEA插件 生成cimmit log摘要 日志规范 日志框架 日志保存时间 日志级别-debug/info/warn/error 日志描述 - 上下文，traceId 日志信息安全 - 脱敏 禁用System.out/error Mysql规范 建表规约 字段，索引，表命名规范 索引规约 普通索引，唯一索引，组合索引 索引区分度 SQL规约 外键与级联 count（列名）、count（1）、count（*） 统一工具与框架 常用工具封装（httpclient/orm/异常处理） 分布式基础组件（缓存，限流，分布式锁，幂等） 业务监控 流程规范 需求管理 需求类型 重要程度 紧急程度 需求优先级 架构评审 架构设计目标 架构设计原则 架构评审要素 目标 功能需求 非功能需求 原则 合适原则 简单原则 演化原则 需求演化 技术架构演化 代码评审 开发规约插件扫描 Sonar扫描 发布计划评审 发布时，要统筹好所有依赖资料 技术规划 短期规划 巡检，周报 像航空飞机一样，定期巡检所有依赖的组件 长期规划 架构演进规划，根据技术需求，优化项目架构 管理 团队建设与管理 集权式管理 事必躬亲，事无巨细都要参与 放权式管理 对所有业务和人员都很熟悉后，开始放权式管理 思路转变，口令转变，授权不授责 激励，指导，赋予，淘汰 团队文化 坦诚，公开，透明 自我暴露，才能更快的融合到团队 平等相处，消除等级感 不要让大家对你言听计从，各自发挥自己的特点，要各自有独立的思考能力。 敢于担当 不求有功，但求无过。 不可取 明确各个人的职责范围 成就他人，乐于分享 每周一次分享会，大家会乐于研究新技术 沟通与辅导 一对一沟通 相对私密的环境，聊一些不同角度的各种问题，让大家去思考，定期举行沟通，慢慢的就会发现很多各自的需要优化的点。 1-2个月沟通一次。 招聘 价值观，味道 技术","link":"/2020/02/team_construction/2月28日/"},{"title":"团队领导的必修课","text":"领导决定组织的成败。 网易前端开发专家 吴子房如是说。 《打造通用型高效前端团队》的学习笔记。 通用型高效前端团队 业务背景 网易严选，自主品牌，参与产品制造，担库存 技术平台：App、H5、小程序、PC 团队职责 4年+，20+人 技术平台/技术中台 DevOps平台 开发，打包，测试一体化方案 权限中心/流程平台 业务研发中通用的一些痛点 用户，用户组，权限管理等等 系统架构演进 BFF框架优化 Serverless实践 对前端非常实用 前端应用架构演进 组件库 基于统一设计规范的组件库，可实践 效率工具 基于远程办公条件下的效率工具 产品思维 人员不增的前提下，支撑产品数量成倍增长 我们可以吗？我们组能够hold住现有业务 * 2的任务量吗？ 打造通用型高效前端团队 团队起步 打造核心能力，核心成员 5人，技术上的骨干力量 12人，技术平台建设，全平台，快速开发框架 18人，技术平台产品化，前后端全做，部分项目全栈开发 20人+，接手更多业务组的团队，技术中台建设，实践Serverless 管理者 全局意识，洞察业务与技术的发展方向，规划团队的未来发展路线 研发链路优化，参与到研发上下游 掌握更全面的开发技能 培养产品思维能力 投入新技术研究/调研 架构调整 30%做基建 人员能力提升 团队获得更多资源 制度建设 项目制度 目标明确 选好项目人员 把控好项目进度 自定项目流程 评审 -&gt; 负责人 -&gt; 方案评审，授权 -&gt; 招募成员（开放） -&gt; 里程碑（合理的里程碑可以更好地控制项目进度） -&gt; 落地（实现项目价值） 20+项目进行中 周会 信息同步，分享，培训 时间观念 时间观念非常重要，开会提前到的和到点后等别人叫的，差别真的很大很大。 提升团队凝聚力 主持人，分享者得到锻炼 人员培养 - 技术团队的核心就是人才 业务线之间人员流动 提升全局观，业务理解更全面、深入，有激情，更多话语权 业务组件库 跨业务线的组件库，依据设计规范 关注个人的核心诉求 了解团队中每个人的情况，喜好，能力 业务特点 一专多能的人才 管理者的思考 领导力 个人和团队的办事效力与领导力成正比 衡量标准：影响力 强制管理 打成一片 满足诉求 辅导功课 成为榜样 成就他人 领导精力有限，要给其他人机会，让其他人负责一些事情 建立信任 先做好建立信任，领导信任你，下属信任你。 领导信任你，愿意分配事情给你做 下属信任你，不会甩锅。 授权他人 不要天天追进度，只在里程碑评审时，关注项目进度。 提升自己 技术，视野，沟通 先“舍”后“得” 先成全别人，后成全自己 推荐书： 《领导力21法则》","link":"/2020/02/team_construction/2月29日/"},{"title":"Data Binding Library官方文档","text":"This document explains how to use the Data Binding Library to write declarative layouts and minimize the glue code necessary to bind your application logic and layouts. The Data Binding Library offers both flexibility and broad compatibility — it’s a support library, so you can use it with all Android platform versions back to Android 2.1 (API level 7+). To use data binding, Android Plugin for Gradle 1.5.0-alpha1 or higher is required. Build EnvironmentTo get started with Data Binding, download the library from the Support repository in the Android SDK manager. To configure your app to use data binding, add the dataBinding element to your build.gradle file in the app module. Use the following code snippet to configure data binding: 123456android { .... dataBinding { enabled = true }} If you have an app module that depends on a library which uses data binding, your app module must configure data binding in its build.gradle file as well. Also, make sure you are using a compatible version of Android Studio. Android Studio 1.3 and later provides support for data binding as described in Android Studio Support for Data Binding. Data Binding Layout FilesWriting your first data binding expressionsData-binding layout files are slightly different and start with a root tag of layout followed by a data element and a view root element. This view element is what your root would be in a non-binding layout file. A sample file looks like this: 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; The user variable within data describes a property that may be used within this layout.1&lt;variable name=\"user\" type=\"com.example.User\"/&gt; Expressions within the layout are written in the attribute properties using the “@{}” syntax. Here, the TextView’s text is set to the firstName property of user:123&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\"/&gt; Data ObjectLet’s assume for now that you have a plain-old Java object (POJO) for User: 12345678public class User { public final String firstName; public final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; }} This type of object has data that never changes. It is common in applications to have data that is read once and never changes thereafter. It is also possible to use a JavaBeans objects: 1234567891011121314public class User { private final String firstName; private final String lastName; public User(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return this.firstName; } public String getLastName() { return this.lastName; }} From the perspective of data binding, these two classes are equivalent. The expression @{user.firstName} used for the TextView’s android:text attribute will access the firstName field in the former class and the getFirstName() method in the latter class. Alternatively, it will also be resolved to firstName() if that method exists. Binding DataBy default, a Binding class will be generated based on the name of the layout file, converting it to Pascal case and suffixing “Binding” to it. The above layout file was main_activity.xml so the generate class was MainActivityBinding. This class holds all the bindings from the layout properties (e.g. the user variable) to the layout’s Views and knows how to assign values for the binding expressions.The easiest means for creating the bindings is to do it while inflating:1234567@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); MainActivityBinding binding = DataBindingUtil.setContentView(this, R.layout.main_activity); User user = new User(\"Test\", \"User\"); binding.setUser(user);} You’re done! Run the application and you’ll see Test User in the UI. Alternatively, you can get the view via:1MainActivityBinding binding = MainActivityBinding.inflate(getLayoutInflater()); If you are using data binding items inside a ListView or RecyclerView adapter, you may prefer to use:123ListItemBinding binding = ListItemBinding.inflate(layoutInflater, viewGroup, false);//orListItemBinding binding = DataBindingUtil.inflate(layoutInflater, R.layout.list_item, viewGroup, false); Binding EventsEvents may be bound to handler methods directly, similar to the way android:onClick can be assigned to a method in the Activity. Event attribute names are governed by the name of the listener method with a few exceptions. For example, View.OnLongClickListener has a method onLongClick(), so the attribute for this event is android:onLongClick. To assign an event to its handler, use a normal binding expression, with the value being the method name to call. For example, if your data object has two methods: 1234public class MyHandlers { public void onClickFriend(View view) { ... } public void onClickEnemy(View view) { ... }} The binding expression can assign the click listener for a View:1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"handlers\" type=\"com.example.Handlers\"/&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\" android:onClick=\"@{user.isFriend ? handlers.onClickFriend : handlers.onClickEnemy}\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\" android:onClick=\"@{user.isFriend ? handlers.onClickFriend : handlers.onClickEnemy}\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Some specialized click event handlers exist and they need an attribute other than android:onClick to avoid a conflict. The following attributes have been created to avoid such conflicts: Class Listener Setter Attribute SearchView setOnSearchClickListener(View.OnClickListener) android:onSearchClick ZoomControls setOnZoomInClickListener(View.OnClickListener) android:onZoomIn ZoomControls setOnZoomOutClickListener(View.OnClickListener) android:onZoomOut Layout DetailsImportsZero or more import elements may be used inside the data element. These allow easy reference to classes inside your layout file, just like in Java.123&lt;data&gt; &lt;import type=\"android.view.View\"/&gt;&lt;/data&gt; Now, View may be used within your binding expression:12345&lt;TextView android:text=\"@{user.lastName}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:visibility=\"@{user.isAdult ? View.VISIBLE : View.GONE}\"/&gt; When there are class name conflicts, one of the classes may be renamed to an “alias:”123&lt;import type=\"android.view.View\"/&gt;&lt;import type=\"com.example.real.estate.View\" alias=\"Vista\"/&gt; Now, Vista may be used to reference the com.example.real.estate.View and View may be used to reference android.view.View within the layout file. Imported types may be used as type references in variables and expressions:123456&lt;data&gt; &lt;import type=\"com.example.User\"/&gt; &lt;import type=\"java.util.List\"/&gt; &lt;variable name=\"user\" type=\"User\"/&gt; &lt;variable name=\"userList\" type=\"List&amp;lt;User&gt;\"/&gt;&lt;/data&gt; Note: Android Studio does not yet handle imports so the autocomplete for imported variables may not work in your IDE. Your application will still compile fine and you can work around the IDE issue by using fully qualified names in your variable definitions. 1234&lt;TextView android:text=\"@{((User)(user.connection)).lastName}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; Imported types may also be used when referencing static fields and methods in expressions:123456789&lt;data&gt; &lt;import type=\"com.example.MyStringUtils\"/&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt;&lt;/data&gt;…&lt;TextView android:text=\"@{MyStringUtils.capitalize(user.lastName)}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; Just as in Java, java.lang.* is imported automatically. VariablesAny number of variable elements may be used inside the data element. Each variable element describes a property that may be set on the layout to be used in binding expressions within the layout file.123456&lt;data&gt; &lt;import type=\"android.graphics.drawable.Drawable\"/&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;variable name=\"image\" type=\"Drawable\"/&gt; &lt;variable name=\"note\" type=\"String\"/&gt;&lt;/data&gt; The variable types are inspected at compile time, so if a variable implements Observable or is an observable collection, that should be reflected in the type. If the variable is a base class or interface that does not implement the Observable* interface, the variables will not be observed! When there are different layout files for various configurations (e.g. landscape or portrait), the variables will be combined. There must not be conflicting variable definitions between these layout files. The generated binding class will have a setter and getter for each of the described variables. The variables will take the default Java values until the setter is called — null for reference types, 0 for int, false for boolean, etc. A special variable named context is generated for use in binding expressions as needed. The value for context is the Context from the root View’s getContext(). The context variable will be overridden by an explicit variable declaration with that name. Custom Binding Class NamesBy default, a Binding class is generated based on the name of the layout file, starting it with upper-case, removing underscores ( _ ) and capitalizing the following letter and then suffixing “Binding”. This class will be placed in a databinding package under the module package. For example, the layout file contact_item.xml will generate ContactItemBinding. If the module package is com.example.my.app, then it will be placed in com.example.my.app.databinding. Binding classes may be renamed or placed in different packages by adjusting the class attribute of the data element. For example:123&lt;data class=\"ContactItem\"&gt; ...&lt;/data&gt; This generates the binding class as ContactItem in the databinding package in the module package. If the class should be generated in a different package within the module package, it may be prefixed with “.”:123&lt;data class=\".ContactItem\"&gt; ...&lt;/data&gt; In this case, ContactItem is generated in the module package directly. Any package may be used if the full package is provided:123&lt;data class=\"com.example.ContactItem\"&gt; ...&lt;/data&gt; IncludesVariables may be passed into an included layout’s binding from the containing layout by using the application namespace and the variable name in an attribute:12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:bind=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;include layout=\"@layout/name\" bind:user=\"@{user}\"/&gt; &lt;include layout=\"@layout/contact\" bind:user=\"@{user}\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Here, there must be a user variable in both the name.xml and contact.xml layout files. Data binding does not support include as a direct child of a merge element. For example, the following layout is not supported: 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:bind=\"http://schemas.android.com/apk/res-auto\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;merge&gt; &lt;include layout=\"@layout/name\" bind:user=\"@{user}\"/&gt; &lt;include layout=\"@layout/contact\" bind:user=\"@{user}\"/&gt; &lt;/merge&gt;&lt;/layout&gt; Expression LanguageCommon FeaturesThe expression language looks a lot like a Java expression. These are the same: Mathematical + - / * % String concatenation + Logical &amp;&amp; || Binary &amp; | ^ Unary + - ! ~ Shift &gt;&gt; &gt;&gt;&gt; &lt;&lt; Comparison == &gt; &lt; &gt;= &lt;= instanceof Grouping () Literals - character, String, numeric, null Cast Method calls Field access Array access [] Ternary operator ?: Examples: 123android:text=\"@{String.valueOf(index + 1)}\"android:visibility=\"@{age &amp;lt; 13 ? View.GONE : View.VISIBLE}\"android:transitionName='@{\"image_\" + id}' Missing OperationsA few operations are missing from the expression syntax that you can use in Java. this super new Explicit generic invocation Null Coalescing OperatorThe null coalescing operator (??) chooses the left operand if it is not null or the right if it is null. 1android:text=\"@{user.displayName ?? user.lastName}\" This is functionally equivalent to: 1android:text=\"@{user.displayName != null ? user.displayName : user.lastName}\" Property ReferenceThe first was already discussed in the Writing your first data binding expressions above: short form JavaBean references. When an expression references a property on a class, it uses the same format for fields, getters, and ObservableFields. 1android:text=\"@{user.lastName}\" Avoiding NullPointerExceptionGenerated data binding code automatically checks for nulls and avoid null pointer exceptions. For example, in the expression @{user.name}, if user is null, user.name will be assigned its default value (null). If you were referencing user.age, where age is an int, then it would default to 0. CollectionsCommon collections: arrays, lists, sparse lists, and maps, may be accessed using the [] operator for convenience.12345678910111213141516&lt;data&gt; &lt;import type=\"android.util.SparseArray\"/&gt; &lt;import type=\"java.util.Map\"/&gt; &lt;import type=\"java.util.List\"/&gt; &lt;variable name=\"list\" type=\"List&amp;lt;String&gt;\"/&gt; &lt;variable name=\"sparse\" type=\"SparseArray&amp;lt;String&gt;\"/&gt; &lt;variable name=\"map\" type=\"Map&amp;lt;String, String&gt;\"/&gt; &lt;variable name=\"index\" type=\"int\"/&gt; &lt;variable name=\"key\" type=\"String\"/&gt;&lt;/data&gt;…android:text=\"@{list[index]}\"…android:text=\"@{sparse[index]}\"…android:text=\"@{map[key]}\" String LiteralsWhen using single quotes around the attribute value, it is easy to use double quotes in the expression:1android:text='@{map[\"firstName\"]}' It is also possible to use double quotes to surround the attribute value. When doing so, String literals should either use the &quot; or back quote (`). 12android:text=\"@{map[`firstName`}\"android:text=\"@{map[&amp;quot;firstName&amp;quot;]}\" ResourcesIt is possible to access resources as part of expressions using the normal syntax:1android:padding=\"@{large? @dimen/largePadding : @dimen/smallPadding}\" Format strings and plurals may be evaluated by providing parameters: 12android:text=\"@{@string/nameFormat(firstName, lastName)}\"android:text=\"@{@plurals/banana(bananaCount)}\" When a plural takes multiple parameters, all parameters should be passed: 123 Have an orange Have %d orangesandroid:text=\"@{@plurals/orange(orangeCount, orangeCount)}\" Some resources require explicit type evaluation. Type Normal Reference Expression Reference String[] @array @stringArray int[] @array @intArray TypedArray @array @typedArray Animator @animator @animator StateListAnimator @animator @stateListAnimator color int @color @color ColorStateList @color @colorStateList Data ObjectsAny plain old Java object (POJO) may be used for data binding, but modifying a POJO will not cause the UI to update. The real power of data binding can be used by giving your data objects the ability to notify when data changes. There are three different data change notification mechanisms, Observable objects, observable fields, and observable collections. When one of these observable data object is bound to the UI and a property of the data object changes, the UI will be updated automatically. Observable ObjectsA class implementing the Observable interface will allow the binding to attach a single listener to a bound object to listen for changes of all properties on that object. The Observable interface has a mechanism to add and remove listeners, but notifying is up to the developer. To make development easier, a base class, BaseObservable, was created to implement the listener registration mechanism. The data class implementer is still responsible for notifying when the properties change. This is done by assigning a Bindable annotation to the getter and notifying in the setter. 1234567891011121314151617181920private static class User extends BaseObservable { private String firstName; private String lastName; @Bindable public String getFirstName() { return this.firstName; } @Bindable public String getLastName() { return this.lastName; } public void setFirstName(String firstName) { this.firstName = firstName; notifyPropertyChanged(BR.firstName); } public void setLastName(String lastName) { this.lastName = lastName; notifyPropertyChanged(BR.lastName); }} The Bindable annotation generates an entry in the BR class file during compilation. The BR class file will be generated in the module package. If the base class for data classes cannot be changed, the Observable interface may be implemented using the convenient PropertyChangeRegistry to store and notify listeners efficiently. ObservableFieldsA little work is involved in creating Observable classes, so developers who want to save time or have few properties may use ObservableField and its siblings ObservableBoolean, ObservableByte, ObservableChar, ObservableShort, ObservableInt, ObservableLong, ObservableFloat, ObservableDouble, and ObservableParcelable. ObservableFields are self-contained observable objects that have a single field. The primitive versions avoid boxing and unboxing during access operations. To use, create a public final field in the data class: 1234567private static class User { public final ObservableField&lt;String&gt; firstName = new ObservableField&lt;&gt;(); public final ObservableField&lt;String&gt; lastName = new ObservableField&lt;&gt;(); public final ObservableInt age = new ObservableInt();} That’s it! To access the value, use the set and get accessor methods: 12user.firstName.set(\"Google\");int age = user.age.get(); Observable CollectionsSome applications use more dynamic structures to hold data. Observable collections allow keyed access to these data objects. ObservableArrayMap is useful when the key is a reference type, such as String. 1234ObservableArrayMap&lt;String, Object&gt; user = new ObservableArrayMap&lt;&gt;();user.put(\"firstName\", \"Google\");user.put(\"lastName\", \"Inc.\");user.put(\"age\", 17); In the layout, the map may be accessed through the String keys: 12345678910111213&lt;data&gt; &lt;import type=\"android.databinding.ObservableMap\"/&gt; &lt;variable name=\"user\" type=\"ObservableMap&amp;lt;String, Object&gt;\"/&gt;&lt;/data&gt;…&lt;TextView android:text='@{user[\"lastName\"]}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt;&lt;TextView android:text='@{String.valueOf(1 + (Integer)user[\"age\"])}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; ObservableArrayList is useful when the key is an integer: 1234ObservableArrayList&lt;Object&gt; user = new ObservableArrayList&lt;&gt;();user.add(\"Google\");user.add(\"Inc.\");user.add(17); In the layout, the list may be accessed through the indices: 1234567891011121314&lt;data&gt; &lt;import type=\"android.databinding.ObservableList\"/&gt; &lt;import type=\"com.example.my.app.Fields\"/&gt; &lt;variable name=\"user\" type=\"ObservableList&amp;lt;Object&gt;\"/&gt;&lt;/data&gt;…&lt;TextView android:text='@{user[Fields.LAST_NAME]}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt;&lt;TextView android:text='@{String.valueOf(1 + (Integer)user[Fields.AGE])}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; Generated BindingThe generated binding class links the layout variables with the Views within the layout. As discussed earlier, the name and package of the Binding may be customized. The Generated binding classes all extend ViewDataBinding. CreatingThe binding should be created soon after inflation to ensure that the View hierarchy is not disturbed prior to binding to the Views with expressions within the layout. There are a few ways to bind to a layout. The most common is to use the static methods on the Binding class.The inflate method inflates the View hierarchy and binds to it all it one step. There is a simpler version that only takes a LayoutInflater and one that takes a ViewGroup as well: 12MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater);MyLayoutBinding binding = MyLayoutBinding.inflate(layoutInflater, viewGroup, false); If the layout was inflated using a different mechanism, it may be bound separately: 1MyLayoutBinding binding = MyLayoutBinding.bind(viewRoot); Sometimes the binding cannot be known in advance. In such cases, the binding can be created using the DataBindingUtil class: 123ViewDataBinding binding = DataBindingUtil.inflate(LayoutInflater, layoutId, parent, attachToParent);ViewDataBinding binding = DataBindingUtil.bindTo(viewRoot, layoutId); Views With IDsA public final field will be generated for each View with an ID in the layout. The binding does a single pass on the View hierarchy, extracting the Views with IDs. This mechanism can be faster than calling findViewById for several Views. For example: 123456789101112131415161718&lt;layout xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;data&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;/data&gt; &lt;LinearLayout android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName}\" android:id=\"@+id/firstName\"/&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.lastName}\" android:id=\"@+id/lastName\"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; Will generate a binding class with: 12public final TextView firstName;public final TextView lastName; IDs are not nearly as necessary as without data binding, but there are still some instances where access to Views are still necessary from code. VariablesEach variable will be given accessor methods. 123456&lt;data&gt; &lt;import type=\"android.graphics.drawable.Drawable\"/&gt; &lt;variable name=\"user\" type=\"com.example.User\"/&gt; &lt;variable name=\"image\" type=\"Drawable\"/&gt; &lt;variable name=\"note\" type=\"String\"/&gt;&lt;/data&gt; will generate setters and getters in the binding: 123456public abstract com.example.User getUser();public abstract void setUser(com.example.User user);public abstract Drawable getImage();public abstract void setImage(Drawable image);public abstract String getNote();public abstract void setNote(String note); ViewStubsViewStubs are a little different from normal Views. They start off invisible and when they either are made visible or are explicitly told to inflate, they replace themselves in the layout by inflating another layout. Because the ViewStub essentially disappears from the View hierarchy, the View in the binding object must also disappear to allow collection. Because the Views are final, a ViewStubProxy object takes the place of the ViewStub, giving the developer access to the ViewStub when it exists and also access to the inflated View hierarchy when the ViewStub has been inflated. When inflating another layout, a binding must be established for the new layout. Therefore, the ViewStubProxy must listen to the ViewStub’s ViewStub.OnInflateListener and establish the binding at that time. Since only one can exist, the ViewStubProxy allows the developer to set an OnInflateListener on it that it will call after establishing the binding. Advanced BindingDynamic VariablesAt times, the specific binding class won’t be known. For example, a RecyclerView.Adapter operating against arbitrary layouts won’t know the specific binding class. It still must assign the binding value during the onBindViewHolder(VH, int). In this example, all layouts that the RecyclerView binds to have an “item” variable. The BindingHolder has a getBinding method returning the ViewDataBinding base. 12345public void onBindViewHolder(BindingHolder holder, int position) { final T item = mItems.get(position); holder.getBinding().setVariable(BR.item, item); holder.getBinding().executePendingBindings();} Immediate BindingWhen a variable or observable changes, the binding will be scheduled to change before the next frame. There are times, however, when binding must be executed immediately. To force execution, use the executePendingBindings() method. Background ThreadYou can change your data model in a background thread as long as it is not a collection. Data binding will localize each variable / field while evaluating to avoid any concurrency issues. Attribute SettersWhenever a bound value changes, the generated binding class must call a setter method on the View with the binding expression. The data binding framework has ways to customize which method to call to set the value. Automatic SettersFor an attribute, data binding tries to find the method setAttribute. The namespace for the attribute does not matter, only the attribute name itself.For example, an expression associated with TextView’s attribute android:text will look for a setText(String). If the expression returns an int, data binding will search for a setText(int) method. Be careful to have the expression return the correct type, casting if necessary. Note that data binding will work even if no attribute exists with the given name. You can then easily “create” attributes for any setter by using data binding. For example, support DrawerLayout doesn’t have any attributes, but plenty of setters. You can use the automatic setters to use one of these. 12345&lt;android.support.v4.widget.DrawerLayout android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" app:scrimColor=\"@{@color/scrim}\" app:drawerListener=\"@{fragment.drawerListener}\"/&gt; Renamed SettersSome attributes have setters that don’t match by name. For these methods, an attribute may be associated with the setter through BindingMethods annotation. This must be associated with a class and contains BindingMethod annotations, one for each renamed method. For example, the android:tint attribute is really associated with setImageTintList(ColorStateList), not setTint. 12345@BindingMethods({ @BindingMethod(type = \"android.widget.ImageView\", attribute = \"android:tint\", method = \"setImageTintList\"),}) It is unlikely that developers will need to rename setters; the android framework attributes have already been implemented. Custom SettersSome attributes need custom binding logic. For example, there is no associated setter for the android:paddingLeft attribute. Instead, setPadding(left, top, right, bottom) exists. A static binding adapter method with the BindingAdapter annotation allows the developer to customize how a setter for an attribute is called. The android attributes have already had BindingAdapters created. For example, here is the one for paddingLeft: 1234567@BindingAdapter(\"android:paddingLeft\")public static void setPaddingLeft(View view, int padding) { view.setPadding(padding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom());} Binding adapters are useful for other types of customization. For example, a custom loader can be called off-thread to load an image. Developer-created binding adapters will override the data binding default adapters when there is a conflict. You can also have adapters that receive multiple parameters. 1234@BindingAdapter({\"bind:imageUrl\", \"bind:error\"})public static void loadImage(ImageView view, String url, Drawable error) { Picasso.with(view.getContext()).load(url).error(error).into(view);} 12&lt;ImageView app:imageUrl=“@{venue.imageUrl}”app:error=“@{@drawable/venueError}”/&gt; This adapter will be called if both imageUrl and error are used for an ImageView and imageUrl is a string and error is a drawable. Custom namespaces are ignored during matching. You can also write adapters for android namespace. Binding adapter methods may optionally take the old values in their handlers. A method taking old and new values should have all old values for the attributes come first, followed by the new values: 123456789@BindingAdapter(\"android:paddingLeft\")public static void setPaddingLeft(View view, int oldPadding, int newPadding) { if (oldPadding != newPadding) { view.setPadding(newPadding, view.getPaddingTop(), view.getPaddingRight(), view.getPaddingBottom()); }} Event handlers may only be used with interfaces or abstract classes with one abstract method. For example: 123456789101112@BindingAdapter(\"android:onLayoutChange\")public static void setOnLayoutChangeListener(View view, View.OnLayoutChangeListener oldValue, View.OnLayoutChangeListener newValue) { if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.HONEYCOMB) { if (oldValue != null) { view.removeOnLayoutChangeListener(oldValue); } if (newValue != null) { view.addOnLayoutChangeListener(newValue); } }} When a listener has multiple methods, it must be split into multiple listeners. For example, View.OnAttachStateChangeListener has two methods: onViewAttachedToWindow() and onViewDetachedFromWindow(). We must then create two interfaces to differentiate the attributes and handlers for them. 12345678@TargetApi(VERSION_CODES.HONEYCOMB_MR1)public interface OnViewDetachedFromWindow { void onViewDetachedFromWindow(View v);}@TargetApi(VERSION_CODES.HONEYCOMB_MR1)public interface OnViewAttachedToWindow { void onViewAttachedToWindow(View v);} Because changing one listener will also affect the other, we must have three different binding adapters, one for each attribute and one for both, should they both be set. 1234567891011121314151617181920212223242526272829303132333435363738394041424344@BindingAdapter(\"android:onViewAttachedToWindow\")public static void setListener(View view, OnViewAttachedToWindow attached) { setListener(view, null, attached);}@BindingAdapter(\"android:onViewDetachedFromWindow\")public static void setListener(View view, OnViewDetachedFromWindow detached) { setListener(view, detached, null);}@BindingAdapter({\"android:onViewDetachedFromWindow\", \"android:onViewAttachedToWindow\"})public static void setListener(View view, final OnViewDetachedFromWindow detach, final OnViewAttachedToWindow attach) { if (VERSION.SDK_INT &gt;= VERSION_CODES.HONEYCOMB_MR1) { final OnAttachStateChangeListener newListener; if (detach == null &amp;&amp; attach == null) { newListener = null; } else { newListener = new OnAttachStateChangeListener() { @Override public void onViewAttachedToWindow(View v) { if (attach != null) { attach.onViewAttachedToWindow(v); } } @Override public void onViewDetachedFromWindow(View v) { if (detach != null) { detach.onViewDetachedFromWindow(v); } } }; } final OnAttachStateChangeListener oldListener = ListenerUtil.trackListener(view, newListener, R.id.onAttachStateChangeListener); if (oldListener != null) { view.removeOnAttachStateChangeListener(oldListener); } if (newListener != null) { view.addOnAttachStateChangeListener(newListener); } }} The above example is slightly more complicated than normal because View uses add and remove for the listener instead of a set method for View.OnAttachStateChangeListener. The android.databinding.adapters.ListenerUtil class helps keep track of the previous listeners so that they may be removed in the Binding Adaper. By annotating the interfaces OnViewDetachedFromWindow and OnViewAttachedToWindow with @TargetApi(VERSION_CODES.HONEYCOMB_MR1), the data binding code generator knows that the listener should only be generated when running on Honeycomb MR1 and new devices, the same version supported by addOnAttachStateChangeListener(View.OnAttachStateChangeListener). ConvertersObject ConversionsWhen an Object is returned from a binding expression, a setter will be chosen from the automatic, renamed, and custom setters. The Object will be cast to a parameter type of the chosen setter. This is a convenience for those using ObservableMaps to hold data. for example: 1234&lt;TextView android:text='@{userMap[\"lastName\"]}' android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; The userMap returns an Object and that Object will be automatically cast to parameter type found in the setter setText(CharSequence). When there may be confusion about the parameter type, the developer will need to cast in the expression. Custom ConversionsSometimes conversions should be automatic between specific types. For example, when setting the background:1234&lt;View android:background=\"@{isError ? @color/red : @color/white}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; Here, the background takes a Drawable, but the color is an integer. Whenever a Drawable is expected and an integer is returned, the int should be converted to a ColorDrawable. This conversion is done using a static method with a BindingConversion annotation: 1234@BindingConversionpublic static ColorDrawable convertColorToDrawable(int color) { return new ColorDrawable(color);} Note that conversions only happen at the setter level, so it is not allowed to mix types like this: 1234&lt;View android:background=\"@{isError ? @drawable/error : @color/white}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"/&gt; Android Studio Support for Data BindingAndroid Studio supports many of the code editing features for data binding code. For example, it supports the following features for data binding expressions: Syntax highlighting Flagging of expression language syntax errors XML code completion References, including navigation (such as navigate to a declaration) and quick documentation Note: Arrays and a generic type, such as the Observable class, might display errors when there are no errors. The Preview pane displays default values for data binding expressions if provided. In the following example excerpt of an element from a layout XML file, the Preview pane displays the PLACEHOLDER default text value in the TextView. 123&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@{user.firstName, default=PLACEHOLDER}\"/&gt; If you need to display a default value during the design phase of your project, you can also use tools attributes instead of default expression values, as described in Designtime Layout Attributes. 转自：https://developer.android.com/topic/libraries/data-binding/index.html#attribute_setters","link":"/2016/05/Data Binding Library/"}],"tags":[{"name":"Android","slug":"Android","link":"/tags/Android/"},{"name":"30天学习打卡","slug":"30天学习打卡","link":"/tags/30天学习打卡/"},{"name":"Flutter","slug":"Flutter","link":"/tags/Flutter/"},{"name":"团队建设","slug":"团队建设","link":"/tags/团队建设/"},{"name":"个人成长","slug":"个人成长","link":"/tags/个人成长/"},{"name":"Android高手进阶视频","slug":"Android高手进阶视频","link":"/tags/Android高手进阶视频/"},{"name":"笔记","slug":"笔记","link":"/tags/笔记/"},{"name":"service","slug":"service","link":"/tags/service/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"字符串","slug":"字符串","link":"/tags/字符串/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"Resources.arsc","slug":"Resources-arsc","link":"/tags/Resources-arsc/"},{"name":"Application","slug":"Application","link":"/tags/Application/"},{"name":"Activity","slug":"Activity","link":"/tags/Activity/"},{"name":"label","slug":"label","link":"/tags/label/"},{"name":"EditText","slug":"EditText","link":"/tags/EditText/"},{"name":"gradle","slug":"gradle","link":"/tags/gradle/"},{"name":"Android开发艺术探索","slug":"Android开发艺术探索","link":"/tags/Android开发艺术探索/"},{"name":"事件分发","slug":"事件分发","link":"/tags/事件分发/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"c语言","slug":"c语言","link":"/tags/c语言/"},{"name":"Data Binding","slug":"Data-Binding","link":"/tags/Data-Binding/"},{"name":"翻译","slug":"翻译","link":"/tags/翻译/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"NDK","slug":"NDK","link":"/tags/NDK/"},{"name":"jni","slug":"jni","link":"/tags/jni/"},{"name":"WebView","slug":"WebView","link":"/tags/WebView/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"scp","slug":"scp","link":"/tags/scp/"},{"name":"vps","slug":"vps","link":"/tags/vps/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"Hook","slug":"Hook","link":"/tags/Hook/"},{"name":"反射","slug":"反射","link":"/tags/反射/"},{"name":"Fiddler","slug":"Fiddler","link":"/tags/Fiddler/"},{"name":"优化","slug":"优化","link":"/tags/优化/"},{"name":"Kotlin","slug":"Kotlin","link":"/tags/Kotlin/"},{"name":"转载","slug":"转载","link":"/tags/转载/"}],"categories":[]}